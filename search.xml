<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[js函数参数传递问题]]></title>
      <url>%2F2018%2F03%2F03%2Fjs%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[JS函数传递参数问题js中所有函数的参数都是按值传递的, 也就是说把函数外部的值复制给函数内部的参数, 就如同把一个变量赋值给另一个变量一样. 基本类型值传递如同基本类型变量复制一样 引用类型则同引用类型变量的复制一样 基本类型值传递定义一个处理函数, 传递给函数一个数值类型的值, 只会修改韩顺局部变量的值. 而不会修改外部变量1234567function handleNum(num) &#123; num++; console.log(&apos;FNnum:&apos;+num); // 11&#125;var num = 10;handleNum(num);console.log(&apos;num:&apos;+num); // 10 引用类型值传递对象传递的是地址, 函数内外的变量会根据引用访问同一个对象, 因为堆中对应的地址只有一个.1234567function handleObj(obj) &#123; obj.name = &apos;jack&apos;; console.log(&apos;FNobj:&apos;+JSON.stringify(obj.name)); // jack&#125;var parson = new Object();handleObj(parson);console.log(&apos;parson:&apos;+JSON.stringify(parson.name)); // jack 看到这个例子后, 很多人会认为, 在局部作用域修改的对象会在全局作用域中反映出来, 就说明引用类型是按引用传递的, 再看接下来一个例子1234567891011function handleObj(obj) &#123; obj.name = &apos;jack&apos;; // ------------------------- obj = new Object(); obj.name = &apos;ruth&apos; // ------------------------- console.log(&apos;FNobj:&apos; + JSON.stringify(obj.name)); // ruth&#125;var person = new Object();handleObj(person);console.log(&apos;person:&apos; + JSON.stringify(person.name)); // jack 这个例子与上面的例子唯一的不同就是添加了两行代码, 一行是为obj重新定义了一个新的对象, 另一行是为这个新对象重新设置了name的属性为’ruth’. 如果引用类型是按照引用传递的话, 全局变量的person的name属性也会修改为’ruth’才对, 但是person的name属性值依然是’jack’; 实际上, 当函数内部重写obj的时候, 这个变量引用就是一个局部对象了, 再函数执行完毕后会立即销毁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie、localStroage与sessionStorage的区别以及用法]]></title>
      <url>%2F2018%2F03%2F01%2Fcookie%E3%80%81localStroage%E4%B8%8EsessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[cookie cookie是服务器发给客户端的特殊信息, 以文本形式存储在客户端,每次请求都会带上cookie 保存在浏览器端保存时间 设置过期时间,浏览器关闭后不会清除,保存在硬盘中, 过期时间到期后失效 不设置过期时间, 保存在内存中, 浏览器关闭后消失单个cookie大小不能超过4kb安全性较低, cookie截获, cookie欺骗应用场景 判断用户是否登陆过网站, 以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。 保持上次登录的时间等信息 保存上次登录查看的页面 浏览计数缺点 大小受限 用户可以禁用cookie, 使功能受限 安全性较低 有些状态不能保存在客户端 每次访问都要传送cookie给服务器，浪费带宽。 cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。 webStoragelocalStorage(本地储存) 永久储存, 除非主动删除, 否则不会消失 sessionStorage(会话储存) 仅在当前会话下有效 在同源窗口始终存在, 浏览器关闭之前 浏览器打开新的同源页面 页面刷新 都还存在 打开一个新的浏览器窗口同一个页面, 同源的session也是不一样的 两者的存储大小都是5MB都保存在客户端不与服务器端进行交互只能储存字符串类型 对于复杂的json格式可以进行stringify和parse来处理获取方式 window. localStroage window. sessionStorage应用场景 localStroage: 长期登录+判断用户是否登录, 长期存储在本地的数据 sessionStorage: 敏感的一次性登录优点 储存空间大 节省网络流量 可在本地直接获取 不需要与服务器进行交互 获取速度块 安全性较高 API window. localStroage window. sessionStorage setItem(key, value): 保存某个数据 getItem(key): 获取某个数据 removeItem(key): 删除某条数据 clear(): 清除所有数据 key(index): 根据索引获取第几条数据的键名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于vue2.x使用axios以及http-proxy-middleware代理处理跨域的问题]]></title>
      <url>%2F2017%2F12%2F02%2F%E5%85%B3%E4%BA%8Evue2-x%E4%BD%BF%E7%94%A8axios%E4%BB%A5%E5%8F%8Ahttp-proxy-middleware%E4%BB%A3%E7%90%86%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[axios现在以及是尤大大推荐使用的了,官方不在维护vue-reresource. 由于是地第一次使用axios, 在使用过程中猜了很大的坑 首先我们使用vue-cli创建的项目, 访问接口肯定是跨域了, 因为我们的本地服务默认的地址一般是localhost:8080 我们的服务器端肯定不是这个, 所以就形成跨域访问, axios不支持jsonp, 所以我们就要使用http-proxy-middleware中间件做代理,http-proxy-middleware的github 安装12345npm i axios --save-devnpm install --save-dev http-proxy-middleware// vue-cli 已经把http-proxy-middleware写在项目依赖里面了 引入axios在项目的src/main.js引入axios1234import axios from &apos;axios&apos;Vue.prototype.$axios = axios;// axios 不支持Vue.use(axios) 配置http-proxy-middleware本地代理打开config/index.js123456789101112131415161718192021222324252627282930313233343536373839var path = require(&apos;path&apos;)module.exports = &#123; build: &#123; env: require(&apos;./prod.env&apos;), index: path.resolve(__dirname, &apos;../dist/index.html&apos;), assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;./&apos;, productionSourceMap: false, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, dev: &#123; env: require(&apos;./dev.env&apos;), port: 8080, autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: &#123; 修改这里修改这里修改这里 &#125;, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false &#125;&#125; 这里是默认的配置, 找到线面的dev对象里面的proxyTable修改 123456789proxyTable: &#123; &apos;/api&apos;: &#123; target:&apos;http://www.baidu.com/api&apos;, changeOrigin:true, pathRewrite:&#123; &apos;^/api&apos;: &apos;&apos; &#125; &#125; &#125; target 的参数就是你要访问的服务器地址, 你在代码里面写/api就等于写了这个地址 , 比如我要访问http://www.baidu.com/api/login这个接口在代码里面只需写/api/login就可以了 至于build/dev.server.js 已经无需修改了, 里面已经有封装好了方法了12345678// proxy api requestsObject.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === &apos;string&apos;) &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(options.filter || context, options))&#125;) 网上好多的解决方案都是在build/dev.server.js里面自己在加内容, 完全不用了 做完上述操作之后一定要重启服务ctrl+c然后npm run dev做完上述操作之后一定要重启服务ctrl+c然后npm run dev做完上述操作之后一定要重启服务ctrl+c然后npm run dev然后我们就可以用axios访问接口了123456789101112131415this.$axios(&#123; method: &quot;POST&quot;, withCredentials: false, url: &quot;/api/login&quot;, data: &#123; name: &quot;1511328705UZVQ&quot;, psd: &quot;123456&quot; &#125;&#125;) .then(function(res) &#123; console.log(res); &#125;) .catch(function(err) &#123; console.log(err);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mock.js模拟生成i假数据]]></title>
      <url>%2F2017%2F12%2F02%2Fmock-js%E6%A8%A1%E6%8B%9F%E7%94%9F%E6%88%90i%E5%81%87%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[mock使用方法很简单, 下面是简单的用法, 详细的用法可以看官方文档, 写的很清楚, 下面的代码直接拷贝到本地html文件, 双击打开即可生成你想要的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;MockJS-demo&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://mockjs.com/bower_components/mockjs/dist/mock.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var Random = Mock.Random; var data = Mock.mock(&#123; &apos;list|4&apos;: [&#123; &apos;id|+1&apos;: 1, &apos;number|1-10&apos;: 7, // 英文姓名 // &apos;name&apos; :&apos;@name&apos;, // // 颜色 // &apos;color&apos;: &apos;@color&apos;, // // 英文标题 // &apos;title&apos;: &apos;@title&apos;, // // 链接 // &apos;url&apos;: &apos;@url(&quot;http&quot;)&apos;, // // 邮箱 // &apos;email&apos;: &apos;@email&apos;, // // 图片 // &apos;image&apos;: Random.image(&apos;200x200&apos;, &apos;#50B347&apos;, &apos;#FFF&apos;, &apos;Mock.js&apos;), // // 时间 // &apos;date&apos;: &apos;@date(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos;, // &apos;date2&apos;: &apos;@dateTime&apos;, // // 汉字 // &apos;ctitle&apos;: &apos;@ctitle(8)&apos;, // // 汉字姓名 // &apos;canme&apos;: &apos;@cname()&apos;, // // 地址 // &apos;cadd&apos;: &apos;@province&apos; + &apos;@city&apos; + &apos;@county&apos;, // // 手机号 // &apos;phone&apos;: /^1[385][1-9]\d&#123;8&#125;/ &#125;] &#125;); console.log(JSON.stringify(data, null, 4))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue-rsource的使用]]></title>
      <url>%2F2017%2F11%2F21%2Fvue-rsource%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装 1npm i vue-resource --save-dev 引入 1import Vueresource from &apos;vue-resource&apos; 注册 1Vue.use(Vueresource) 使用 123456789101112131415161718192021// 便捷方法this.$http.get(&#123;url:&apos;api/index&apos;, headers:&#123;Authorization:&apos;Basic Yxsdlfjui&apos;&#125;&#125;).them((data) =&gt; &#123; // 请求成功&#125;, (error) =&gt; &#123; // 请求失败&#125;)// 底层方法Vue.http(&#123; url:&apos;api/index2&apos;, method: &apos;POST&apos;, data: &#123; param: 1 &#125;&#125;).then((data) =&gt; &#123; // 请求成功&#125;, (error) =&gt; &#123; // 请求失败&#125;) 便捷方法 便捷方法是对底层方法的封装 this.$http.get(url,{data},{opation}) 参数 url: 字符串, 请求地址 data: 对象或者字符串 opation: 对象, 传入的对象来控制请求 返回的response对象 data(对象或者字符串): 服务器返回的数据, 已用JSON.parse解析 ok(布尔值): 当HTTP响应码在200-299区间是true, 表示响应成功 status(数值): HTTP响应码 statusText(字符串): HTTP响应状态文本描述 headers(函数): 响应头信息 返回Promise对象执行HTTP调用后会返回一个Promise对象, 该对象提供了then, catch, finally注册回调函数 1234567891011121314var promise = this.$http.post(&apos;api/index&apos;);promise.this(function(response)&#123; // 成功回调&#125;, function(error)&#123; // 失败回调&#125;)promise.catch(function(error)&#123; // 失败回调&#125;)promise.finally(function()&#123; // 失败或者成功后都会执行此函数&#125;)// 所有回调函数的`this`都指向组件实例 JSONP请求 设置methos的值为JSONP即可 this.$http.jsonp()也可以 修改发给服务器端的数据类型 默认情况下, 发送给服务器请求头的Content-Type为application/json 有时我们需要将数据提交为指定的类型 全局headers配置 1Vue.http.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos; 实例配置 123456789101112131415this.$http.post( &apos;api/index&apos;, // 成功回调 function(data, status, request) &#123; if(status === 200) &#123; // 成功 &#125; &#125;, // 实例配置 &#123; headers: &#123; &apos;Content-Type&apos;:&apos;multipart/form-data&apos; &#125; &#125;) 实力配置优先于全局配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从头开始开发一个vue幻灯片组件]]></title>
      <url>%2F2017%2F11%2F19%2F%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAvue%E5%B9%BB%E7%81%AF%E7%89%87%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[首先新建项目vue init webpack projectName安装依赖包npm i这些就不说了接下来就是构建我们的swiper组件 因为我写的代码不规范, 通不过eslint的检测, 会频繁报警告, 所以不愿意看警告的可以打开\build\webpack.base.conf.js的32行到41行注释掉接下来才开始正式的构建组件 我直接把脚手架工具\src\components\HelloWorld.vue下的HelloWorld组件修改为Swiper, 然后把ruter\router的HelloWorld都修改成Swiper src\router\index.js 123456789101112131415import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Swiper from &apos;@/components/Swiper&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Swiper&apos;, component: Swiper &#125; ]&#125;) \src\components\Swiper.vue 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p&gt;测试&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;Swiper&apos;, data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; npm run dev之后看到这样页面就是创建成功, 可以开始 swiper的基本样式(凑合可以看) 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;div class=&quot;swiper&quot;&gt; &lt;img :src=&quot;imgArr[0].src&quot; alt=&quot;&quot; &gt; // 绑定的属性一定要用v-bind指令 : 是简写 &lt;div&gt; &lt;p&gt;&#123;&#123;imgArr[0].title&#125;&#125;&lt;/p&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; JS部分 1234567891011121314151617&lt;script&gt;export default &#123; name: &apos;Swiper&apos;, props: &#123; imgArr: &#123; // 接受一个数组类型imgArr参数, 默认值是空数组 type: Array, default: [] &#125; &#125;, data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt; app.vue代码 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;Swiper :imgArr=&quot;imgArr&quot;&gt;&lt;/Swiper&gt; // 把imgArr传递给swipr组件 &lt;/div&gt;&lt;/template&gt; js部分 123456789101112131415161718192021222324252627282930313233&lt;script&gt;import Swiper from &apos;./components/Swiper.vue&apos;// 引用swiper组件export default &#123; name: &apos;app&apos;, components : &#123; Swiper // 声明使用Swiper组件 &#125;, data() &#123; return &#123; imgArr: [ &#123; src:require(&quot;./images/1.jpg&quot;), // js中引用图片路径一定要用require关键字, html和css部分不需要 title: &apos;1.jpg&apos; &#125;, &#123; src:require(&quot;./images/2.jpg&quot;), title: &apos;2.jpg&apos; &#125;, &#123; src:require(&quot;./images/3.jpg&quot;), title: &apos;3.jpg&apos; &#125;, &#123; src:require(&quot;./images/4.jpg&quot;), title: &apos;4.jpg&apos; &#125;, ] &#125; &#125;&#125;&lt;/script&gt; 现在的页面应该是接下来我们该去写切换逻辑部分 首先是把图片标号改成图片数组的长度, 不能写死我们修改swiper.vue内的代码 接下来是点击编号跳转到相应的图片, 通过switchImg函数进行跳转函数就是修改当前组件的currentNum, 达到显示哪一张图片 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;div class=&quot;swiper&quot;&gt; &lt;img :src=&quot;imgArr[currentNum].src&quot; alt=&quot;&quot; &gt; &lt;div&gt; &lt;p&gt;&#123;&#123;imgArr[currentNum].title&#125;&#125;&lt;/p&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in imgArr&quot;&gt; &lt;a @click=&quot;switchImg(index)&quot; href=&quot;javascripe:;&quot;&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;Swiper&apos;, props: &#123; imgArr: &#123; type: Array, default: [] &#125; &#125;, data () &#123; return &#123; currentNum:0 &#125; &#125;, methods: &#123; switchImg(index) &#123; this.currentNum = index; &#125; &#125;&#125;&lt;/script&gt; 接下来就是左右切换按钮跳转, 我们使用vue的计算属性特性 12345678910111213141516computed: &#123; nextNum() &#123; if (this.currentNum === 0) &#123; return this.imgArr.length-1 &#125; else &#123; return this.currentNum - 1 &#125; &#125;, preNum() &#123; if (this.currentNum === this.imgArr.length-1) &#123; return 0 &#125; else &#123; return this.currentNum + 1 &#125; &#125; &#125; 只需上一页下一页的按钮添加同样的事件, 把以上两个计算属性传入函数即可1234567&lt;span @click=&quot;switchImg(nextNum)&quot;&gt;&lt;a href=&quot;javascripe:;&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/span&gt; &lt;ul&gt; &lt;li @click=&quot;switchImg(index)&quot; v-for=&quot;(item, index) in imgArr&quot;&gt; &lt;a href=&quot;javascripe:;&quot;&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span @click=&quot;switchImg(preNum)&quot;&gt;&lt;a href=&quot;javascripe:;&quot;&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt; 接下来就是加入定时切换的功能, 我们只需要添加一个定时器即可, 再组件构建完毕就开始执行 12345interval() &#123; this.inv = setInterval(() =&gt; &#123; this.switchImg(this.preNum); &#125;,this.time) &#125; 再添加一个传入的参数, 默认值是1000(1秒) 12345 time: &#123; type: Number, default: 1000&#125; 再组件初始化完毕后开始执行123created() &#123; this.interval();&#125; 再一个功能就是, 再移入的时候清空计数器, 移除之后再重启计时器12345678// 清除定时器clearTime() &#123; clearInterval(this.inv) &#125;, // 重启定时器 setTime() &#123; this.interval(); &#125; 再最外层的div加上两个出发函数1&lt;div class=&quot;hello&quot; @mouseover=&quot;clearTime&quot; @mouseout=&quot;setTime&quot;&gt; 最后一个功能就是, 是否自动播放加入一个可传入参数autoPlay1234autoPlay: &#123; type: Boolean, default: true &#125; 然后处理一下刚才定义好的重启定时器和初始化完毕钩子函数12345678910setTime() &#123; if(this.autoPlay) &#123; this.interval(); &#125; &#125; created() &#123; if(this.autoPlay) &#123; this.interval(); &#125; &#125; 此时一个简单的swiper组件就构建完毕, 可传入一个图片地址数组, 一个自动播放事件, 是否自动播放三个参数项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解Async和Await]]></title>
      <url>%2F2017%2F10%2F30%2F%E5%9B%BE%E8%A7%A3Async%E5%92%8CAwait%2F</url>
      <content type="text"><![CDATA[JavaScript ES7的async/await语法让异步promise操作起来更方便。如果你需要从多个数据库或者接口按顺序异步获取数据，你可能最终写出一坨纠缠不清的promise与回调。然而使用async/await可以让我们用更加可读、可维护的方式来表达这种逻辑。 这篇教程以图表与简单例子来阐述JS async/await的语法与运行机理。 在深入之前，我们先简单回顾一下promise，如果对这方面概念有自信，大可自行跳过。 Promise在JS的世界里，一个promise抽象表达一个非阻塞（阻塞指一个任务开始后，要等待该任务执行结果产生之后才继续执行后续任务）的异步流程，类似于Java的Futrue或者C#的Task。 Promise最典型的使用场景是网络或其他I/O操作（如读取一个文件或者发送一个HTTP请求）。与其阻塞住当前的执行“线程”，我们可以产生一个异步的promise，然后用then方法来附加一个回调，用于执行该promise完成之后要做的事情。回调自身也可以返回一个promise，如此我就可以将多个promise串联。 为方便说明，假定后续所有的例子都已经引入了request-promise 库： 1var rp = require(&apos;request-promise&apos;); 然后我们就可以如此发送一个简单的HTTP GET请求并获得一个promise返回值： 1const promise = rp(&apos;http://example.com/&apos;) 现在来看个例子： 123456console.log(&apos;Starting Execution&apos;);const promise = rp(&apos;http://example.com/&apos;);promise.then(result =&gt; console.log(result));console.log(&quot;Can&apos;t know if promise has finished yet...&quot;); 我们在第3行产生了一个promise，然后在第4行附上了一个回调函数。返回的promise是异步的，所以当执行的第6行的时候，我们无法确定这个promise有没有完成，多次执行可能有不同的结果（译者：浏览器里执行多少次，这里promise都会是未完成状态）。概括来说，promise之后的代码跟promise自身是并发的（译者：对这句话有异议者参见本文最后一节的并发说明）。 并不存在一种方法可以让当前的执行流程阻塞直到promise完成，这一点与Java的Futrue.get相异。JS里，我们无法直接原地等promise完成，唯一可以用于提前计划promise完成后的执行逻辑的方式就是通过then附加回调函数。 下面的图表描绘了上面代码例子的执行过程： Promise的执行过程，调用“线程”无法直接等待promise结果。唯一规划promise之后逻辑的方法是使用then方法附加一个回调函数。 通过then 附加的回调函数只会在promise成功是被触发，如果失败了（比如网络异常），这个回调不会执行，处理错误需要通过catch 方法： 123rp(&apos;http://example.com/&apos;). then(() =&gt; console.log(&apos;Success&apos;)). catch(e =&gt; console.log(`Failed: $&#123;e&#125;`)) 最后，为了方便试验功能，我们可以直接创建一些“假想”的promise，使用Promise.resolve生成会直接成功或失败的promise 结果： 123456789101112const success = Promise.resolve(&apos;Resolved&apos;);// Will print &quot;Successful result: Resolved&quot;success. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`))const fail = Promise.reject(&apos;Err&apos;);// Will print &quot;Failed with: Err&quot;fail. then(result =&gt; console.log(`Successful result: $&#123;result&#125;`)). catch(e =&gt; console.log(`Failed with: $&#123;e&#125;`)) 问题——组合多个Promise只使用一个单次的promise非常简单。然而如果我们需要编写一个非常复杂了异步逻辑，我们可能需要将若干个promise组合起来。写许多的then语句以及匿名函数很容易失控。 比如，我们需要实现以下逻辑： 发起一个HTTP请求，等待结果并将其输出 再发起两个并发的HTTP请求 当两个请求都完成时，一起输出他们 下面的代码演示如何达到这个要求： 12345678910111213141516// Make the first callconst call1Promise = rp(&apos;http://example.com/&apos;);call1Promise.then(result1 =&gt; &#123; // Executes after the first request has finished console.log(result1); const call2Promise = rp(&apos;http://example.com/&apos;); const call3Promise = rp(&apos;http://example.com/&apos;); return Promise.all([call2Promise, call3Promise]);&#125;).then(arr =&gt; &#123; // Executes after both promises have finished console.log(arr[0]); console.log(arr[1]);&#125;) 我们先呼叫第一次HTTP请求，然后预备一个在它完成时执行的回调（第1-3行）。在回调里，我们为另外两次请求制造了promise（第8-9行）。这两个promise并发运行，我们需要计划一个在两个都完成时执行的回调，于是，我们通过Promise.all（第11行）来讲他们合并。这第一个回调的返回值是一个promise，我们再添加一个then来输出结果（第12-16行）。 以下图标描绘这个计算过程： 将promise组合的计算过程。使用“Promise.all”将两个并发的promise合并成一个。 为了一个简单的例子，我们最终写了两个then回调以及一个Promise.all来同步两个并发promise。如果我们还想再多做几个异步操作或者添加一些错误处理会怎样？这种实现方案最终很容变为纠缠成一坨的then、Promise.all以及回调匿名函数。 Async函数一个async函数是定义会返回promise的函数的简便写法。 比如，以下两个定义是等效的： 12345678function f() &#123; return Promise.resolve(&apos;TEST&apos;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; return &apos;TEST&apos;;&#125; 相似地，会抛出错误的async函数等效于返回将失败的promise 的函数：12345678function f() &#123; return Promise.reject(&apos;Error&apos;);&#125;// asyncF is equivalent to f!async function asyncF() &#123; throw &apos;Error&apos;;&#125; Await以前，当我们产生一个promise，我们无法同步地等待它完成，我们只能通过then注册一个回调函数。不允许直接等待一个promise是为了鼓励开发者写非阻塞的代码，不然开发者会更乐意写阻塞的代码，因为这样比promise和回调简单。 然而，为了同步多个promise，我们需要它们互相等待，换句话说，如果一个操作本身就是异步的（比如，用promise包装的），它应该具备能力等待另一个异步操作先完成。但是JS解释器如何知道一个操作是不是在一个promise里的？ 答案就是async关键字，所有的async函数一定会返回一个promise。所以，JS解释器也可以确信async函数里操作是用promise包装的异步过程。于是也就可以允许它等待其他promise。 键入await关键字，它只能在async函数内使用，让我们可以等待一个promise。如果在async函数外使用promise，我们依然需要使用then和回调函数：123456789async function f()&#123; // response will evaluate as the resolved value of the promise const response = await rp(&apos;http://example.com/&apos;); console.log(response);&#125;// We can&apos;t use await outside of async function.// We need to use then callbacks ....f().then(() =&gt; console.log(&apos;Finished&apos;)); 现在我们来看看我们可以如何解决之前提到的问题：12345678910111213141516171819// Encapsulate the solution in an async functionasync function solution() &#123; // Wait for the first HTTP call and print the result console.log(await rp(&apos;http://example.com/&apos;)); // Spawn the HTTP calls without waiting for them - run them concurrently const call2Promise = rp(&apos;http://example.com/&apos;); // Does not wait! const call3Promise = rp(&apos;http://example.com/&apos;); // Does not wait! // After they are both spawn - wait for both of them const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);&#125;// Call the async functionsolution().then(() =&gt; console.log(&apos;Finished&apos;)); 上面的片段，我们将逻辑分装在一个async函数里。这样我们就可以直接对promise使用await了，也就规避了写then回调。最后我们调用这个async函数，然后按照普通的方式使用返回的promise。 要注意的是，在第一个例子里（没有async/await），后面两个promise是并发的。所以我们在第7-8行也是如此，然后直到11-12行才用await来等待两个promise都完成。这之后，我们可以确信两个promise都已经完成（与之前Promise.all(…).then(…)类似）。 计算流程跟之前的图表描绘的一样，但是代码变得更加已读与直白。 事实上，async/await其实会翻译成promise与then回调（译者：babel其实是翻译成generator语法，再通过类似co的函数运行，co内部运行机制离不开promise）。每次我们使用await，解释器会创建一个promise然后把async函数的后续代码放到then回调里。 我们来看看以下的例子：12345async function f() &#123; console.log(&apos;Starting F&apos;); const result = await rp(&apos;http://example.com/&apos;); console.log(result);&#125; f函数的内在运行过程如下图所描绘。因为f标记了async，它会与它的调用者“并发”：函数f启动并产生一个promise。在这一刻，函数剩下的部分都会被封装到一个回调函数里，并被计划在promise完成之后执行。 错误处理在之前的例子里，我们大多假定promise会成功，然后await一个promise的返回值。如果我们等待的promise失败了，会在async函数里产生一个异常，我们可以使用标准的try/catch来处理它1234567async function f() &#123; try &#123; const promiseResult = await Promise.reject(&apos;Error&apos;); &#125; catch (e)&#123; console.log(e); &#125;&#125; 如果async函数不处理这个异常，不管是这异常是因为promise是被reject了还是其他的bug，这个函数都会返回一个被reject掉的promise：123456789101112131415161718async function f() &#123; // Throws an exception const promiseResult = await Promise.reject(&apos;Error&apos;);&#125;// Will print &quot;Error&quot;f(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err))async function g() &#123; throw &quot;Error&quot;;&#125;// Will print &quot;Error&quot;g(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) 这就让我们可以使用熟悉的方式来处理错误。 扩展说明async/await是一个对promise进行补充的语法部件，它能让我们写更少的重复代码来使用promise。然而，async/await并不能彻底取代普通的promise。比如，如果我们在一个普通的函数或者全局作用域里使用一个async函数，我们无法使用await，也就只能求助于原始的promise 用法：1234567async function fAsync() &#123; // actual return value is Promise.resolve(5) return 5;&#125;// can&apos;t call &quot;await fAsync()&quot;. Need to use then/catchfAsync().then(r =&gt; console.log(`result is $&#123;r&#125;`)); 我通常会把大部分的异步逻辑封装在一个或少量几个async函数里，然后在非async的代码区域里使用，这样就可以尽量减少书写then或catch回调。 async / await是让promise用起来更简洁的语法糖。所有的async / await都可以用普通的promise来实现。所有总结来说，这只是个代码样式与简洁的问题。 学院派的人会指出，并发与并行是有区别的（译者：所以前文都是说并发，而非并行）。参见Rob Pike的讲话或者我之前的博文。并发是组合多个独立过程来一起工作，并行是多个过程同时执行。并发是体现在应用的结构设计，并行是实际执行的方式。 我们来看看一个多线程应用的例子。将应用分割成多个线程是该应用并发模型的定义，将这些线程放到可用的cpu核心上执行是确立它的并行。一个并发的系统也可以在一个单核处理器上正常运行，但这种情况并不是并行。以这种方式理解，promise可以将一个程序分解成多个并发的模块，它们或许，也可能并不会并行执行。JS是否并行执行要看解释器自身的实现。比如，NodeJS是单线程的，如果一个promise里有大量的CPU操作（非I/O操作），你可能感受不到太多并行。然而如果你用像nashorn这样的工具把代码编译成java字节码，理论上你可以把繁重的CPU操作放到其他内核上来获得平行效果。于是在我的观点中，promise（不管是裸的还是有async/await）只是作用于定义JS应用的并发模型（而非确定逻辑是否会并行运行）。 关于本文 译者：@安秦 译文：https://zhuanlan.zihu.com/p/30500864 作者：@Nikolay 原文：http://nikgoozev.com/2017/10/01/async-await/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组：进化与性能]]></title>
      <url>%2F2017%2F10%2F21%2F%E6%B7%B1%E5%85%A5JavaScript%E6%95%B0%E7%BB%84%EF%BC%9A%E8%BF%9B%E5%8C%96%E4%B8%8E%E6%80%A7%E8%83%BD%2F</url>
      <content type="text"><![CDATA[正式开始前需要声明，本文并不是要讲解 JavaScript 数组基础知识，也不会涉及语法和使用案例。本文讲得更多的是内存、优化、语法差异、性能、近来的演进。 在使用 JavaScript 前，我对 C、C++、C# 这些已经颇为熟悉。与许多 C/C++ 开发者一样，JavaScript 给我的第一印象并不好。 Array 是主要原因之一。JavaScript 数组不是连续（contiguous）的，其实现类似哈希映射（hash-maps）或字典（dictionaries）。我觉得这有点像是一门 B 级语言，数组实现根本不恰当。自那以后，JavaScript 和我对它的理解都发生了变化，很多变化。 为什么说 JavaScript 数组不是真正的数组在聊 JavaScript 之前，先讲讲 Array 是什么。 数组是一串连续的内存位置，用来保存某些值。注意重点，“连续”（continuous，或 contiguous），这很重要。 上图展示了数组在内存中存储方式。这个数组保存了 4 个元素，每个元素 4 字节。加起来总共占用了 16 字节的内存区。 假设我们声明了 tinyInt arr[4];，分配到的内存区的地址从 1201 开始。一旦需要读取 arr[2]，只需要通过数学计算拿到 arr[2] 的地址即可。计算 1201 + (2 X 4)，直接从 1209 开始读取即可。 JavaScript 中的数据是哈希映射，可以使用不同的数据结构来实现，如链表。所以，如果在 JavaScript 中声明一个数组 var arr = new Array(4)，计算机将生成类似上图的结构。如果程序需要读取 arr[2]，则需要从 1201 开始遍历寻址。 以上急速 JavaScript 数组与真实数组的不同之处。显而易见，数学计算比遍历链表快。就长数组而言，情况尤其如此。. JavaScript 数组的进化不知你是否记得我们对朋友入手的 256MB 内存的电脑羡慕得要死的日子？而今天，8GB 内存遍地都是。 与此类似，JavaScript 这门语言也进化了不少。从 V8、SpiderMonkey 到 TC39 和与日俱增的 Web 用户，巨大的努力已经使 JavaScript 成为世界级必需品。一旦有了庞大的用户基础，性能提升自然是硬需求。 实际上，现代 JavaScript 引擎是会给数组分配连续内存的 —— 如果数组是同质的（所有元素类型相同）。优秀的程序员总会保证数组同质，以便 JIT（即时编译器）能够使用 c 编译器式的计算方法读取元素。 不过，一旦你想要在某个同质数组中插入一个其他类型的元素，JIT 将解构整个数组，并按照旧有的方式重新创建。 因此，如果你的代码写得不太糟，JavaScript Array 对象在幕后依然保持着真正的数组形式，这对现代 JS 开发者来说极为重要。 此外，数组跟随 ES2015/ES6 有了更多的演进。TC39 决定引入类型化数组（Typed Arrays），于是我们就有了 ArrayBuffer。 ArrayBuffer 提供一块连续内存供我们随意操作。然而，直接操作内存还是太复杂、偏底层。于是便有了处理 ArrayBuffer 的视图（View）。目前已有一些可用视图，未来还会有更多加入。 123var buffer = new ArrayBuffer(8);var view = new Int32Array(buffer);view[0] = 100; 了解更多关于类型化数组（Typed Arrays）的知识，请访问 MDN 文档。 高性能、高效率的类型化数组在 WebGL 之后被引入。WebGL 工作者遇到了极大的性能问题，即如何高效处理二进制数据。另外，你也可以使用 SharedArrayBuffer 在多个 Web Worker 进程之间共享数据，以提升性能。 从简单的哈希映射到现在的 SharedArrayBuffer，这相当棒吧？ 旧式数组 vs 类型化数组：性能前面已经讨论了 JavaScript 数组的演进，现在来测试现代数组到底能给我们带来多大收益。下面是我在 Mac 上使用 Node.js 8.4.0 进行的一些微型测试结果。 旧式数组：插入1234567var LIMIT = 10000000;var arr = new Array(LIMIT);console.time(&quot;Array insertion time&quot;);for (var i = 0; i&lt; LIMIT; i++) &#123; arr[i] = i;&#125;console.timeEnd(&quot;Array insertion time&quot;); 用时：55ms Typed Array：插入12345678var LIMIT = 10000000;var buffer = new ArrayBuffer(LIMIT * 4);var arr = new Int32Array(buffer);console.time(&quot;ArrayBuffer insertion time&quot;);for (var i = 0; i &lt; LIMIT; i++) &#123; arr[i] = i;&#125;console.timeEnd(&quot;ArrayBuffer insertion time&quot;); 用时：52ms 擦，我看到了什么？旧式数组和 ArrayBuffer 的性能不相上下？不不不。请记住，前面提到过，现代编译器已经智能化，能够将元素类型相同的传统数组在内部转换成内存连续的数组。第一个例子正是如此。尽管使用了 new Array(LIMIT)，数组实际依然以现代数组形式存在。 接着修改第一例子，将数组改成异构型（元素类型不完全一致）的，来看看是否存在性能差异。 旧式数组：插入（异构）12345678var LIMIT = 10000000;var arr = new Array(LIMIT);arr.push(&#123;a: 22&#125;);console.time(&quot;Array insertion time&quot;);for (var i = 0; i&lt; LIMIT; i++) &#123; arr[i] = i;&#125;console.timeEnd(&quot;Array insertion time&quot;); 用时：1207ms 改变发生在第 3 行，添加一条语句，将数组变为异构类型。其余代码保持不变。性能差异表现出来了，慢了 22 倍。 旧式数组：读取12345678var LIMIT = 10000000;var arr = new Array(LIMIT);arr.push(&#123;a: 22&#125;);for (var i = 0; i&lt; LIMIT; i++) &#123; //arr[i] = i; p = arr[i];&#125;console.timeEnd(&quot;Array read time&quot;); 用时：196ms Typed Array：读取123456789101112var LIMIT = 10000000;var buffer = new ArrayBuffer(LIMIT * 4);var arr = new Int32Array(buffer);console.time(&quot;ArrayBuffer insertion time&quot;);for (var i = 0; i&lt; LIMIT; i++) &#123; arr[i] = i;&#125;console.time(&quot;ArrayBuffer read time&quot;);for (var i = 0; i &lt; LIMIT; i++) &#123; var p = arr[i];&#125;console.timeEnd(&quot;ArrayBuffer read time&quot;); 用时：27ms 结论类型化数组的引入是JavaScript发展历程中的一大步。Int8Array，Uint8Array，Uint8ClampedArray，Int16Array，Uint16Array，Int32Array，Uint32Array，Float32Array，Float64Array，这些是类型化数组视图，使用原生字节序（与本机相同）。我们还可以使用 DataView 创建自定义视图窗口。希望未来会有更多帮助我们轻松操作 ArrayBuffer 的 DataView 库。 JavaScript 数组的演进非常 nice。现在它们速度快、效率高、健壮，在内存分配时也足够智能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编写css代码的20个建议]]></title>
      <url>%2F2017%2F09%2F04%2F%E7%BC%96%E5%86%99css%E4%BB%A3%E7%A0%81%E7%9A%8420%E4%B8%AA%E5%BB%BA%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[明白何谓Margin Collapse不同于其他很多属性，盒模型中垂直方向上的Margin会在相遇时发生崩塌，也就是说当某个元素的底部Margin与另一个元素的顶部Margin相邻时，只有二者中的较大值会被保留下来，可以从下面这个简单的例子来学习: 1234567891011121314.square &#123; width: 80px; height: 80px; &#125; .red &#123; background-color: #F44336; margin-bottom: 40px; &#125; .blue &#123; background-color: #2196F3; margin-top: 30px; &#125; 在上述例子中我们会发现，红色和蓝色方块的外边距并没有相加得到70px，而是只有红色的下外边距保留了下来。我们可以使用一些方法来避免这种行为，不过建议来说还是尽量统一使用margin-bottom属性，这样就显得和谐多了。 使用Flexbox进行布局在传统的布局中我们习惯使用Floats或者inline-blocks，不过它们更适合于格式化文档，而不是整个网站。而Flexbox则是专门的用于进行布局的工具。Flexbox模型允许开发者使用很多便捷可扩展的属性来进行布局，估计你一旦用上就舍不得了: 1234.container &#123; display: flex; /* Don&apos;t forget to add prefixes for Safari */display: -webkit-flex; &#125; 我们已经在Tutorialzine上提供了很多的关于Flexbox的介绍与小技巧，譬如5 Flexbox Techniques You Need to Know About。 使用CSS Reset 虽然这些年来随着浏览器的迅速发展与规范的统一，浏览器特性碎片化的情况有所改善，但是在不同的浏览器之间仍然存在着很多的行为差异。而解决这种问题的最好的办法就是使用某个CSS Reset来为所有的元素设置统一的样式，保证你能在相对统一干净的样式表的基础上开始工作。目前流行的Reset库有 normalize.css, minireset以及 ress ，它们都可以修正很多已知的浏览器之间的差异性。而如果你不打算用某个外在的库，那么建议可以使用如下的基本规则: 12345* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; 上面的规则看起来没啥用，不过如果不同的浏览器在默认情况下为你设置了不同的外边距/内边距的默认值，还是会挺麻烦的。 一切应为Border-box虽然很多初学者并不了解box-sizing这个属性，但是它确实相当的重要。而最好的理解它的方式就是看看它的两种取值: 默认值为content-box，即当我们设置某个元素的heght/width属性时，仅仅会作用于其内容尺寸。而所有的内边距与边都是在其之上的累加，譬如某个&lt;div&gt;标签设置为宽100，内边距为10，那么最终元素会占用120(100 + 2*10)的像素。 border-box:内边距与边是包含在了width/height之内，譬如设置了width:100px的&lt;div&gt;无论其内边距或者边长设置为多少，其占有的大小都是100px。 将元素设置为border-box会很方便你进行样式布局，这样的话你就可以在父元素设置高宽限制而不担心子元素的内边距或者边打破了这种限制。 以背景图方式使用Images如果需要在响应式的环境下展示图片，有个简单的小技巧就是使用该图片作为某个&lt;div&gt;的背景图而不是直接使用img标签。基于这种方式配合上background-size与background-position这两个属性，可以很方便地按比例缩放: 1234567891011121314151617img &#123; width: 300px; height: 200px; &#125; div &#123; width: 300px; height: 200px; background: url(&apos;http://cdn.tutorialzine.com/wp-content/uploads/2016/08/bicycle.jpg&apos;); background-position: center center; background-size: cover; &#125; section&#123; float: left; margin: 15px; &#125; 不过这种方式也是存在缺陷的，譬如你无法设置图片的懒加载、图片无法被搜索引擎或者其他类似的工具抓取到，有个不错的属性叫object-fit可以解决这个问题，不过该属性目前的浏览器支持并不是很完善。 注释格式优化CSS虽然谈不上一门编程语言但是其仍然需要添加注释以保障整体代码的可读性，只要添加些简单的注释不仅可以方便你更好地组织整个样式表还能够让你的同事或者未来的自己更好地理解。对于CSS中整块的注释或者使用在Media-Query中的注释，建议是使用如下形式： 12345/*--------------- #Header ---------------*/header &#123; &#125;header nav &#123; &#125;/*--------------- #Slideshow ---------------*/.slideshow &#123; &#125; 而设计的细节说明或者一些不重要的组件可以用如下单行注释的方式: 123/* Footer Buttons */ .footer button &#123; &#125; .footer button:hover &#123; &#125; 同时，不要忘了CSS中是没有//这种注释方式的: 12345/* Do */p &#123; padding: 15px; /*border: 1px solid #222;*/ &#125;/* Don&apos;t */p &#123; padding: 15px; // border: 1px solid #222; &#125; 使用Kebab-case命名变量对于样式类名或者ID名的命名都需要在多个单词之间添加-符号，CSS本身是大小写不敏感的因此你是用不了camelCase的，另一方面，很久之前也不支持下划线，所以现在的默认的命名方式就是使用-: 12345/* Do */ .footer-column-left &#123; &#125; /* Don&apos;t */ .footerColumnLeft &#123; &#125; .footer_column_left &#123; &#125; 而涉及到具体的变量命名规范时，建议是使用BEM规范，只要遵循一些简单的原则即可以保证基于组件风格的命名一致性。你也可以参考CSS Tricks来获得更多的细节描述。 避免重复代码大部分元素的CSS属性都是从DOM树根部继承而来，这也是其命名为级联样式表的由来。我们以font属性为例，该属性往往是继承自父属性，因此我们并不需要再单独地为元素设置该属性。我们只需要在html或者body中添加该属性然后使其层次传递下去即可: 123html &#123; font: normal 16px/1.4 sans-serif; &#125; 使用transform添加CSS Animations不建议直接改变元素的width与height属性或者left/top/bottom/right这些属性来达到动画效果，而应该优先使用transform()属性来提供更平滑的变换效果，并且能使得代码的可读性会更好: 12345678.ball &#123; left: 50px; transition: 0.4s ease-out; &#125;/* Not Cool*/.ball.slide-out &#123; left: 500px; &#125;/* Cool*/.ball.slide-out &#123; transform: translateX(450px); &#125; Transform的几个属性translate、rotate、scale都具有比较好的浏览器兼容性可以放心使用。 不要重复造轮子现在CSS社区已经非常庞大，并且不断地有新的各式各样的库开源出来。这些库可以帮助我们解决从小的代码片到用于构建完整的响应式应用的全框架。所以如果下次你再碰到什么CSS问题的时候，在打算撸起袖子自己上之前可以尝试在GitHUB或者CodePen上搜索可行方案。 尽可能使用低优先级的选择器并不是所有的CSS选择器的优先级都一样，很多初学者在使用CSS选择器的时候都是考虑以新的特性去复写全部的继承特性，不过这一点在某个元素多状态时就麻烦了，譬如下面这个例子: 123456789101112a&#123; color: #fff; padding: 15px; &#125; a#blue-btn &#123; background-color: blue; &#125; a.active &#123; background-color: red; &#125; 我们本来希望将.active类添加到按钮上然后使其显示为红色，不过在上面这个例子中很明显起不了作用，因为button已经以ID选择器设置过了背景色，也就是所谓的Higher Selector Specificity。一般来说，选择器的优先级顺序为：ID(#id) &gt; Class(.class) &gt; Type(header) 避免使用!important认真的说，千万要避免使用!important，这可能会导致你在未来的开发中无尽的属性重写，你应该选择更合适的CSS选择器。而唯一的可以使用!important属性的场景就是当你想去复写某些行内样式的时候，不过行内样式本身也是需要避免的。 使用text-transform属性设置文本大写 12345&lt;div class=&quot;movie-poster&quot;&gt;Star Wars: The Force Awakens&lt;/div&gt; .movie-poster &#123; text-transform: uppercase; &#125; Em, Rem, 以及 Pixel已经有很多关于人们应该如何使用em，rem，以及px作为元素尺寸与文本尺寸的讨论，而笔者认为，这三个尺寸单位都有其适用与不适用的地方。不同的开发与项目都有其特定的设置，因此并没有通用的规则来决定应该使用哪个单位，这里是我总结的几个考虑: em – 其基本单位即为当前元素的font-size值，经常适用于media-queries中，em是特别适用于响应式开发中。 rem – 其是相对于html属性的单位，可以保证文本段落真正的响应式尺寸特性。 px – Pixels 并没有任何的动态扩展性，它们往往用于描述绝对单位，并且可以在设置值与最终的显示效果之间保留一定的一致性。 在大型项目中使用预处理器估计你肯定听说过 Sass, Less, PostCSS, Stylus这些预处理器与对应的语法。Preprocessors可以允许我们将未来的CSS特性应用在当前的代码开发中，譬如变量支持、函数、嵌套式的选择器以及很多其他的特性，这里我们以Sass为例: 12345678910$accent-color: #2196F3; a &#123; padding: 10px 15px; background-color: $accent-color; &#125; a:hover &#123; background-color: darken($accent-color,10%); &#125; 使用Autoprefixers来提升浏览器兼容性使用特定的浏览器前缀是CSS开发中常见的工作之一，不同的浏览器、不同的属性对于前缀的要求也不一样，这就使得我们无法在编码过程中记住所有的前缀规则。并且在写样式代码的时候还需要加上特定的浏览器前缀支持也是个麻烦活，幸亏现在也是有很多工具可以辅助我们进行这样的开发: Online tools: Autoprefixer Text editor plugins: Sublime Text, Atom Libraries: Autoprefixer (PostCSS) 在生产环境下使用Minified代码为了提升页面的加载速度，在生产环境下我们应该默认使用压缩之后的资源代码。在压缩的过程中，会将所有的空白与重复剔除掉从而减少整个文件的体积大小。当然，经过压缩之后的代码毫无可读性，因此在开发阶段我们还是应该使用普通的版本。对于CSS的压缩有很多的现行工具: Online tools – CSS Minifier (API included), CSS Compressor Text editor plugins: Sublime Text, Atom Libraries: Minfiy (PHP), CSSO and CSSNano (PostCSS, Grunt, Gulp) 多参阅Caniuse不同的浏览器在兼容性上差异很大，因此如果我们可以针对我们所需要适配的浏览器，在caniuse上我们可以查询某个特性的浏览器版本适配性，是否需要添加特定的前缀或者在某个平台上是否存在Bug等等。不过光光使用caniuse肯定是不够的，我们还需要使用些额外的服务来进行检测。 Validate:校验对于CSS的校验可能不如HTML校验或者JavaScript校验那么重要，不过在正式发布之前用Lint工具校验一波你的CSS代码还是很有意义的。它会告诉你代码中潜在的错误，提示你一些不符合最佳实践的代码以及给你一些提升代码性能的建议。就像Minifers与Autoprefixers，也有很多可用的工具: Online tools: W3 Validator, CSS Lint Text editor plugins: Sublime Text, Atom Libraries: stylelint (Node.js, PostCSS), css-validator (Node.js)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿微信联系人列表滑动字母索引]]></title>
      <url>%2F2017%2F08%2F15%2F%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%94%E7%B3%BB%E4%BA%BA%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%E5%AD%97%E6%AF%8D%E7%B4%A2%E5%BC%95%2F</url>
      <content type="text"><![CDATA[今天做到了一个联系人列表的需求, 要求和微信的一样! 写出来分享给大家, 使用了jq和doT模版引擎(doT模版教程) 首先对数据源进行数据排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 数据排序 function sortData(data) &#123; var letterArr = []; for (var i = 0; i &lt; data.length; i++) &#123; for (var j = 0; j &lt; data.length; j++) &#123; if (data[i].flag &lt; data[j].flag) &#123; var temp = data[i]; data[i] = data[j]; data[j] = temp; &#125; &#125; &#125; if (f_check_uppercase(data[0].flag)) &#123; letterArr.push(data[0].flag) &#125; else &#123; letterArr.push(&apos;#&apos;) &#125; for (var i = 0; i &lt; data.length; i++) &#123; if(f_check_uppercase(data[0].flag)) &#123; data[0].flagLetter = data[0].flag &#125; else &#123; data[0].flagLetter = &apos;#&apos; &#125; if (i&gt;0) &#123; if (data[i].flag !== data[i-1].flag) &#123; if (f_check_uppercase(data[i].flag)) &#123; data[i].flagLetter = data[i].flag; letterArr.push(data[i].flag) &#125; else &#123; data[i].flagLetter = &apos;#&apos;; letterArr.push(&apos;#&apos;) &#125; &#125; &#125; &#125; // 侧边栏 var str = &apos;&apos; ; for (var i = 0; i &lt; letterArr.length; i++) &#123; str += &apos;&lt;a ontouchstart=&quot;anchorJump(this)&quot; &gt;&apos;+ letterArr[i] +&apos;&lt;/a&gt;&apos; &#125; $(&apos;.slidePage div&apos;).html(str) $(&apos;.resultList&apos;).html(doT.template($(&apos;#listT&apos;).text())(data)) &#125;// 判断是否是字母 function f_check_uppercase(obj) &#123; if (/[A-Z]/.test(obj)) &#123; return true; &#125; return false; &#125; 然后是跳转锚点location.hash = &#39;#id&#39; 和a标签的作用相同, 跳转到指定锚点123456789// 跳转锚点 function anchorJump(n) &#123; var text = $(n).text(); if (text.length &lt; 2) &#123; $(&apos;.letter&apos;).text(text) $(&apos;.letter&apos;).css(&#123;&apos;opacity&apos;:&apos; 1&apos;&#125;) location.hash = &apos;#&apos; + text &#125; &#125; 手指滑动, 页面跳转123456// 手指滑动 function move() &#123; // 阻止默认事件, 页面滑动 event.preventDefault(); anchorJump(document.elementFromPoint(event.changedTouches[0].clientX,event.changedTouches[0].clientY)) &#125; document.elementFromPoint(x,y) 获取指定坐标的顶层元素 最后滑动结束, 手指离开屏幕123456789101112// 滑动结束 function touchEnd() &#123; var opcityNum = 1; setInterval(function () &#123; opcityNum -= 0.1; if (opcityNum &gt; 0) &#123; $(&apos;.letter&apos;).css(&#123;&apos;opacity&apos;: opcityNum&#125;) &#125; else &#123; clearInterval(); &#125; &#125;,50) &#125; 点击每条数据1234// 点击事件 function clickInfo(ele) &#123; alert($(ele).find(&apos;.name&apos;).text()) &#125; 完整的代码链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[彻底明白js中的this的指向]]></title>
      <url>%2F2017%2F08%2F12%2F%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDjs%E4%B8%AD%E7%9A%84this%E7%9A%84%E6%8C%87%E5%90%91%2F</url>
      <content type="text"><![CDATA[首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉），那么接下来我会深入的探讨这个问题。 为什么要学习this？如果你学过函数式编程，面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。 例子1：123456function a()&#123; var user = &quot;追梦子&quot;; console.log(this.user); //undefined console.log(this); //Window&#125;a(); 按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。 123456function a()&#123; var user = &quot;追梦子&quot;; console.log(this.user); //undefined console.log(this); //Window&#125;window.a(); 和上面代码一样吧，其实alert也是window的一个属性，也是window点出来的。 例子2：1234567var o = &#123; user:&quot;追梦子&quot;, fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;o.fn(); 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。 其实例子1和例子2说的并不够准确，下面这个例子就可以推翻上面的理论。 如果要彻底的搞懂this必须看接下来的几个例子 例子3：1234567var o = &#123; user:&quot;追梦子&quot;, fn:function()&#123; console.log(this.user); //追梦子 &#125;&#125;window.o.fn(); 这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，这里先说个而外话，window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window点o对象。 这里先不解释为什么上面的那段代码this为什么没有指向window，我们再来看一段代码。 12345678910var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //12 &#125; &#125;&#125;o.b.fn(); 这里同样也是对象o点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确，接下来我将补充一句话，我相信你就可以彻底的理解this的指向的问题。 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。 12345678910var o = &#123; a:10, b:&#123; // a:12, fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。 例子4：123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 这里this指向的是window，是不是有些蒙了？其实是因为你没有理解一句话，这句话同样至关重要。 this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子3是不一样的，例子3是直接执行了fn。 this讲来讲去其实就是那么一回事，只不过在不同的情况下指向的会有些不同，上面的总结每个地方都有些小错误，也不能说是错误，而是在不同环境下情况就会有不同，所以我也没有办法一次解释清楚，只能你慢慢地的去体会。 构造函数版this：12345function Fn()&#123; this.user = &quot;追梦子&quot;;&#125;var a = new Fn();console.log(a.user); //追梦子 这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。 除了上面的这些以外，我们还可以自行改变this的指向，关于自行改变this的指向请看JavaScript中call,apply,bind方法的总结这篇文章，详细的说明了我们如何手动更改this的指向。 更新一个小问题当this碰到return时 1234567function fn() &#123; this.user = &apos;追梦子&apos;; return &#123;&#125;; &#125;var a = new fn; console.log(a.user); //undefined 再看一个 1234567function fn() &#123; this.user = &apos;追梦子&apos;; return function()&#123;&#125;;&#125;var a = new fn; console.log(a.user); //undefined 再来 123456789101112131415function fn() &#123; this.user = &apos;追梦子&apos;; return 1;&#125;var a = new fn; console.log(a.user); //追梦子function fn() &#123; this.user = &apos;追梦子&apos;; return undefined;&#125;var a = new fn; console.log(a.user); //追梦子 什么意思呢？ 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 1234567function fn() &#123; this.user = &apos;追梦子&apos;; return undefined;&#125;var a = new fn; console.log(a); //fn &#123;user: &quot;追梦子&quot;&#125; 还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。 1234567function fn() &#123; this.user = &apos;追梦子&apos;; return null;&#125;var a = new fn; console.log(a.user); //追梦子 知识点补充： 在严格版中的默认的this不再是window，而是undefined。 new操作符会改变函数this的指向问题，虽然我们上面讲解过了，但是并没有深入的讨论这个问题，网上也很少说，所以在这里有必要说一下。 123456function fn()&#123; this.num = 1;&#125;var a = new fn();console.log(a.num); //1 为什么this会指向a？首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。 函数由谁接收执行，this就指向谁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——总结一下最近开发APP遇到的一些问题-2]]></title>
      <url>%2F2017%2F07%2F15%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E5%BC%80%E5%8F%91APP%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98-2%2F</url>
      <content type="text"><![CDATA[高度自适应flex布局 允许子元素伸缩 手机号正则123456789101112function checkPhone(data)&#123; if(!(/^1[34578]\d&#123;9&#125;$/.test(data)))&#123; alert("手机号码有误，请重填"); return false; &#125; &#125;function checkTel(data)&#123; if(!/^(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;7,14&#125;$/.test(data))&#123; alert('固定电话有误，请重填'); return false; &#125;&#125; db模块执行sql语句 一句一句执行,不能以;号隔开,否则后面的会不执行 vscode汉化快捷键F1, 输入Configure Language 回车, 把en改成zh-CN, 保存, 重启vscode. 格式化时间1new Date().toISOString().match(/(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)/)[1]; 创建数据库操作 创建数据库 12DROP TABLE IF EXISTS addressList; CREATE TABLE addressList(user_id int)// 如果有addressList这个表就不执行新建命令 设置唯一索引 12CREATE UNIQUE INDEX IF NOT EXISTS user_id_idx ON addressList (user_id)// 在addresslist表中的user_id这个列设置唯一索引user_id_idx IOS系统下输入框字体数量使用onkeup事件有BUG, 如果点击键盘上面的文字输入到输入框,onkeyup不会触发,统计不了字体数量 使用oninput这个事件可以解决这个问题 android和ios行高不兼容使用js判断 android比ios大9px 去掉input[type=number]的箭头-webkit-appearance：none git在使用git的时候，每次执行 #git add * 都会提示这样一个警告消息：1warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX. 虽然说没有什么影响吧。 不过就是觉得太碍眼了， 按照这样设置就没有问题了: 12git config core.autocrlf false// 禁止自动转换 这样设置git的配置后在执行add操作就没有问题了。 删除指定字符串把指定字符串替换成空1str = str.replace(&apos;a&apos;,&apos;&apos;) 查找指定字符串是否含有某个子字符串1234str.indexOf(&apos;aa&apos;) == -1不含有指定字符串str.indexOf(&apos;aa&apos;) &gt;=0含有 slice和splice1slice(start,end);剪切数组 12345splice(start, howmany, item1, ..., itemX); 方法用于插入、删除或替换数组的元素。// start 开始插入/删除的位置// howmany 插入/删除几项,必须是数字// item1, ..., itemX 插入的内容, 不传的时候为删除 listContact模块在小米5s下的bug每个页面第一次打开listContact列表会出现点击返回的index不正确, 右边字母导航也会出现重复 解决方法, 在打开正式有数据的列表之前打开一个空的列表,然后立马关闭 1234567891011121314listContact.open(&#123; x: -1000, y: -1000, w: 5, h: 5, data: [], fixedOn: api.frameName&#125;,function(ret,err)&#123;&#125;)listContact.close();listContact.open(&#123; // 有数据的列表&#125;) 安卓下第二个bug 设置选中的项, 安卓不起作用 解决办法: 在设置数据源的时候, 处理以选择数据 清除角标1234api.setAppIconBadge(&#123; badge: 1&#125;);// 为0时表示清除 css三角形带边框 原理: 写两个三角形, 一个覆盖另一个, 错开一个像素123456789101112131415161718192021222324 p:after &#123; content: &quot;&quot;; display: inline-block; width: 0; height: 0; border-top: .15rem solid transparent; border-right: .22rem solid #fff; border-bottom: .15rem solid transparent; position: absolute; top: .25rem; left: -.20rem;&#125; p:before &#123; content: &quot;&quot;; display: inline-block; width: 0; height: 0; border-top: .15rem solid transparent; border-right: .22rem solid #E3E3E3; border-bottom: .15rem solid transparent; position: absolute; top: .25rem; left: -.22rem;&#125; Deferred long-running timer task的问题 Deferred long-running timer task(s) to improve scrolling smoothness. See crbug.com/574343. at frame1.html : 0 延时函数使用不当 ios下创建时间对象12345678910111213141516171819// 处理时间显示 function initTime(time) &#123; var timeRep = time; time=time.replace(/-/g,&apos;:&apos;).replace(&apos; &apos;,&apos;:&apos;); time=time.split(&apos;:&apos;); var nowTime = new Date(); var pageTime = new Date(time[0],(time[1]-1),time[2],time[3],time[4],time[5]); if ((pageTime.getDate() != nowTime.getDate()) || (pageTime.getFullYear() != nowTime.getFullYear()) || ((pageTime.getMonth()+1) != (nowTime.getMonth()+1))) &#123; // 不是今天 return timeRep; &#125; else &#123; // 今天 if (nowTime.getHours() != pageTime.getHours()) &#123; return nowTime.getHours() - pageTime.getHours()+ &apos;小时之前&apos; &#125; else &#123; return nowTime.getMinutes() - pageTime.getMinutes() + &apos;分钟之前&apos; &#125; &#125; &#125; 长按事件1234567891011121314151617181920212223242526272829var timeOutEvent=0;//定时器 //开始按 function gtouchstart(ele)&#123; var e = window.event var x = e.touches[0].pageX,y=e.touches[0].pageY timeOutEvent = setTimeout(&quot;longPress(&quot;+x+&quot;,&quot;+y+&quot;)&quot;,500);//这里设置定时器，定义长按500毫秒触发长按事件，时间可以自己改，个人感觉500毫秒非常合适 return false; &#125;; //手释放，如果在500毫秒内就释放，则取消长按事件，此时可以执行onclick应该执行的事件 function gtouchend()&#123; clearTimeout(timeOutEvent);//清除定时器 if(timeOutEvent!=0)&#123; //这里写要执行的内容（尤如onclick事件） &#125; return false; &#125;; //如果手指有移动，则取消所有事件，此时说明用户只是要移动而不是长按 function gtouchmove()&#123; clearTimeout(timeOutEvent);//清除定时器 timeOutEvent = 0; &#125;; //真正长按后应该执行的内容 function longPress(x,y)&#123; timeOutEvent = 0; $api.css($api.dom(&apos;.shadow&apos;), &apos;display:inline-block;top:&apos; + y + &apos;px;left:&apos; + x + &apos;px;&apos;); //执行长按要执行的内容，如弹出菜单 console.log(&quot;长按事件触发发&quot;); &#125; 两次往数据库插入同一条数据 首先查询数据所在的行(需要有一个唯一索引) 如果有数据就更新数据 1UPDATE 表名 SET 列名 = 数据,列2 = 数据2 WHERE 唯一索引 = 索引 没有该数据就插入 1INSERT OR REPLACE INTO 表名(列名1, 列名2, 列名3, 列名14) VALUES (值1, 值2 ...)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript创建对象的七种方式]]></title>
      <url>%2F2017%2F06%2F30%2FJavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[JavaScript创建对象的方式有很多，通过Object构造函数或对象字面量的方式也可以创建单个对象，显然这两种方式会产生大量的重复代码，并不适合量产。接下来介绍七种非常经典的创建对象的方式，他们也各有优缺点。 工厂模式1234567891011function createPerson(name, job) &#123; var o = new Object() o.name = name o.job = job o.sayName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = createPerson(&apos;Jiang&apos;, &apos;student&apos;)var person2 = createPerson(&apos;X&apos;, &apos;Doctor&apos;) 可以无数次调用这个工厂函数，每次都会返回一个包含两个属性和一个方法的对象 工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别问题，即不能知道一个对象的类型 构造函数模式123456789function Person(name, job) &#123; this.name = name this.job = job this.sayName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person(&apos;Jiang&apos;, &apos;student&apos;)var person2 = new Person(&apos;X&apos;, &apos;Doctor&apos;) 没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作 创建一个新对象 这个新对象会被执行[[prototype]]链接 这个新对象会绑定到函数调用的this 返回这个对象 使用这个方式创建对象可以检测对象类型12person1 instanceof Object // trueperson1 instanceof Person //true 但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次 原型模式12345678function Person() &#123;&#125;Person.prototype.name = &apos;Jiang&apos;Person.prototype.job = &apos;student&apos;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person() 将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。 更简单的写法12345678910function Person() &#123;&#125;Person.prototype = &#123; name: &apos;jiang&apos;, job: &apos;student&apos;, sayName: function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person() 将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。 使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里 1Person.prototype.constructor === Person // false 如果需要这个属性的话，可以手动添加 12345678910function Person() &#123;&#125;Person.prototype = &#123; constructor：Person name: &apos;jiang&apos;, job: &apos;student&apos;, sayName: function() &#123; console.log(this.name) &#125;&#125; 不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以的时候，使用Object.defineProperty方法 1234Object.defineProperty(Person.prototype, &apos;constructor&apos;, &#123; enumerable: false, value: Person&#125;) 缺点使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点 原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了 123456789101112function Person() &#123;&#125;Person.prototype = &#123; name: &apos;jiang&apos;, friends: [&apos;Shelby&apos;, &apos;Court&apos;]&#125;var person1 = new Person()var person2 = new Person()person1.friends.push(&apos;Van&apos;)console.log(person1.friends) //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person2.friends) //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person1.friends === person2.friends) // true friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中 组合使用构造函数模式和原型模式这是使用最为广泛、认同度最高的一种创建自定义类型的方法。它可以解决上面那些模式的缺点 使用此模式可以让每个实例都会有自己的一份实例属性副本，但同时又共享着对方法的引用 这样的话，即使实例属性修改引用类型的值，也不会影响其他实例的属性值了 12345678910111213function Person(name) &#123; this.name = name this.friends = [&apos;Shelby&apos;, &apos;Court&apos;]&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person1 = new Person()var person2 = new Person()person1.friends.push(&apos;Van&apos;)console.log(person1.friends) //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person2.friends) // [&quot;Shelby&quot;, &quot;Court&quot;]console.log(person1.friends === person2.friends) //false 动态原型模式动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型 123456789101112131415function Person(name, job) &#123; // 属性 this.name = name this.job = job // 方法 if(typeof this.sayName !== &apos;function&apos;) &#123; Person.prototype.sayName = function() &#123; console.log(this.name) &#125; &#125; &#125;var person1 = new Person(&apos;Jiang&apos;, &apos;Student&apos;)person1.sayName() 只有在sayName方法不存在的时候，才会将它添加到原型中。这段代码只会初次调用构造函数的时候才会执行。 此后原型已经完成初始化，不需要在做什么修改了 这里对原型所做的修改，能够立即在所有实例中得到反映 其次，if语句检查的可以是初始化之后应该存在的任何属性或方法，所以不必用一大堆的if语句检查每一个属性和方法，只要检查一个就行 寄生构造函数模式这种模式的基本思想就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新建的对象 1234567891011function Person(name, job) &#123; var o = new Object() o.name = name o.job = job o.sayName = function() &#123; console.log(this.name) &#125; return o&#125;var person1 = new Person(&apos;Jiang&apos;, &apos;student&apos;)person1.sayName() 这个模式，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式几乎一样 构造函数如果不返回对象，默认也会返回一个新的对象，通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值 稳妥构造函数模式首先明白稳妥对象指的是没有公共属性，而且其方法也不引用this。 稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或防止数据被其他应用程序改动时使用 稳妥构造函数模式和寄生模式类似，有两点不同:一是创建对象的实例方法不引用this，而是不使用new操作符调用构造函数 1234567891011function Person(name, job) &#123; var o = new Object() o.name = name o.job = job o.sayName = function() &#123; console.log(name) &#125; return o&#125;var person1 = Person(&apos;Jiang&apos;, &apos;student&apos;)person1.sayName() 和寄生构造函数模式一样，这样创建出来的对象与构造函数之间没有什么关系，instanceof操作符对他们没有意义 欢迎访问我的博客欢迎访问IT资源库作者：Xuthusxxxgitone.github.io/2017/06/10/JavaScript创建对象的七种方式/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS的六种继承方式]]></title>
      <url>%2F2017%2F06%2F27%2FJS%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[继承是面向对象编程中又一非常重要的概念，JavaScript支持实现继承，不支持接口继承，实现继承主要依靠原型链来实现的。 一、原型链首先得要明白什么是原型，原型链继承基本思想就是让一个原型对象指向另一个的实例 123456789101112131415function SuperType() &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType() &#123; this.subproperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.getSubValue = function () &#123; return this.subproperty&#125;var instance = new SubType()console.log(instance.getSuperValue()) // true 代码定义了两个类型SuperType和SubType，每个类型分别有一个属性和一个方法，SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。 实现的本质是重写原型对象,代之以一个新类型的实例，那么存在SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。 我们知道，在创建一个实例的时候，实例对象中会有一个内部指针指向创建它的原型，进行关联起来，在这里代码SubType.prototype = new SuperType()，也会在SubType.prototype创建一个内部指针，将SubType.prototype与SuperType关联起来。 所以instance指向SubType的原型，SubType的原型又指向SuperType的原型，继而在instance在调用getSuperValue()方法的时候，会顺着这条链一直往上找。 添加方法在给SubType原型添加方法的时候，如果，父类上也有同样的名字，SubType将会覆盖这个方法，达到重写的目的。 但是这个方法依然存在于父类中。 记住不能以字面量的形式添加，因为，上面说过通过实例继承本质上就是重写，再使用字面量形式，又是一次重写了，但这次重写没有跟父类有任何关联，所以就会导致原型链截断。 1234567891011121314151617function SuperType() &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType() &#123; this.subproperty = false&#125;SubType.prototype = new SuperType()SubType.prototype = &#123; getSubValue:function () &#123; return this.subproperty &#125;&#125;var instance = new SubType()console.log(instance.getSuperValue()) // error 问题单纯的使用原型链继承，主要问题来自包含引用类型值的原型。 1234567891011function SuperType() &#123; this.colors = ['red', 'blue', 'green']&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType()var instance1 = new SubType()var instance2 = new SubType()instance1.colors.push('black')console.log(instance1.colors) // ["red", "blue", "green", "black"]console.log(instance2.colors) // ["red", "blue", "green", "black"] 在SuperType构造函数定义了一个colors属性，当SubType通过原型链继承后，这个属性就会出现SubType.prototype中，就跟专门创建了SubType.prototype.colors一样，所以会导致SubType的所有实例都会共享这个属性，所以instance1修改colors这个引用类型值，也会反映到instance2中。 二、借用构造函数此方法为了解决原型中包含引用类型值所带来的问题。 这种方法的思想就是在子类构造函数的内部调用父类构造函数，可以借助apply()和call()方法来改变对象的执行上下文 123456789101112function SuperType() &#123; this.colors = ['red', 'blue', 'green']&#125;function SubType() &#123; // 继承SuperType SuperType.call(this)&#125;var instance1 = new SubType()var instance2 = new SubType()instance1.colors.push('black')console.log(instance1.colors) // ["red", "blue", "green", "black"]console.log(instance2.colors) // ["red", "blue", "green"] 在新建SubType实例是调用了SuperType构造函数，这样以来，就会在新SubType对象上执行SuperType函数中定义的所有对象初始化代码。 结果，SubType的每个实例就会具有自己的colors属性的副本了。 传递参数借助构造函数还有一个优势就是可以传递参数 123456789101112function SuperType(name) &#123; this.name = name&#125;function SubType() &#123; // 继承SuperType SuperType.call(this, 'Jiang') this.job = 'student'&#125;var instance = new SubType()console.log(instance.name) // Jiangconsole.log(instance.job) // student 问题如果仅仅借助构造函数，方法都在构造函数中定义，因此函数无法达到复用 三、组合继承(原型链+构造函数)组合继承是将原型链继承和构造函数结合起来，从而发挥二者之长的一种模式。 思路就是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 123456789101112131415161718192021222324252627function SuperType(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType(name, job) &#123; // 继承属性 SuperType.call(this, name) this.job = job&#125;// 继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SuperTypeSubType.prototype.sayJob = function() &#123; console.log(this.job)&#125;var instance1 = new SubType('Jiang', 'student')instance1.colors.push('black')console.log(instance1.colors) //["red", "blue", "green", "black"]instance1.sayName() // 'Jiang'instance1.sayJob() // 'student'var instance2 = new SubType('J', 'doctor')console.log(instance2.colors) // //["red", "blue", "green"]instance2.sayName() // 'J'instance2.sayJob() // 'doctor' 这种模式避免了原型链和构造函数继承的缺陷，融合了他们的优点，是最常用的一种继承模式。constructor始终指向创建当前对象的构造函数。 四、原型式继承借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125; 在object函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。 本质上来说，object对传入其中的对象执行了一次浅复制。 123456var person = &#123; name: 'Jiang', friends: ['Shelby', 'Court']&#125;var anotherPerson = object(person)console.log(anotherPerson.friends) // ['Shelby', 'Court'] 这种模式要去你必须有一个对象作为另一个对象的基础。 在这个例子中，person作为另一个对象的基础，把person传入object中，该函数就会返回一个新的对象。 这个新对象将person作为原型，所以它的原型中就包含一个基本类型和一个引用类型。 所以意味着如果还有另外一个对象关联了person，anotherPerson修改数组friends的时候，也会体现在这个对象中。 Object.create()方法ES5通过Object.create()方法规范了原型式继承，可以接受两个参数，一个是用作新对象原型的对象和一个可选的为新对象定义额外属性的对象，行为相同，基本用法和上面的object一样，除了object不能接受第二个参数以外。123456var person = &#123; name: 'Jiang', friends: ['Shelby', 'Court']&#125;var anotherPerson = Object.create(person)console.log(anotherPerson.friends) // ['Shelby', 'Court'] 五、寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数。123456789101112function createAnother(o) &#123; var clone = Object.create(o) // 创建一个新对象 clone.sayHi = function() &#123; // 添加方法 console.log('hi') &#125; return clone // 返回这个对象&#125;var person = &#123; name: 'Jiang'&#125;var anotherPeson = createAnother(person)anotherPeson.sayHi() // hi 基于person返回了一个新对象anotherPeson，新对象不仅拥有了person的属性和方法，还有自己的sayHi方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，这是一个有用的模式。 六、寄生组合式继承在前面说的组合模式(原型链+构造函数)中，继承的时候需要调用两次父类构造函数。 父类1234function SuperType(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125; 第一次在子类构造函数中123456function SubType(name, job) &#123; // 继承属性 SuperType.call(this, name) this.job = job&#125; 第二次将子类的原型指向父类的实例12// 继承方法SubType.prototype = new SuperType() 当使用var instance = new SubType()的时候，会产生两组name和color属性，一组在SubType实例上，一组在SubType原型上，只不过实例上的屏蔽了原型上的。 使用寄生式组合模式，可以规避这个问题。 这种模式通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 基本思路：不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本。 本质上就是使用寄生式继承来继承父类的原型，在将结果指定给子类型的原型。 12345function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype) prototype.constructor = subType subType.prototype = prototype&#125; 该函数实现了寄生组合继承的最简单形式。 这个函数接受两个参数，一个子类，一个父类。 第一步创建父类原型的副本，第二步将创建的副本添加constructor属性，第三部将子类的原型指向这个副本。 1234567891011121314151617181920212223function SuperType(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType(name, job) &#123; // 继承属性 SuperType.call(this, name) this.job = job&#125;function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype) prototype.constructor = subType subType.prototype = prototype&#125;// 继承inheritPrototype(SubType, SuperType)var instance = new SubType('Jiang', 'student')instance.sayName() 补充：直接使用Object.create来实现，其实就是将上面封装的函数拆开，这样演示可以更容易理解。 12345678910111213141516171819function SuperType(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType(name, job) &#123; // 继承属性 SuperType.call(this, name) this.job = job&#125;// 继承SubType.prototype = Object.create(SuperType.prototype)// 修复constructorSubType.prototype.constructor = SubTypevar instance = new SubType('Jiang', 'student')instance.sayName() ES6新增了一个方法，Object.setPrototypeOf，可以直接创建关联，而且不用手动添加constructor属性。123// 继承Object.setPrototypeOf(SubType.prototype, SuperType.prototype)console.log(SubType.prototype.constructor === SubType) // true 欢迎访问我的博客欢迎访问IT资源库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[30分钟让你彻底明白Promise原理]]></title>
      <url>%2F2017%2F06%2F23%2F30%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDPromise%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[为了让大家更容易理解，我们从一个场景开始讲解，让大家一步一步跟着思路思考，相信你一定会更容易看懂。 考虑下面一种获取用户id的请求处理 12345678910111213//例1function getUserId() &#123; return new Promise(function(resolve) &#123; //异步请求 http.get(url, function(results) &#123; resolve(results.id) &#125;) &#125;)&#125; getUserId().then(function(id) &#123; //一些处理&#125;) getUserId方法返回一个promise，可以通过它的then方法注册(注意注册这个词)在promise异步操作成功时执行的回调。这种执行方式，使得异步调用变得十分顺手。 原理剖析那么类似这种功能的Promise怎么实现呢？其实按照上面一句话，实现一个最基础的雏形还是很easy的。 极简promise雏形12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; //callbacks为数组，因为可能同时有很多个回调 this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled); &#125;; function resolve(value) &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125; fn(resolve);&#125; 上述代码很简单，大致的逻辑是这样的： 调用then方法，将想要在Promise异步操作成功时执行的回调放入callbacks队列，其实也就是注册回调函数，可以向观察者模式方向思考； 创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，它接收一个参数value，代表异步操作返回的结果，当一步操作执行成功后，用户会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行； 可以结合例1中的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(results.id)方法, 该方法执行then方法注册的回调数组。 相信仔细的人应该可以看出来，then方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让then方法支持链式调用，其实也是很简单的： 1234this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled); return this;&#125;; see?只要简单一句话就可以实现类似下面的链式调用： 123456// 例2getUserId().then(function (id) &#123; // 一些处理&#125;).then(function (id) &#123; // 一些处理&#125;); 加入延时机制细心的同学应该发现，上述代码可能还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数： 123456789// 例3function getUserId() &#123; return new Promise(function (resolve) &#123; resolve(9876); &#125;);&#125;getUserId().then(function (id) &#123; // 一些处理&#125;); 这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数: 1234567function resolve(value) &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0)&#125; 上述代码的思路也很简单，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成. 但是，这样好像还存在一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的。 加入状态恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected。 Promises/A+规范中的2.1Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。一图胜千言： 改进后的代码是这样的：12345678910111213141516171819202122232425262728function Promise(fn) &#123; var state = &apos;pending&apos;, value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === &apos;pending&apos;) &#123; callbacks.push(onFulfilled); return this; &#125; onFulfilled(value); return this; &#125;; function resolve(newValue) &#123; value = newValue; state = &apos;fulfilled&apos;; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 上述代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。 这里没有任何地方将state设为rejected，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。 链式Promise那么这里问题又来了，如果用户再then函数里面注册的仍然是一个Promise，该如何解决？比如下面的例4： 1234567891011121314// 例4getUserId() .then(getUserJobById) .then(function (job) &#123; // 对job的处理 &#125;); function getUserJobById(id) &#123; return new Promise(function (resolve) &#123; http.get(baseUrl + id, function(job) &#123; resolve(job); &#125;); &#125;);&#125; 这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise。 链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？（这是这里的难点）。 其实也不是辣么难，只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这么说哒(微笑脸)~ 下面来看看这段暗藏玄机的then方法和resolve方法改造代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Promise(fn) &#123; var state = &apos;pending&apos;, value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === &apos;pending&apos;) &#123; callbacks.push(callback); return; &#125; //如果then中没有传递任何东西 if(!callback.onResolved) &#123; callback.resolve(value); return; &#125; var ret = callback.onFulfilled(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === &apos;object&apos; || typeof newValue === &apos;function&apos;)) &#123; var then = newValue.then; if (typeof then === &apos;function&apos;) &#123; then.call(newValue, resolve); return; &#125; &#125; state = &apos;fulfilled&apos;; value = newValue; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve);&#125; 我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里： 123456789101112131415// 例4getUserId() .then(getUserJobById) .then(function (job) &#123; // 对job的处理 &#125;); function getUserJobById(id) &#123; return new Promise(function (resolve) &#123; http.get(baseUrl + id, function(job) &#123; resolve(job); &#125;); &#125;);&#125; then方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用。 handle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在（这里一定要好好的分析下handle的作用）。 getUserId生成的promise（简称getUserId promise）异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果id 调用handle方法处理callbacks队列中的回调：getUserJobById方法，生成新的promise（getUserJobById promise） 执行之前由getUserId promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserJobById promise。这种情况下，会将该resolve方法传入getUserJobById promise的then方法中，并直接返回。6. 在getUserJobById promise异步操作成功时，执行其callbacks中的回调：getUserId bridge promise中的resolve方法 最后执行getUserId bridge promise的后邻promise的callbacks中的回调。 更直白的可以看下面的图，一图胜千言（都是根据自己的理解画出来的，如有不对欢迎指正）： 失败处理在异步操作失败时，标记其状态为rejected，并执行注册的失败回调: 123456789101112131415161718//例5function getUserId() &#123; return new Promise(function(resolve) &#123; //异步请求 http.get(url, function(error, results) &#123; if (error) &#123; reject(error); &#125; resolve(results.id) &#125;) &#125;)&#125; getUserId().then(function(id) &#123; //一些处理&#125;, function(error) &#123; console.log(error)&#125;) 有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function Promise(fn) &#123; var state = &apos;pending&apos;, value = null, callbacks = []; this.then = function (onFulfilled, onRejected) &#123; return new Promise(function (resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === &apos;pending&apos;) &#123; callbacks.push(callback); return; &#125; var cb = state === &apos;fulfilled&apos; ? callback.onFulfilled : callback.onRejected, ret; if (cb === null) &#123; cb = state === &apos;fulfilled&apos; ? callback.resolve : callback.reject; cb(value); return; &#125; ret = cb(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === &apos;object&apos; || typeof newValue === &apos;function&apos;)) &#123; var then = newValue.then; if (typeof then === &apos;function&apos;) &#123; then.call(newValue, resolve, reject); return; &#125; &#125; state = &apos;fulfilled&apos;; value = newValue; execute(); &#125; function reject(reason) &#123; state = &apos;rejected&apos;; value = reason; execute(); &#125; function execute() &#123; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve, reject);&#125; 上述代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法。 错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的： 123456789//例6getUserId() .then(getUserJobById) .then(function (job) &#123; // 处理job &#125;, function (error) &#123; // getUserId或者getUerJobById时出现的错误 console.log(error); &#125;); 异常处理细心的同学会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下： 1234567891011121314151617181920function handle(callback) &#123; if (state === &apos;pending&apos;) &#123; callbacks.push(callback); return; &#125; var cb = state === &apos;fulfilled&apos; ? callback.onFulfilled : callback.onRejected, ret; if (cb === null) &#123; cb = state === &apos;fulfilled&apos; ? callback.resolve : callback.reject; cb(value); return; &#125; try &#123; ret = cb(value); callback.resolve(ret); &#125; catch (e) &#123; callback.reject(e); &#125;&#125; 如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决。 总结刚开始看promise源码的时候总不能很好的理解then和resolve函数的运行机理，但是如果你静下心来，反过来根据执行promise时的逻辑来推演，就不难理解了。这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。 现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式： 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者 作者：前端静径mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ 欢迎访问我的博客免费it资源]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS的API设计原则]]></title>
      <url>%2F2017%2F06%2F20%2FJS%E7%9A%84API%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
      <content type="text"><![CDATA[一、接口的流畅性好的接口是流畅易懂的，他主要体现如下几个方面： 1.简单操作某个元素的css属性，下面是原生的方法: 1document.querySelectorAll(&apos;#id&apos;).style.color = &apos;red&apos;; 封装之后 1234function a(selector, color) &#123; document.querySelectorAll(selector)[0].style.color = color&#125;a(&apos;#a&apos;, &apos;red&apos;); 从几十个字母长长的一行到简简单单的一个函数调用，体现了api简单易用 2.可阅读性a(‘#a’, ‘red’)是个好函数，帮助我们简单实用地改变某个元素，但问题来了，如果第一次使用改函数的人来说会比较困惑，a函数是啥函数，没有人告诉他。开发接口有必要知道一点，人都是懒惰的，从颜色赋值这个函数来说，虽然少写了代码，但是增加了记忆成本。每次做这件事情的时候都需要有映射关系。 a—-&gt;color. 如果是简单的几个无所谓，但是通常一套框架都有几十甚至上百的api，映射成本增加会使得程序员哥哥崩溃。 我们需要的就是使得接口有意义，下面我们改写一下a函数： 123function letSomeElementChangeColor(selector, color) &#123; document.querySelectorAll(selector, color);&#125; letSomeElementChangeColor相对于a来说被赋予了语言意义，任何人都会知道它的意义 3.减少记忆成本我们刚刚的函数也是这样的它太长了letSomeElementChangeColor虽然减少了映射成本，但是增加了记忆成本。要知道，包括学霸在内，任何人都不喜欢被单词。原生获取dom的api也同样有这个问题 document.getElementsByClassName； document.getElementsByName; document.querySelectorAll;这些api给人的感觉就是单词太长了，虽然他给出的意义是很清晰，然而这种做法是建立在牺牲简易性的基础上进行的。于是我们又再次改写这个之前函数123function setColor(selector, color) &#123;xxxxxxxxxxxx&#125; 在意义不做大的变化前提下，缩减函数名称。使得它易读易记易用； 4.可延伸所谓延伸就是指函数的使用像流水一样按照书写的顺序执行形成执行链条:123document.getElementById(&apos;id&apos;).style.color = &apos;red&apos;;document.getElementById(&apos;id&apos;).style.fontSize = &apos;12px&apos;;document.getElementById(&apos;id&apos;).style.backgourdColor = &apos;pink&apos;; 用我们之前的之前的方法是再次封装两个函数 setFontSize, setbackgroundColor; 然后执行它们 setColor(‘id’, ‘red’);setFontSiez(‘id’, ’12px’); setbackgroundColor(‘id’, ‘pink’); 显然，这样的做法没有懒出境界来；id元素每次都需要重新获取，影响性能，失败；每次都需要添加新的方法 失败 每次还要调用这些方法，还是失败。下面我们将其改写为可以延伸的函数 首先将获取id方法封装成对象,然后再对象的每个方法中返回这个对象：1234567891011121314151617181920function getElement(selector) &#123; this.style = document.querySelecotrAll(selector).style;&#125; getElement.prototype.color = function(color) &#123; this.style.color = color; return this;&#125;getElement.prototype.background = function(bg) &#123; this.style.backgroundColor = color; return this;&#125;getElement.prototype.fontSize = function(size) &#123; this.style.fontSize = size; return this;&#125; //调用var el = new getElement(&apos;#id&apos;)el.color(&apos;red&apos;).background(&apos;pink&apos;).fontSize(&apos;12px&apos;); 简单、流畅、易读后面我们会在参数里面讲到如何继续优化。所以，大家都比较喜欢用jquery的api，虽然一个$符号并不代表任何现实意义，但简单的符号有利于我们的使用。它体现了以上的多种原则，简单，易读，易记，链式写法，多参处理。 nightmare:123document.getElementById(&apos;id&apos;).style.color = &apos;red&apos;;document.getElementById(&apos;id&apos;).style.fontSize = &apos;12px&apos;;document.getElementById(&apos;id&apos;).style.backgourdColor = &apos;pink&apos;; dream:1$(&apos;id&apos;).css(&#123;color:&apos;red&apos;, fontSize:&apos;12px&apos;, backgroundColor:&apos;pink&apos;&#125;) 二、一致性1.接口的一致性相关的接口保持一致的风格，一整套 API 如果传递一种熟悉和舒适的感觉，会大大减轻开发者对新工具的适应性。 命名这点事：既要短，又要自描述，最重要的是保持一致性 “在计算机科学界只有两件头疼的事：缓存失效和命名问题” — Phil Karlton 选择一个你喜欢的措辞，然后持续使用。选择一种风格，然后保持这种风格。 Nightware:1234setColor,letBackGroundchangefontSizemakedisplay dream:1234setColor;setBackground;setFontSizeset......... 尽量地保持代码风格和命名风格，使人读你的代码像是阅读同一个人写的文章一样。 三、参数的处理1.参数的类型判断参数的类型为你的程序提供稳定的保障12345//我们规定，color接受字符串类型function setColor(color) &#123; if(typeof color !== &apos;string&apos;) return;dosomething&#125; 2.使用json方式传参使用json的方式传值很多好处，它可以给参数命名，可以忽略参数的具体位置，可以给参数默认值等等 比如下面这种糟糕的情况:1function fn(param1, param2...............paramN) 你必须对应地把每一个参数按照顺序传入，否则你的方法就会偏离你预期去执行，正确的方法是下面的做法。12345678function fn(json) &#123;//为必须的参数设置默认值 var default = extend(&#123;param: &apos;default&apos;,param1: &apos;default&apos;...... &#125;,json)&#125; 这段函数代码，即便你不传任何参数进来，他也会预期运行。因为在声明的时候，你会根据具体的业务决定参数的缺省值。 四、可扩展性软件设计最重要的原则之一：永远不修改接口，指扩展它！可扩展性同时会要求接口的职责单一，多职责的接口很难扩展。 举个栗子：1234567891011121314151617181920212223//需要同时改变某个元素的字体和背景// Nightmare:function set(selector, color) &#123; document.querySelectroAll(selector).style.color = color; document.querySelectroAll(selector).style.backgroundColor = color;&#125; //无法扩展改函数，如果需要再次改变字体的大小的话，只能修改此函数，在函数后面填加改变字体大小的代码 //Dreamfunction set(selector, color) &#123; var el = document.querySelectroAll(selector); el.style.color = color; el.style.backgroundColor = color; return el;&#125; //需要设置字体、背景颜色和大小function setAgain (selector, color, px) &#123; var el = set(selector, color) el.style.fontSize = px; return el;&#125; 以上只是简单的添加颜色，业务复杂而代码又不是你写的时候，你就必须去阅读之前的代码再修改它，显然是不符合开放-封闭原则的。修改后的function是返回了元素对象，使得下次需要改变时再次得到返回值做处理。 2.this的运用可扩展性还包括对this的以及call和apply方法的灵活运用：123456789function sayBonjour() &#123; alert(this.a)&#125; obj.a = 1;obj.say = sayBonjour;obj.say();//1//orsayBonjour.call||apply(obj);//1 五、对错误的处理1.预见错误可以用 类型检测 typeof 或者try…catch。 typeof 会强制检测对象不抛出错误，对于未定义的变量尤其有用。 2.抛出错误大多数开发者不希望出错了还需要自己去找带对应得代码，最好方式是直接在console中输出，告诉用户发生了什么事情。我们可以用到浏览器的输出api:console.log/warn/error。你还可以为自己的程序留些后路: try…catch。 12345678910111213function error (a) &#123; if(typeof a !== &apos;string&apos;) &#123; console.error(&apos;param a must be type of string&apos;) &#125;&#125; function error() &#123; try &#123; // some code excucete here maybe throw wrong &#125;catch(ex) &#123; console.wran(ex); &#125;&#125; 六、可预见性可预见性味程序接口提供健壮性，为保证你的代码顺利执行，必须为它考虑到非正常预期的情况。我们看下不可以预见的代码和可预见的代码的区别用之前的setColor123456789101112131415161718192021222324252627282930313233343536373839404142434445//nighwarefunction set(selector, color) &#123; document.getElementById(selector).style.color = color;&#125;//dreamzepto.init = function(selector, context) &#123; var dom // If nothing given, return an empty Zepto collection if (!selector) return zepto.Z() // Optimize for string selectors else if (typeof selector == &apos;string&apos;) &#123; selector = selector.trim() // If it&apos;s a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn&apos;t begin with &lt; if (selector[0] == &apos;&lt;&apos; &amp;&amp; fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null // If there&apos;s a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // If it&apos;s a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // If a function is given, call it when the DOM is ready else if (isFunction(selector)) return $(document).ready(selector) // If a Zepto collection is given, just return it else if (zepto.isZ(selector)) return selector else &#123; // normalize array if an array of nodes is given if (isArray(selector)) dom = compact(selector) // Wrap DOM nodes. else if (isObject(selector)) dom = [selector], selector = null // If it&apos;s a html fragment, create nodes from it else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null // If there&apos;s a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector) // And last but no least, if it&apos;s a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector) &#125; // create a new Zepto collection from the nodes found return zepto.Z(dom, selector)&#125; 以上是zepto的源码，可以看见，作者在预见传入的参数时做了很多的处理。其实可预见性是为程序提供了若干的入口，无非是一些逻辑判断而已。zepto在这里使用了很多的是非判断，同时导致了代码的冗长，不适合阅读。总之，可预见性真正需要你做的事多写一些对位置实物的参数。把外部的检测改为内部检测。是的使用的人用起来舒心放心开心。呐！做人嘛最重要的就是海森啦。 七、注释和文档的可读性一个最好的接口是不需要文档我们也会使用它，但是往往接口量一多和业务增加，接口使用起来也会有些费劲。所以接口文档和注释是需要认真书写的。注释遵循简单扼要地原则，给多年后的自己也给后来者看：12345678910//注释接口，为了演示PPT用function commentary() &#123; //如果你定义一个没有字面意义的变量时，最好为它写上注释：a：没用的变量，可以删除 var a; //在关键和有歧义的地方写上注释，犹如画龙点睛：路由到hash界面后将所有的数据清空结束函数 return go.Navigate(&apos;hash&apos;, function()&#123; data.clear(); &#125;);&#125; 最后 推荐markdown语法书写API文档，github御用文档编写语法。简单、快速，代码高亮、话不多说上图 卤煮在此也推荐几个在线编辑的网站。诸君可自行前往练习使用。 https://www.zybuluo.com/mdeditor http://mahua.jser.me/ 参考博文 前端头条-javascript的api设计原则（http://top.css88.com/archives/814） 作者：卖烧烤夫斯基www.cnblogs.com/constantince/p/5580003.html 欢迎访问我的博客欢迎访问IT资源库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[唯快不破：web应用的13个优化步骤]]></title>
      <url>%2F2017%2F06%2F16%2F%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%EF%BC%9Aweb%E5%BA%94%E7%94%A8%E7%9A%8413%E4%B8%AA%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[时过境迁，Web 应用比以往任何时候都更具交互性。搞定性能可以帮助你极大地改善终端用户的体验。阅读以下的技巧并学以致用，看看哪些可以用来改善延迟，渲染时间以及整体性能吧！ 更快的 Web 应用优化 Web 应用是一项费劲的工作。Web 应用不仅处于客户端和服务器端的两部分组件当中，通常来说也是由多种多样的技术栈构建而成：数据库，后端组件（一般也是搭建在不同技术架构之上的），以及前端（HTML + JavaScript + CSS + 转译器）。运行时也是变化多端的：iOS，Android，Chrome，Firefox，Edge。如果你曾经工作在一个不同的单一庞大的平台之上，通常情况下性能优化只针对于单一目标（甚至只是目标的单一版本而已），但是现在的话你就可能会意识到任务复杂度要远超于此。这就对了。但这儿也有一些通用的优化指南可以大大优化一个应用。我们将会在接下来的章节中探讨这些指南的内容。 一份 Bing 的研究表明，页面加载时间每增加 10ms，网站的年收入就会减少 25 万美元。 —— Rob Trace 和 David Walp，微软高级程序经理 过早优化？优化最难的地方就是如何在开发生命周期中最适当的时候去做优化。Donald Knuth 有一句名言：「过早优化乃万恶之源」。这句话背后的原因非常简单：因为一不小心就会浪费时间去优化某个 1% 的地方，但是结果却并不会对性能造成什么重大影响。与此同时，一些优化还妨碍了可读性或者是可维护性，甚至还会引入新的 Bug。换句话说，优化不应当被认为是「意味着得到应用程序的最佳性能」，而是「探索优化应用的正确的方式，并得到最大的效益」。再换句话说，盲目的优化可能会导致效率的丢失，而收益却很小。在你应用以下技巧的时候请将此铭记在心。你最好的朋友就是分析工具：找到你可以进行通过优化获得最大程度改善的性能点，而不用损害应用开发的进程或者可维护性。 程序员们浪费了大量时间来思考，或者说是担忧，他们的程序中非关键部分的运行速度。并且他们对于性能的这些尝试，实际上却对代码的调试和维护有着非常消极的影响。我们应当忘记那些不重要的性能影响，在 97% 的时间里都可以这么说：过早优化乃万恶之源。当然我们也不应当在那关键的 3% 上放弃我们的机会。—— Donald Knuth 1. JavaScript 压缩和模块打包JavaScript 应用是以源码形式进行分发的，而源码解析的效率是要比字节码低的。对于一小段脚本来说，区别可以忽略不计。但是对于更大型的应用，脚本的大小会对应用启动时间有着负面的影响。事实上，寄期望于使用 WebAssembly 而获得最大程度的改善，其中之一就是可以得到更快的启动时间。 另一方面，模块打包则用于将不同脚本打包在一起并放进同一文件。更少的 HTTP 请求和单个文件解析都可以减少加载时间。通常情况下，单独一种工具就可以处理打包和压缩。Webpack 就是其中之一。 示例代码： 1234567function insert(i) &#123; document.write(&quot;Sample &quot; + i);&#125; for(var i = 0; i &lt; 30; ++i) &#123; insert(i);&#125; 结果如下： 12!function(r)&#123;function t(o)&#123;if(e[o])return e[o].exports;var n=e[o]=&#123;exports:&#123;&#125;,id:o,loaded:!1&#125;;returnr[o].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var e=&#123;&#125;;return t.m=r,t.c=e,t.p=&quot;&quot;,t(0)&#125;([function(r,t)&#123;function e(r)&#123;document.write(&quot;Sample &quot;+r)&#125;for(var o=0;30&gt;o;++o)e(o)&#125;]);//# sourceMappingURL=bundle.min.js.map 进一步打包 你也可以使用 Webpack 打包 CSS 文件以及合并图片。这些特性都可以有助于改善启动时间。研究一下 Webpack 文档来做些测试吧！ 2. 按需加载资源资源（特别是图片）的按需加载或者说惰性加载，可以有助于你的 Web 应用在整体上获得更好的性能。对于使用大量图片的页面来说惰性加载有着显著的三个好处： 减少向服务器发出的并发请求数量（这就使得页面的其他部分获得更快的加载时间） 减少浏览器的内存使用率（更少的图片，更少的内存） 减少服务器端的负载 大体上的理念就是只在必要的时候才去加载图片或资源（如视频），比如在第一次被显示的时候，或者是在将要显示的时候对其进行加载。由于这种方式跟你建站的方式密切相关，惰性加载的解决方案通常需要借助其他库的插件或者扩展来实现。举个例子，react-lazy-load 就是一个用于处理 React 惰性加载图片的插件： 12345678const MyComponent = () =&gt; ( &lt;div&gt; Scroll to load images. &lt;div className=&quot;filler&quot; /&gt; &lt;LazyLoad height=&#123;762&#125; offsetVertical=&#123;300&#125;&gt; &lt;img src=&apos;http://apod.nasa.gov/apod/image/1502/HDR_MVMQ20Feb2015ouellet1024.jpg&apos; /&gt; &lt;/LazyLoad&gt; (...) 一个非常好的实践范例就像 Goggle Images 的搜索工具一样。点击前面的链接并且滑动页面滚动条就可以看到效果了。 3. 在使用 DOM 操作库时用上 array-ids如果你正在使用 React，Ember，Angular 或者其他 DOM 操作库，使用 array-ids（或者 Angular 1.x 中的 track-by 特性）非常有助于实现高性能，对于动态网页尤其如此。此特性背后的主要概念就是尽可能多地重用已有的节点。Array ids 使得 DOM 操作引擎可以「知道」在什么时候某个节点可以被映射到数组当中的某个元素。没有 array-ids 或者 track-by 的话，大部分库都会进行重新排序而摧毁已有的节点并重新创建新的。这就非常损耗性能了。 4. 缓存Caches 是用于存储那些被频繁存取的静态数据的组件，便于随后对于这个数据的请求可以更快地被响应，或者说请求方式更加高效。由于 Web 应用是由很多可拆卸的部件组合而成，缓存就可以存在于架构中的很多部分。举例来说，缓存可以被放在动态内容服务器和客户端之间，就可以避免公共请求以减少服务器的负载，与此同时改善响应时间。其他缓存可能被放置在代码里，以优化某些用于脚本存取的通用模式，还有些缓存可能被放置在数据库或者是长运行进程之前。 简而言之，在 Web 应用中使用缓存是一种改善响应时间和减少 CPU 使用的绝佳方式。难点就在于搞清楚哪里才是在架构中存放缓存的地方。再一次，答案就是性能分析：常见的瓶颈在哪里？数据或者结果可缓存吗？他们都太容易失效吗？这都是一些棘手的问题，需要从原理上来一点一点回答。 缓存的使用在 Web 环境中富有创造性。比如，basket.js 就是一个使用Local Storage 来缓存应用脚本的库。所以你的 Web 应用在第二次运行脚本的时候就可以几乎瞬间加载了。 如今一个广受欢迎的缓存服务就是亚马逊的 CloudFront。CloudFront 就跟通常的内容分发网络（CDN）用途一样，可以被设置作为动态内容的缓存。 5. 启用 HTTP/2越来越多的浏览器都开始支持 HTTP/2。这可能听起来没有必要，但是 HTTP/2 为同一服务器的并发连接问题带来了很多好处。换句话说，如果有很多小型资源需要加载（如果你打包过的话就没有必要了），在延迟和性能方面 HTTP/2 秒杀 HTTP/1。试试 Akamai 的 HTTP/2 demo，可以在最新的浏览器中看到区别。 6. 应用性能分析性能分析是优化任何应用程序时的重要一步。就像介绍中所提到的那样，盲目尝试优化应用经常会导致效率的浪费，微不足道的收益和更差的可维护性。执行性能分析是识别你的应用问题所在的一个重要步骤。 对于 Web 应用来说，延迟时间是最大的抱怨之一，所以你需要确保数据的加载和显示都尽可能得快。Chrome 提供了非常棒的性能分析工具。特别是 Chrome Dev Tools 中的时间线和网络视图都对于定位延迟问题有着很大的帮助： 时间线视图可以帮忙找到运行时间较长的操作。 网络视图可以帮助识别出额外的由缓慢请求导致的延迟或对于某一端点的串行访问。 正确分析的话，内存则是另一块可能获得收益的部分。如果你正在运行着一个拥有很多虚拟元素的页面（庞大的动态表格）或者可交互式的元素（比如游戏），内存优化可以获得更少的卡顿和更高的帧率。 找到性能损耗的中心可以让你有效率地达到优化的目标。 对后端的性能分析会更加困难。通常情况下，确认一个耗费较多时间的请求可以让你明确应该优先分析哪一个服务。对于后端的分析工具来说，则取决于所构建的技术栈。 一个关于算法的注意事项 在大多数情况下，选择一个更优的算法，比围绕着小成本中心所实现的具体优化策略能够获得更大的收益。在某种程度上，CPU 和内存分析应该可以帮你找到大的性能瓶颈。当这些瓶颈跟编码问题并不相关时，则是时候考虑考虑不同的算法了。 7. 使用负载均衡方案我们在之前讨论缓存的时候简要提到了内容分发网络（CDNs）。把负载分配到不同的服务器（甚至于不同的地理区域）可以给你的用户提供更好的延迟时间，但是这条路还很漫长，特别是在处理很多的并发连接的时候。 负载均衡就跟使用某个 round-robin（循环）解决方案一样简单，可以基于一个 nginx 反向代理 ，或者基于一个成熟的分布式网络，比如 Cloudflare 或者 Amazon CloudFront。 以上的图来自于 Citrix。 为了使负载均衡真正有效，动态内容和静态内容都应该被拆分成易于并发访问的。换句话说，元素的串形访问会削弱负载均衡器以最佳形式进行分流的能力。与此同时，对于资源的并发访问可以改善启动时间。 虽然负载均衡可能会很复杂。对最终一致性算法不友好的数据模型，或者缓存都会让事情更加困难。幸运的是，大多数应用对于已简化的数据集都只需要保证高层次的一致性即可。如果你的应用程序没有这样设计的话，就有必要重构一下了。 8. 为了更快的启动时间考虑一下同构 JavaScript改善 Web 应用程序观感的方式之一，就是减少启动时间或者减少首页渲染时间。这对于新兴的单页面应用尤为重要，其需要在客户端执行大量任务。在客户端做更多事情通常就意味着，在第一次渲染被执行之前就需要下载更多的信息。同构 JavaScript 可以解决这个问题：自从 JavaScript 可以同时运行在客户端和服务器端，这就让在服务器端来执行页面的首次渲染成为可能，先把已渲染的页面发送出去然后再由客户端的脚本接管。这限制了所使用的后端（必须使用支持该特性的 JavaScript 框架），但却能获得更好的用户体验。举例来说，React 就很适合于做这个，就像以下代码所示： 123456789101112131415var React = require(&apos;react/addons&apos;);var ReactApp = React.createFactory(require(&apos;../components/ReactApp&apos;).ReactApp); module.exports = function(app) &#123; app.get(&apos;/&apos;, function(req, res)&#123; // React.renderToString takes your component // and generates the markup var reactHtml = React.renderToString(ReactApp(&#123;&#125;)); // Output html rendered by react // console.log(myAppHtml); res.render(&apos;index.ejs&apos;, &#123;reactOutput: reactHtml&#125;); &#125;); &#125;; Meteor.js 对于客户端和服务器端的 JavaScript 混用有着非常棒的支持。 12345678910111213141516171819if (Meteor.isClient) &#123; Template.hello.greeting = function () &#123; return &quot;Welcome to myapp.&quot;; &#125;; Template.hello.events(&#123; &apos;click input&apos;: function () &#123; // template data, if any, is available in &apos;this&apos; if (typeof console !== &apos;undefined&apos;) console.log(&quot;You pressed the button&quot;); &#125; &#125;);&#125; if (Meteor.isServer) &#123; Meteor.startup(function () &#123; // code to run on server at startup &#125;);&#125; 但是，为了支持服务器端渲染，需要像 meteor-ssr 这样的插件 . 如果你有复杂的或者中等大小的应用需要支持同构部署，试试这个，你可能会感到惊讶的。 9. 使用索引加速数据库查询如果你需要解决数据库查询耗费大量时间的问题（分析你的应用看看是否是这种情况！），是时候找出加速数据库的方法了。每个数据库和数据模型都有自己的权衡。数据库优化在每一方面都是一个主题：数据模型，数据库类型，具体实现方案，等等。提速可能不是那么的简单。但是这儿有个建议，可能可以对某些数据库有所帮助：索引。索引是一个过程，即数据库所创建的快速访问数据结构，从内部映射到键（在关系数据库中的列），可以提高检索相关数据的速度。大多数现代数据库都支持索引。索引并不是文档型数据库（比如 MongoDB）所独有的，也包括关系型数据库（比如PostgreSQL）。 为了使用索引来优化你的查询，你将需要研究一下应用程序的访问模式：什么是最常见的查询，在哪个键或列中执行搜索，等等。 10. 使用更快的转译方案JavaScript 软件技术栈一如既往的复杂。而改善语言本身的需求则又增加了复杂度。不幸地是，JavaScript 作为目标平台又会被用户的运行时所限制。尽管很多改进已经以 ECMAScript 2015（2016正在进行）的形式实现了，但是通常情况下，对客户端代码来说又不可能依赖于这个版本。这种趋势促使了一系列的转译器：用于处理 ECMAScript 2015 代码的工具和只使用 ECMAScript 5 结构实现其中所缺失的特性。与此同时，模块绑定和压缩处理也已经被集成到这个生产过程中，被称为为发布而构建的代码版本。这些工具可以转化代码，并且能够以有限的方式影响到最终代码的性能。Google 开发者 Paul Irish 花了一些时间来寻找这些转译方案会如何影响性能和最终代码的大小。尽管大多数情况下收益会很小，但也值得在正式采用某个工具栈之前看看这些数据。对于大型应用程序来说，这种区别可能会影响重大。 11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染JavaScript 和 CSS 资源都会阻塞页面的渲染。通过采取某些的规则，你可以保证你的脚本和 CSS 被尽可能快速地处理，以便于浏览器能够显示你的网站内容。 在 CSS 的情况下这是非常重要的，所有的 CSS 规则都不能与特定媒体直接相关，规则只用于处理你准备在页面上所显示内容的优先级。这可以通过使用 CSS 媒体查询来实现。媒体查询告诉浏览器，哪些 CSS 样式表应用在某个特定的显示媒体上。举个例子，用于打印的某些规则可以被赋予比用于屏幕显示更低的优先级。 媒体查询可以被设置成 标签属性： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;only screen and (max-device-width: 480px)&quot; href=&quot;mobile-device.css&quot; /&gt; 轮到 JavaScript 了，关键就在于遵循某些用于内联 JavaScript 的规则（比如内联在 HTML 文件当中的代码）。内联 JavaScript 应该尽可能短，并将其放在不会阻塞页面剩余部分解析的地方。换句话说，被放在 HTML 树中间的内联 JavaScript 将会在这个地方阻塞解析器，并强制其等待直到脚本被执行完毕。如果在 HTML 文件中随意放了一些大的代码块或者很多小的代码块，对于性能来说这会成为性能杀手。内联可以有效减少额外对于某些特定脚本的网络请求。但是对于重复使用的脚本或者大的代码块来说，这个好处就可以忽略不计了。 防止 JavaScript 阻塞解析器和渲染器的一种方法就是将 &lt;script&gt; 标签标记为异步的。这限制了我们对于 DOM 的访问但是可以让浏览器不管脚本的执行状态而继续解析和渲染页面。换句话说，为了获得最佳的启动时间，确保那些对于渲染不重要的脚本已经通过异步属性的方式标记成异步的了。 1&lt;script src=&quot;async.js&quot; async&gt;&lt;/script&gt; 12. 用于未来的一个建议：使用 service workers + 流Jake Archibald 最近的一篇博文详细描述了一种有趣的技术，可以用于加速渲染时间：将 service workers 和流结合起来。结果非常令人叹服： 不幸的是这个技术所需要的 APIs 都还不稳定，这也是为什么这是一种有趣的概念但现在还没有真正被应用的原因。这个想法的主旨就是在网站和客户端之间放置一个 service worker。这个 service worker 可以在获取缺失信息的同时缓存某些数据（比如 header 和一些不会经常改变的东西）。缺失的内容就可以尽可能快速地流向被渲染的页面。https://www.youtube.com/watch?v=Cjo9iq8k-bc 13. 图片编码优化图片编码优化。PNGs 和 JPGs 在 Web 发布时都会使用次优的设置进行编码。通过改变编码器和它的设置，对于需要大量图片的网站来说可以获得有效的改善。流行的解决方案包括 OptiPNG 和jpegtran。 A guide to PNG optimization（http://optipng.sourceforge.net/pngtech/optipng.html） 详细描述了 OptiPNG 可以如何用于优化 PNGs。 The man page for jpegtran（http://linux.die.net/man/1/jpegtran） 对它的一些特性提供了很好的介绍。 如果你发现这些指南相对于你的要求来说都太复杂了的话，这儿有一些在线网站可以提供优化服务。也有一些像 RIOT 一样的图形化界面，非常有助于批量操作和结果检查。 结论由于应用程序变得越来越大和越来越复杂，性能优化对于 Web 开发来说正在变得越来越重要。在做出任何值得的时间和潜在的未来成本的优化尝试时，有针对性的改进都是必不可少的。Web 应用程序早已突破了大多数静态内容的边界，学习常见模式进行优化则是令人愉悦的应用和完全不可用的应用之间最大的区别（这是让你的访客留下来的长远之计！）。没有什么规则是绝对的，但是：性能分析和研究特定软件技术栈的错综复杂之处，是找出如何优化它的唯一方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端跨域请求原理及实践]]></title>
      <url>%2F2017%2F06%2F15%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[一、 跨域请求的含义浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。 一般的，只要网站的 协议名protocol、 主机host、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用 NodeJs 创建了两个服务器，分别监听 3000、 3001 端口（下面简称 服务器3000 与 服务器3001 ），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。 在服务器3000 上有如下的页面： 服务器3000 上的请求页面中包含如下 JavaScript 代码： 12345678910111213141516171819202122$(function() &#123; $("#submit").click(function() &#123; var data = &#123; name: $("#name").val(), id: $("#id").val() &#125;; $.ajax(&#123; type: 'POST', data: data, url: 'http://localhost:3000/ajax/deal', dataType: 'json', cache: false, timeout: 5000, success: function(data) &#123; console.log(data) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log('error ' + textStatus + ' ' + errorThrown); &#125; &#125;); &#125;);&#125;); 服务器3000 对应的处理函数为 123456789app.post('/ajax/deal', function(req, res) &#123; console.log("server accept: ", req.body.name, req.body.id) var data = &#123; name: req.body.name + ' - server 3000 process', id: req.body.id + ' - server 3000 process' &#125; res.send(data) res.end()&#125;) 请求页面返回结果： 此处数据处理成功。 由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server 3000 process’），并且返回给浏览器，表示数据经过服务器端处理。如果让 服务器3000 上的页面向 服务器 3001 发起请求会怎样呢？ 将请求页面中的 ajax 请求路径改为： 12345$.ajax(&#123; ... url: 'http://localhost:3001/ajax/deal', ...&#125;); 服务器3001 对应的处理函数与 服务器3000 类似： 123456789app.post('/ajax/deal', function(req, res) &#123; console.log("server accept: ", req.body.name, req.body.id) var data = &#123; name: req.body.name + ' - server 3001 process', id: req.body.id + ' - server 3001 process' &#125; res.send(data) res.end()&#125;) 结果如下： 结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。 需要注意的是，服务器 3001 控制台有输出：1server accept: chiaki 3001 这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。 二、 利用 JSONP 实现跨域调用说到跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了 什么是JSONP？ JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website. It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier. JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data. JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 XmlHttpRequest 对象受到同源策略的影响，而&lt;script&gt;标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。 使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用我们先从简单的实现开始，利用 jQuery 中的 $.ajax 来实现上诉的跨域调用。 依然是上面的例子，我们将 服务器 3000 上的请求页面的 JavaScript 代码改为： 123456789101112131415161718192021222324252627// 回调函数function jsonpCallback(data) &#123; console.log("jsonpCallback: " + data.name)&#125;$("#submit").click(function() &#123; var data = &#123; name: $("#name").val(), id: $("#id").val() &#125;; $.ajax(&#123; url: 'http://localhost:3001/ajax/deal', data: data, dataType: 'jsonp', cache: false, timeout: 5000, // jsonp 字段含义为服务器通过什么字段获取回调函数的名称 jsonp: 'callback', // 声明本地回调函数的名称，jquery 默认随机生成一个函数名称 jsonpCallback: 'jsonpCallback', success: function(data) &#123; console.log("ajax success callback: " + data.name) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log(textStatus + ' ' + errorThrown); &#125; &#125;);&#125;); 服务器 3001 上对应的处理函数为： 123456789app.get('/ajax/deal', function(req, res) &#123; console.log("server accept: ", req.query.name, req.query.id) var data = "&#123;" + "name:'" + req.query.name + " - server 3001 process'," + "id:'" + req.query.id + " - server 3001 process'" + "&#125;" var callback = req.query.callback var jsonp = callback + '(' + data + ')' console.log(jsonp) res.send(jsonp) res.end()&#125;) 这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的 data 直接传给回调函数，否则会发生编译错误： parsererror Error: jsonpCallback was not called。 其实脑海里应该有一个概念：利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。 处理结果如下所示： 使用&lt;script&gt;标签原生实现 JSONP经过上面的事件，你是不是觉得 JSONP 的实现和 Ajax 大同小异？ 其实，由于实现的原理不同，由 JSONP 实现的跨域调用不是通过 XmlHttpRequset 对象，而是通过 script 标签，所以在实现原理上，JSONP 和 Ajax 已经一点关系都没有了。看上去形式相似只是由于 jQuery 对 JSONP 做了封装和转换。 比如在上面的例子中，我们假设要传输的数据 data 格式如下 1234&#123; name: "chiaki", id": "3001"&#125; 那么数据是如何传输的呢？HTTP 请求头的第一行如下： 1GET /ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032 HTTP/1.1 可见，即使形式上是用 POST 传输一个 JSON 格式的数据，其实发送请求时还是转换成 GET 请求。 其实如果理解 JSONP 的原理的话就不难理解为什么只能使用 GET 请求方法了。由于是通过 script 标签进行请求，所以上述传输过程根本上是以下的形式： 1&lt;script src = 'http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032'&gt;&lt;/script&gt; 这样从服务器返回的代码就可以直接在这个 script 标签中运行了。下面我们自己实现一个 JSONP： 服务器 3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback： 123function jsonpCallback(data) &#123; console.log("jsonpCallback: "+data.name)&#125; 服务器 3000请求页面还包含一个 script 标签： 1&lt;script src = 'http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback'&gt;&lt;/script&gt; 服务器 3001上对应的处理函数： 123456789app.get('/jsonServerResponse', function(req, res) &#123; var cb = req.query.jsonp console.log(cb) var data = 'var data = &#123;' + 'name: $("#name").val() + " - server 3001 jsonp process",' + 'id: $("#id").val() + " - server 3001 jsonp process"' + '&#125;;' var debug = 'console.log(data);' var callback = '$("#submit").click(function() &#123;' + data + cb + '(data);' + debug + '&#125;);' res.send(callback) res.end()&#125;) 与上面一样，我们在所获取的参数后面加上 “ – server 3001 jsonp process” 代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。 最终的结果为： JSONP 总结至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足： 只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。 不能很好的发现错误，并进行处理。 与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。 使用 CORS 实现跨域调用什么是 CORS？Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。 CORS 的实现还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。 服务器 3000 上的请求页面 JavaScript 不变，如下： 12345678910111213141516171819202122$(function() &#123; $("#submit").click(function() &#123; var data = &#123; name: $("#name").val(), id: $("#id").val() &#125;; $.ajax(&#123; type: 'POST', data: data, url: 'http://localhost:3001/cors', dataType: 'json', cache: false, timeout: 5000, success: function(data) &#123; console.log(data) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log('error ' + textStatus + ' ' + errorThrown); &#125; &#125;); &#125;);&#125;); 服务器 3001上对应的处理函数： 1234567891011121314app.post('/cors', function(req, res) &#123; res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By", ' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); var data = &#123; name: req.body.name + ' - server 3001 cors process', id: req.body.id + ' - server 3001 cors process' &#125; console.log(data) res.send(data) res.end()&#125;) 在服务器中对返回信息的请求头进行了设置。 最终的结果为： CORS 中属性的分析 1.Access-Control-Allow-OriginThe origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource. 2.Access-Control-Allow-MethodsSpecifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above. 3.Access-Control-Allow-HeadersUsed in response to a preflight request to indicate which HTTP headers can be used when making the actual request. CORS 与 JSONP 的对比 CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。 CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。 JSONP 可以在不支持 CORS 的老旧浏览器上运作。 一些其它的跨域调用方式window.namewindow对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 window.postMessage()这个方法是 HTML5 的一个新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。 点击查看编程系列视频教程点击查看我的博客参考：https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage作者：高鹏tingandpeng.com/2016/09/05/前端跨域请求原理及实践/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解JavaScript作用域]]></title>
      <url>%2F2017%2F06%2F14%2F%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[简介JavaScript 有个特性称为作用域。尽管对于很多开发新手来说，作用域的概念不容易理解，我会尽可能地从最简单的角度向你解释它们。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你实现强大的设计模式。 什么是作用域？作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 想想计算机管理员吧。他们在公司各个系统上拥有很多控制权，看起来甚至可以给予他们拥有全部权限的账号。假设你有一家公司，拥有三个管理员，他们都有系统的全部访问权限，并且一切运转正常。但是突然发生了一点意外，你的一个系统遭到恶意病毒攻击。现在你不知道这谁出的问题了吧？你这才意识到你应该只给他们基本用户的账号，并且只在需要时赋予他们完全的访问权。这能帮助你跟踪变化并记录每个人的操作。这叫做最小访问原则。眼熟吗？这个原则也应用于编程语言设计，在大多数编程语言（包括 JavaScript）中称为作用域，接下来我们就要学习它。 在你的编程旅途中，你会意识到作用域在你的代码中可以提升性能，跟踪 bug 并减少 bug。作用域还解决不同范围的同名变量命名问题。记住不要弄混作用域和上下文。它们是不同的特性。 JavaScript中的作用域在 JavaScript 中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当你在文档中（document）编写 JavaScript 时，你就已经在全局作用域中了。JavaScript 文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = 'Hammad'; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = 'Hammad'; console.log(name); // logs 'Hammad' function logName() &#123; console.log(name); // 'name' is accessible here and everywhere else&#125; logName(); // logs 'Hammad' 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213// Global Scopefunction someFunction() &#123; // Local Scope ##1 function someOtherFunction() &#123; // Local Scope ##2 &#125;&#125; // Global Scopefunction anotherFunction() &#123; // Local Scope ##3&#125;// Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if (true) &#123; // this 'if' conditional block doesn't create a new scope var name = 'Hammad'; // name is still in the global scope&#125; console.log(name); // logs 'Hammad' ECMAScript 6 引入了let和const关键字。这些关键字可以代替var。 1234var name = 'Hammad'; let likes = 'Coding';const skills = 'Javascript and PHP'; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if (true) &#123; // this 'if' conditional block doesn't create a scope // name is in the global scope because of the 'var' keyword var name = 'Hammad'; // likes is in the local scope because of the 'let' keyword let likes = 'Coding'; // skills is in the local scope because of the 'const' keyword const skills = 'JavaScript and PHP';&#125; console.log(name); // logs 'Hammad'console.log(likes); // Uncaught ReferenceError: likes is not definedconsole.log(skills); // Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及到你代码某些特殊部分中的this值。作用域指的是变量的可见性，而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是 Window 对象。 123456789// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;console.log(this); function logFunction() &#123; console.log(this);&#125;// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;// because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象的方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125; (new User).logName(); // logs User &#123;&#125; (new User).logName()是创建对象关联到变量并调用logName方法的一种简便形式。通过这种方式你并不需要创建一个新的变量。 你可能注意到一点，就是如果你使用new关键字调用函数时上下文的值会有差异。上下文会设置为被调用的函数的实例。考虑一下上面的这个例子，用new关键字调用的函数。 12345function logFunction() &#123; console.log(this);&#125; new logFunction(); // logs logFunction &#123;&#125; 当在严格模式（strict mode）中调用函数时，上下文默认是 undefined。 执行环境为了解决掉我们从上面学习中会出现的各种困惑，“执行环境（context）”这个词中的“环境（context）”指的是作用域而并非上下文。这是一个怪异的命名约定，但由于 JavaScript 的文档如此，我们只好也这样约定。 JavaScript 是一种单线程语言，所以它同一时间只能执行单个任务。其他任务排列在执行环境中。当 JavaScript 解析器开始执行你的代码，环境（作用域）默认设为全局。全局环境添加到你的执行环境中，事实上这是执行环境里的第一个环境。 之后，每个函数调用都会添加它的环境到执行环境中。无论是函数内部还是其他地方调用函数，都会是相同的过程。 每个函数都会创建它自己的执行环境。 当浏览器执行完环境中的代码，这个环境会从执行环境中弹出，执行环境中当前环境的状态会转移到父级环境。浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里层的作用域）。 全局环境只能有一个，函数环境可以有任意多个。执行环境有两个阶段：创建和执行。 创建阶段第一阶段是创建阶段，是函数刚被调用但代码并未执行的时候。创建阶段主要发生了 3 件事。 创建变量对象 创建作用域链 设置上下文（this）的值 变量对象变量对象（Variable Object）也称为活动对象（activation object），包含所有变量、函数和其他在执行环境中定义的声明。当函数调用时，解析器扫描所有资源，包括函数参数、变量和其他声明。当所有东西装填进一个对象，这个对象就是变量对象。123'variableObject': &#123; // contains function arguments, inner variable and function declarations&#125; 作用域链在执行环境创建阶段，作用域链在变量对象之后创建。作用域链包含变量对象。作用域链用于解析变量。当解析一个变量时，JavaScript 开始从最内层沿着父级寻找所需的变量或其他资源。作用域链包含自己执行环境以及所有父级环境中包含的变量对象。 123'scopeChain': &#123; // contains its own variable object and other variable objects of the parent execution contexts&#125; 执行环境对象执行环境可以用下面抽象对象表示： 12345executionContextObject = &#123; 'scopeChain': &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts 'variableObject': &#123;&#125;, // contains function arguments, inner variable and function declarations 'this': valueOfThis&#125; 代码执行阶段执行环境的第二个阶段就是代码执行阶段，进行其他赋值操作并且代码最终被执行。 词法作用域词法作用域的意思是在函数嵌套中，内层函数可以访问父级作用域的变量等资源。这意味着子函数词法绑定到了父级执行环境。词法作用域有时和静态作用域有关。 12345678910111213function grandfather() &#123; var name = 'Hammad'; // likes is not accessible here function parent() &#123; // name is accessible here // likes is not accessible here function child() &#123; // Innermost level of the scope chain // name is also accessible here var likes = 'Coding'; &#125; &#125;&#125; 你可能注意到了词法作用域是向前的，意思是子执行环境可以访问name。但不是由父级向后的，意味着父级不能访问likes。这也告诉了我们，在不同执行环境中同名变量优先级在执行栈由上到下增加。一个变量和另一个变量同名，内层函数（执行栈顶的环境）有更高的优先级。 闭包闭包的概念和我们刚学习的词法作用域紧密相关。当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包。闭包包括它们自己的作用域链、父级作用域链和全局作用域。 闭包不仅能访问外部函数的变量，也能访问外部函数的参数。 即使函数已经return，闭包仍然能访问外部函数的变量。这意味着return的函数允许持续访问外部函数的所有资源。 当你的外部函数return一个内部函数，调用外部函数时return的函数并不会被调用。你必须先用一个单独的变量保存外部函数的调用，然后将这个变量当做函数来调用。看下面这个例子： 1234567891011121314function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet(); // nothing happens, no errors // the returned function from greet() gets saved in greetLettergreetLetter = greet(); // calling greetLetter calls the returned function from the greet() functiongreetLetter(); // logs 'Hi Hammad' 值得注意的是，即使在greet函数return后，greetLetter函数仍可以访问greet函数的name变量。如果不使用变量赋值来调用greet函数return的函数，一种方法是使用()两次()()，如下所示： 12345678function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet()(); // logs 'Hi Hammad' 共有作用域和私有作用域在许多其他编程语言中，你可以通过 public、private 和 protected 作用域来设置类中变量和方法的可见性。看下面这个 PHP 的例子 1234567891011121314151617// Public Scopepublic $property;public function method() &#123; // ...&#125; // Private Sccpeprivate $property;private function method() &#123; // ...&#125; // Protected Scopeprotected $property;protected function method() &#123; // ...&#125; 将函数从公有（全局）作用域中封装，使它们免受攻击。但在 JavaScript 中，没有 共有作用域和私有作用域。然而我们可以用闭包实现这一特性。为了使每个函数从全局中分离出去，我们要将它们封装进如下所示的函数中： 123(function () &#123; // private scope&#125;)(); 函数结尾的括号告诉解析器立即执行此函数。我们可以在其中加入变量和函数，外部无法访问。但如果我们想在外部访问它们，也就是说我们希望它们一部分是公开的，一部分是私有的。我们可以使用闭包的一种形式，称为模块模式（Module Pattern），它允许我们用一个对象中的公有作用域和私有作用域来划分函数。 模块模式模块模式如下所示： 1234567891011var Module = (function() &#123; function privateMethod() &#123; // do something &#125; return &#123; publicMethod: function() &#123; // can call privateMethod(); &#125; &#125;;&#125;)(); Module 的return语句包含了我们的公共函数。私有函数并没有被return。函数没有被return确保了它们在 Module 命名空间无法访问。但我们的共有函数可以访问我们的私有函数，方便它们使用有用的函数、AJAX 调用或其他东西。 12Module.publicMethod(); // worksModule.privateMethod(); // Uncaught ReferenceError: privateMethod is not defined 一种习惯是以下划线作为开始命名私有函数，并返回包含共有函数的匿名对象。这使它们在很长的对象中很容易被管理。向下面这样： 1234567891011var Module = (function () &#123; function _privateMethod() &#123; // do something &#125; function publicMethod() &#123; // do something &#125; return &#123; publicMethod: publicMethod, &#125;&#125;)(); 立即执行函数表达式（IIFE）另一种形式的闭包是立即执行函数表达式（Immediately-Invoked Function Expression，IIFE）。这是一种在 window 上下文中自调用的匿名函数，也就是说this的值是window。它暴露了一个单一全局接口用来交互。如下所示： 123(function(window) &#123; // do anything&#125;)(this); 使用 .call()， .apply() 和 .bind() 改变上下文Call 和 Apply 函数来改变函数调用时的上下文。这带给你神奇的编程能力（和终极统治世界的能力）。你只需要使用 call 和 apply 函数并把上下文当做第一个参数传入，而不是使用括号来调用函数。函数自己的参数可以在上下文后面传入。 1234567function hello() &#123; // do something...&#125; hello(); // the way you usually call ithello.call(context); // here you can pass the context(value of this) as the first argumenthello.apply(context); // here you can pass the context(value of this) as the first argument .call()和.apply()的区别是 Call 中其他参数用逗号分隔传入，而 Apply 允许你传入一个参数数组。 1234567891011121314151617function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125; introduce('Hammad', 'Coding'); // the way you usually call itintroduce.call(window, 'Batman', 'to save Gotham'); // pass the arguments one by one after the contexttintroduce.apply('Hi', ['Bruce Wayne', 'businesses']); // pass the arguments in an array after the context // Output:// Hi! I'm Hammad and I like Coding.// The value of this is [object Window].// Hi! I'm Batman and I like to save Gotham.// The value of this is [object Window].// Hi! I'm Bruce Wayne and I like businesses.// The value of this is Hi.` Call 比 Apply 的效率高一点。 下面这个例子列举文档中所有项目，然后依次在控制台打印出来。1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Things to learn&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Things to Learn to Rule the World&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Learn PHP&lt;/li&gt; &lt;li&gt;Learn Laravel&lt;/li&gt; &lt;li&gt;Learn JavaScript&lt;/li&gt; &lt;li&gt;Learn VueJS&lt;/li&gt; &lt;li&gt;Learn CLI&lt;/li&gt; &lt;li&gt;Learn Git&lt;/li&gt; &lt;li&gt;Learn Astral Projection&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll(&apos;ul li&apos;); // Loops through each of the Node in the listItems NodeList and logs its content for (var i = 0; i &lt; listItems.length; i++) &#123; (function () &#123; console.log(this.innerHTML); &#125;).call(listItems[i]); &#125; // Output logs: // Learn PHP // Learn Laravel // Learn JavaScript // Learn VueJS // Learn CLI // Learn Git // Learn Astral Projection &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML文档中仅包含一个无序列表。JavaScript 从 DOM 中选取它们。列表项会被从头到尾循环一遍。在循环时，我们把列表项的内容输出到控制台。 输出语句包含在由括号包裹的函数中，然后调用call函数。相应的列表项传入 call 函数，确保控制台输出正确对象的 innerHTML。 对象可以有方法，同样函数对象也可以有方法。事实上，JavaScript 函数有 4 个内置方法： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript 5 (ES5)) Function.prototype.call() Function.prototype.toString() Function.prototype.toString()返回函数代码的字符串表示。 到现在为止，我们讨论了.call()、.apply()和toString()。与 Call 和 Apply 不同，Bind 并不是自己调用函数，它只是在函数调用之前绑定上下文和其他参数。在上面提到的例子中使用 Bind： 12345678(function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125;).bind(window, 'Hammad', 'Cosmology')(); // logs:// Hi! I'm Hammad and I like Cosmology.// The value of this is [object Window]. Bind 像call函数一样用逗号分隔其他传入参数，不像apply那样用数组传入参数。 结论这些概念是 JavaScript 的基础，如果你想钻研更深的话，理解这些很重要。我希望你对 JavaScript 作用域及相关概念有了更好地理解。如果有东西不清楚，可以在评论区提问。 作用域常伴你的代码左右，享受编码！ 点击查看编程系列教程点击访问我的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[兼容新旧浏览器的flex写法]]></title>
      <url>%2F2017%2F05%2F26%2F%E5%85%BC%E5%AE%B9%E6%96%B0%E6%97%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84flex%E5%86%99%E6%B3%95%2F</url>
      <content type="text"><![CDATA[拷贝直接加类名即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* 定义 */.flex-def &#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125;/* 主轴居中 */.flex-zCenter &#123; -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center;&#125;/* 主轴两端对齐 */.flex-zBetween &#123; -webkit-box-pack: justify; -moz-justify-content: space-between; -webkit-justify-content: space-between; justify-content: space-between;&#125;/* 主轴end对齐 */.flex-zEnd &#123; -webkit-box-pack: end; -moz-justify-content: flex-end; -webkit-justify-content: flex-end; justify-content: flex-end;&#125;/* 主轴start对齐 */.flex-zStart &#123; -webkit-box-pack: start; -moz-justify-content: start; -webkit-justify-content: start; justify-content: start;&#125;/* 侧轴居中 */.flex-cCenter &#123; -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center;&#125;/* 侧轴start对齐 */.flex-cStart &#123; -webkit-box-align: start; -moz-align-items: start; -webkit-align-items: start; align-items: start;&#125;/* 侧轴底部对齐 */.flex-cEnd &#123; -webkit-box-align: end; -moz-align-items: flex-end; -webkit-align-items: flex-end; align-items: flex-end;&#125;/* 侧轴文本基线对齐 */.flex-cBaseline &#123; -webkit-box-align: baseline; -moz-align-items: baseline; -webkit-align-items: baseline; align-items: baseline;&#125;/* 侧轴上下对齐并铺满 */.flex-cStretch &#123; -webkit-box-align: stretch; -moz-align-items: stretch; -webkit-align-items: stretch; align-items: stretch;&#125;/* 主轴从上到下 */.flex-zTopBottom &#123; -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column;&#125;/* 主轴从下到上 */.flex-zBottomTop &#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse;&#125;/* 主轴从左到右 */.flex-zLeftRight &#123; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row;&#125;/* 主轴从右到左 */.flex-zRightLeft &#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse;&#125;/* 是否允许子元素伸缩 */.flex-item &#123; -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1;&#125;/* 子元素的显示次序 */.flex-order&#123; -webkit-box-ordinal-group: 1; -moz-order: 1; -webkit-order: 1; order: 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大牛公司的github]]></title>
      <url>%2F2017%2F05%2F23%2F%E5%A4%A7%E7%89%9B%E5%85%AC%E5%8F%B8%E7%9A%84github%2F</url>
      <content type="text"><![CDATA[GoogleGooglehttps://github.com/google Google Sampleshttps://github.com/googlesamples Google Codelabshttps://github.com/googlecodelabs GoogleChromehttps://github.com/GoogleChrome Google Creative Labhttps://github.com/googlecreativelab 人人皆可使用的Google开源字体https://github.com/googlei18n FacebookFacebookhttps://github.com/facebook Facebook Sampleshttps://github.com/fbsamples facebookresearchhttps://github.com/facebookresearch Twitter, Inc.https://github.com/twitter Square（android开源的类库多而且厉害）https://github.com/square AlibabaAlibabahttps://github.com/alibaba hiloteam(阿里，终端跨平台小游戏)https://github.com/hiloteam https://github.com/hiloteam/hilo 腾讯相关腾讯https://github.com/Tencent 腾讯前端库https://github.com/AlloyTeam 微信开发团队https://github.com/WeMobileDev/article 其他Yalantis（好几个效果不错android的控件）https://github.com/Yalantis SwiftAndroidhttps://github.com/SwiftAndroid Ramotion（App Development Agency | Available for new projects）https://github.com/Ramotion Tinify(压缩图片的那个网站)https://github.com/tinify 豆瓣https://github.com/douban WeUI（微信ui）https://github.com/weui 美团·大众点评https://github.com/Meituan-Dianping 极光开发者https://github.com/jpush Dropboxhttps://github.com/dropbox 伯乐在线https://github.com/jobbole grpc（gRPC：Google开源的基于HTTP/2和ProtoBuf的通用RPC框架）https://github.com/grpc Nike Inc.(耐克)https://github.com/Nike-Inc Mediumhttps://github.com/Medium Microsofthttps://github.com/Microsoft Mapboxhttps://github.com/mapbox JetBrains(好多ide都是他家出的)https://github.com/JetBrains Kotlin（可以写Android,现在已经扶正了）https://github.com/Kotlin ReactiveX（函数响应式编程）https://github.com/ReactiveX https://github.com/Reactive-Extensions Airbnbhttps://github.com/airbnb Applehttps://github.com/apple Uberhttps://github.com/uber Baidu EFE team（百度）https://github.com/ecomfe Bilibili（B站）https://github.com/Bilibili Yalantis（音乐播放，好多比较好的移动端效果）https://github.com/Yalantis https://yalantis.com/ Springhttps://github.com/spring-projects 饿了么https://github.com/eleme https://elelogistics.github.io/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——总结一下最近开发APP遇到的一些问题]]></title>
      <url>%2F2017%2F05%2F20%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E5%BC%80%E5%8F%91APP%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[距离上一次发文都过去十天了, 下班回来懒的就想睡觉, 今天520一个重要的节日, 恩爱已经秀完, 该干点事情了！！ 总结一下最近开发遇到的一些问题, 以及解决方案纯css三角形123456/* 没有哪个方向的边框, 三角形就朝向那边 */width: 0;height: 0;border-top: .5rem solid transparent;border-left: 1rem solid red;border-bottom: .5rem solid transparent; :after和:before伪元素在设置宽高之前,必须先设置display属性1234567:before &#123; content: ""; display: inline-block; width: .18rem; height: .18rem; background-color: #f00;&#125; 禁止换行, 使文字在一行内显示123white-space:nowrap;overflow: hidden;text-overflow: ellipsis; 朋友圈上传图片, 根据图片数量自适应大小12345678910111213141516171819202122232425// 根据上传图片的多少自适应图片的大小(function() &#123; // 获取所有有图片内容的容器, apicloud的选择器, 其他选择器亦可 var listContent = $api.domAll('.listContent'); for (var i = 0; i &lt; listContent.length; i++) &#123; // 每个图片容器中有几个图片 var imgArr = listContent[i].getElementsByClassName('content_img'); var imgCount = imgArr.length // 根据每个容器中的图片输了设置当前容器中图片的尺寸 if (imgCount == 1) &#123; $api.css(listContent[i].getElementsByClassName('content_img')[i], 'width:2.86rem;margin:0'); &#125; else if (imgCount == 2 || imgCount == 4) &#123; for (var j = 0; j &lt; imgCount; j++) &#123; $api.css(listContent[i].getElementsByClassName('content_img')[j], 'height:2.78rem'); &#125; &#125; else &#123; for (var j = 0; j &lt; imgCount; j++) &#123; $api.css(listContent[i].getElementsByClassName('content_img')[j], 'height:1.8rem'); &#125; &#125; &#125;&#125;)() qq历史聊天记录–网页面上部添加标签后不滚动123456789// 获取历史聊天记录前 页面高度mainH=$api.offset($api.dom('.main')).h;_main = mainH // 修改获取聊天记录后的页面位置mainH = $api.offset($api.dom('.main')).h;scrollH = mainH - _main;_main = mainH;window.scrollTo(0,scrollH-50); apicloud阻止冒泡事件12345678// 添加到标签上// 阻止默认事件onclick = 'event.preventDefault();'// 阻止冒泡事件onclick = 'event.stopPropagation();'// 或者onclick = 'api.closeWin();event.preventDefault();'onclick = 'api.closeWin();event.stopPropagation();' 排他原则(干掉所有人,留下我自己)12345678function li_span(ele) &#123; // 选择传入元素的所有同级元素 var allDom = ele.parentNode.childNodes for (var i = 0; i &lt; allDom.length; i++) &#123; $api.removeCls(allDom[i], 'sel'); &#125; $api.addCls(ele, 'sel');&#125; android4.4 兼容flex定义12345678.box&#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125; 主轴对齐方式12345678910111213141516.box&#123; -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center;&#125;/* 旧版语法有4个参数，而新版语法有5个参数，兼容写法新版语法的 space-around 是不可用的 */.box&#123; box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/&#125; 侧轴对齐方式1234567891011121314.box&#123; -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center;&#125;/* 参数 */.box&#123; box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 显示方向 左到右1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row;&#125; 右到左12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse;&#125; 上到下1234567.box&#123; -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column;&#125; 下到上12345678.box&#123; -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse;&#125; 是否允许子元素伸缩1234567891011121314151617.item&#123; -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1;&#125;/* 参数 */.item&#123; box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/&#125; 触摸对象1234567891011121314151617181920212223242526272829以下是四种touch事件touchstart: //手指放到屏幕上时触发touchmove: //手指在屏幕上滑动式触发touchend: //手指离开屏幕时触发touchcancel: //系统取消touch事件的时候触发，这个好像比较少用每个触摸事件被触发后，会生成一个event对象，event对象里额外包括以下三个触摸列表touches: //当前屏幕上所有手指的列表targetTouches: //当前dom元素上手指的列表，尽量使用这个代替toucheschangedTouches: //涉及当前事件的手指的列表，尽量使用这个代替touches这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下：clientX / clientY: //触摸点相对浏览器窗口的位置pageX / pageY: //触摸点相对于页面的位置screenX / screenY: //触摸点相对于屏幕的位置identifier: //touch对象的IDtarget: //当前的DOM元素 ios系统下 数字变蓝多位数字在ios系统下会被识别为电话变得可点击123&lt;!-- 阻止方法加meta标签 --&gt;&lt;meta name="format-detection" content="telephone=no" /&gt; textarea去掉右下角可拖动按钮可以使用 resize: none; 来禁用 textarea 右下角的拖动图标。 apicloud获取本地文件路径api.fsDir]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[汉字转换拼音函数]]></title>
      <url>%2F2017%2F05%2F10%2F%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%8B%BC%E9%9F%B3%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[汉字转换为拼音调用ConvertPinyin()函数, 参数为你要转换的汉字 返回值就是转换后的拼音 可以只返回首字母或者首字母大写的全拼拼音 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447var phoneticTranscriptionObj = &#123; "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869", "chai": "\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87", "chan": "\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94", "chang": "\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3", "chao": "\u8d85\u6284\u949e\u671d\u5632\u6f6e\u5de2\u5435\u7092\u600a\u7ec9\u6641\u8016", "che": "\u8f66\u626f\u64a4\u63a3\u5f7b\u6f88\u577c\u5c6e\u7817", "chen": "\u90f4\u81e3\u8fb0\u5c18\u6668\u5ff1\u6c89\u9648\u8d81\u886c\u79f0\u8c0c\u62bb\u55d4\u5bb8\u741b\u6987\u809c\u80c2\u789c\u9f80", "cheng": "\u6491\u57ce\u6a59\u6210\u5448\u4e58\u7a0b\u60e9\u6f84\u8bda\u627f\u901e\u9a8b\u79e4\u57d5\u5d4a\u5fb5\u6d48\u67a8\u67fd\u6a18\u665f\u584d\u77a0\u94d6\u88ce\u86cf\u9172", "chi": "\u5403\u75f4\u6301\u5319\u6c60\u8fdf\u5f1b\u9a70\u803b\u9f7f\u4f88\u5c3a\u8d64\u7fc5\u65a5\u70bd\u50ba\u5880\u82aa\u830c\u640b\u53f1\u54e7\u557b\u55e4\u5f73\u996c\u6cb2\u5ab8\u6555\u80dd\u7719\u7735\u9e31\u761b\u892b\u86a9\u87ad\u7b1e\u7bea\u8c49\u8e05\u8e1f\u9b51", "chong": "\u5145\u51b2\u866b\u5d07\u5ba0\u833a\u5fe1\u61a7\u94f3\u825f", "chou": "\u62bd\u916c\u7574\u8e0c\u7a20\u6101\u7b79\u4ec7\u7ef8\u7785\u4e11\u4fe6\u5733\u5e31\u60c6\u6eb4\u59af\u7633\u96e0\u9c8b", "chu": "\u81ed\u521d\u51fa\u6a71\u53a8\u8e87\u9504\u96cf\u6ec1\u9664\u695a\u7840\u50a8\u77d7\u6410\u89e6\u5904\u4e8d\u520d\u61b7\u7ecc\u6775\u696e\u6a17\u870d\u8e70\u9edc", "chuan": "\u63e3\u5ddd\u7a7f\u693d\u4f20\u8239\u5598\u4e32\u63be\u821b\u60f4\u9044\u5ddb\u6c1a\u948f\u9569\u8221", "chuang": "\u75ae\u7a97\u5e62\u5e8a\u95ef\u521b\u6006", "chui": "\u5439\u708a\u6376\u9524\u5782\u9672\u68f0\u69cc", "chun": "\u6625\u693f\u9187\u5507\u6df3\u7eaf\u8822\u4fc3\u83bc\u6c8c\u80ab\u6710\u9e51\u877d", "chuo": "\u6233\u7ef0\u851f\u8fb6\u8f8d\u955e\u8e14\u9f8a", "ci": "\u75b5\u8328\u78c1\u96cc\u8f9e\u6148\u74f7\u8bcd\u6b64\u523a\u8d50\u6b21\u8360\u5472\u5d6f\u9e5a\u8785\u7ccd\u8d91", "cong": "\u806a\u8471\u56f1\u5306\u4ece\u4e1b\u506c\u82c1\u6dd9\u9aa2\u742e\u7481\u679e", "cu": "\u51d1\u7c97\u918b\u7c07\u731d\u6b82\u8e59", "cuan": "\u8e7f\u7be1\u7a9c\u6c46\u64ba\u6615\u7228", "cui": "\u6467\u5d14\u50ac\u8106\u7601\u7cb9\u6dec\u7fe0\u8403\u60b4\u7480\u69b1\u96b9", "cun": "\u6751\u5b58\u5bf8\u78cb\u5fd6\u76b4", "cuo": "\u64ae\u6413\u63aa\u632b\u9519\u539d\u811e\u9509\u77ec\u75e4\u9e7e\u8e49\u8e9c", "da": "\u642d\u8fbe\u7b54\u7629\u6253\u5927\u8037\u54d2\u55d2\u601b\u59b2\u75b8\u8921\u7b2a\u977c\u9791", "dai": "\u5446\u6b79\u50a3\u6234\u5e26\u6b86\u4ee3\u8d37\u888b\u5f85\u902e\u6020\u57ed\u7519\u5454\u5cb1\u8fe8\u902f\u9a80\u7ed0\u73b3\u9edb", "dan": "\u803d\u62c5\u4e39\u5355\u90f8\u63b8\u80c6\u65e6\u6c2e\u4f46\u60ee\u6de1\u8bde\u5f39\u86cb\u4ebb\u510b\u5369\u840f\u5556\u6fb9\u6a90\u6b9a\u8d55\u7708\u7605\u8043\u7baa", "dang": "\u5f53\u6321\u515a\u8361\u6863\u8c20\u51fc\u83ea\u5b95\u7800\u94db\u88c6", "dao": "\u5200\u6363\u8e48\u5012\u5c9b\u7977\u5bfc\u5230\u7a3b\u60bc\u9053\u76d7\u53e8\u5541\u5fc9\u6d2e\u6c18\u7118\u5fd1\u7e9b", "de": "\u5fb7\u5f97\u7684\u951d", "deng": "\u8e6c\u706f\u767b\u7b49\u77aa\u51f3\u9093\u5654\u5d9d\u6225\u78f4\u956b\u7c26", "di": "\u5824\u4f4e\u6ef4\u8fea\u654c\u7b1b\u72c4\u6da4\u7fdf\u5ae1\u62b5\u5e95\u5730\u8482\u7b2c\u5e1d\u5f1f\u9012\u7f14\u6c10\u7c74\u8bcb\u8c1b\u90b8\u577b\u839c\u837b\u5600\u5a23\u67e2\u68e3\u89cc\u7825\u78b2\u7747\u955d\u7f9d\u9ab6", "dian": "\u98a0\u6382\u6ec7\u7898\u70b9\u5178\u975b\u57ab\u7535\u4f43\u7538\u5e97\u60e6\u5960\u6dc0\u6bbf\u4e36\u963d\u576b\u57dd\u5dc5\u73b7\u765c\u766b\u7c1f\u8e2e", "diao": "\u7889\u53fc\u96d5\u51cb\u5201\u6389\u540a\u9493\u8c03\u8f7a\u94de\u8729\u7c9c\u8c82", "die": "\u8dcc\u7239\u789f\u8776\u8fed\u8c0d\u53e0\u4f5a\u57a4\u581e\u63f2\u558b\u6e2b\u8f76\u7252\u74de\u8936\u800b\u8e40\u9cbd\u9cce", "ding": "\u4e01\u76ef\u53ee\u9489\u9876\u9f0e\u952d\u5b9a\u8ba2\u4e22\u4ec3\u5576\u738e\u815a\u7887\u753a\u94e4\u7594\u8035\u914a", "dong": "\u4e1c\u51ac\u8463\u61c2\u52a8\u680b\u4f97\u606b\u51bb\u6d1e\u578c\u549a\u5cbd\u5cd2\u5902\u6c21\u80e8\u80f4\u7850\u9e2b", "dou": "\u515c\u6296\u6597\u9661\u8c46\u9017\u75d8\u8538\u94ad\u7aa6\u7aac\u86aa\u7bfc\u9161", "du": "\u90fd\u7763\u6bd2\u728a\u72ec\u8bfb\u5835\u7779\u8d4c\u675c\u9540\u809a\u5ea6\u6e21\u5992\u828f\u561f\u6e0e\u691f\u6a50\u724d\u8839\u7b03\u9ad1\u9ee9", "duan": "\u7aef\u77ed\u953b\u6bb5\u65ad\u7f0e\u5f56\u6934\u7145\u7c16", "dui": "\u5806\u5151\u961f\u5bf9\u603c\u619d\u7893", "dun": "\u58a9\u5428\u8e72\u6566\u987f\u56e4\u949d\u76fe\u9041\u7096\u7818\u7905\u76f9\u9566\u8db8", "duo": "\u6387\u54c6\u591a\u593a\u579b\u8eb2\u6735\u8dfa\u8235\u5241\u60f0\u5815\u5484\u54da\u7f0d\u67c1\u94ce\u88f0\u8e31", "e": "\u86fe\u5ce8\u9e45\u4fc4\u989d\u8bb9\u5a25\u6076\u5384\u627c\u904f\u9102\u997f\u5669\u8c14\u57a9\u57ad\u82ca\u83aa\u843c\u5443\u6115\u5c59\u5a40\u8f6d\u66f7\u816d\u786a\u9507\u9537\u9e57\u989a\u9cc4", "en": "\u6069\u84bd\u6441\u5514\u55ef", "er": "\u800c\u513f\u8033\u5c14\u9975\u6d31\u4e8c\u8d30\u8fe9\u73e5\u94d2\u9e38\u9c95", "fa": "\u53d1\u7f5a\u7b4f\u4f10\u4e4f\u9600\u6cd5\u73d0\u57a1\u781d", "fan": "\u85e9\u5e06\u756a\u7ffb\u6a0a\u77fe\u9492\u7e41\u51e1\u70e6\u53cd\u8fd4\u8303\u8d29\u72af\u996d\u6cdb\u8629\u5e61\u72ad\u68b5\u6535\u71d4\u7548\u8e6f", "fang": "\u574a\u82b3\u65b9\u80aa\u623f\u9632\u59a8\u4eff\u8bbf\u7eba\u653e\u531a\u90a1\u5f77\u94ab\u822b\u9c82", "fei": "\u83f2\u975e\u5561\u98de\u80a5\u532a\u8bfd\u5420\u80ba\u5e9f\u6cb8\u8d39\u82be\u72d2\u60b1\u6ddd\u5983\u7ecb\u7eef\u69a7\u8153\u6590\u6249\u7953\u7829\u9544\u75f1\u871a\u7bda\u7fe1\u970f\u9cb1", "fen": "\u82ac\u915a\u5429\u6c1b\u5206\u7eb7\u575f\u711a\u6c7e\u7c89\u594b\u4efd\u5fff\u6124\u7caa\u507e\u7035\u68fc\u610d\u9cbc\u9f22", "feng": "\u4e30\u5c01\u67ab\u8702\u5cf0\u950b\u98ce\u75af\u70fd\u9022\u51af\u7f1d\u8bbd\u5949\u51e4\u4ff8\u9146\u8451\u6ca3\u781c", "fu": "\u4f5b\u5426\u592b\u6577\u80a4\u5b75\u6276\u62c2\u8f90\u5e45\u6c1f\u7b26\u4f0f\u4fd8\u670d\u6d6e\u6daa\u798f\u88b1\u5f17\u752b\u629a\u8f85\u4fef\u91dc\u65a7\u812f\u8151\u5e9c\u8150\u8d74\u526f\u8986\u8d4b\u590d\u5085\u4ed8\u961c\u7236\u8179\u8d1f\u5bcc\u8ba3\u9644\u5987\u7f1a\u5490\u5310\u51eb\u90db\u8299\u82fb\u832f\u83a9\u83d4\u544b\u5e5e\u6ecf\u8274\u5b5a\u9a78\u7ec2\u6874\u8d59\u9efb\u9efc\u7f58\u7a03\u99a5\u864d\u86a8\u8709\u8760\u876e\u9eb8\u8dba\u8dd7\u9cc6", "ga": "\u5676\u560e\u86e4\u5c2c\u5477\u5c15\u5c1c\u65ee\u9486", "gai": "\u8be5\u6539\u6982\u9499\u76d6\u6e89\u4e10\u9654\u5793\u6224\u8d45\u80f2", "gan": "\u5e72\u7518\u6746\u67d1\u7aff\u809d\u8d76\u611f\u79c6\u6562\u8d63\u5769\u82f7\u5c34\u64c0\u6cd4\u6de6\u6f89\u7ec0\u6a44\u65f0\u77f8\u75b3\u9150", "gang": "\u5188\u521a\u94a2\u7f38\u809b\u7eb2\u5c97\u6e2f\u6206\u7f61\u9883\u7b7b", "gong": "\u6760\u5de5\u653b\u529f\u606d\u9f9a\u4f9b\u8eac\u516c\u5bab\u5f13\u5de9\u6c5e\u62f1\u8d21\u5171\u857b\u5efe\u54a3\u73d9\u80b1\u86a3\u86e9\u89e5", "gao": "\u7bd9\u768b\u9ad8\u818f\u7f94\u7cd5\u641e\u9550\u7a3f\u544a\u777e\u8bf0\u90dc\u84bf\u85c1\u7f1f\u69d4\u69c1\u6772\u9506", "ge": "\u54e5\u6b4c\u6401\u6208\u9e3d\u80f3\u7599\u5272\u9769\u845b\u683c\u9601\u9694\u94ec\u4e2a\u5404\u9b32\u4ee1\u54ff\u5865\u55dd\u7ea5\u643f\u8188\u784c\u94ea\u9549\u88bc\u988c\u867c\u8238\u9abc\u9ac2", "gei": "\u7ed9", "gen": "\u6839\u8ddf\u4e98\u831b\u54cf\u826e", "geng": "\u8015\u66f4\u5e9a\u7fb9\u57c2\u803f\u6897\u54fd\u8d53\u9ca0", "gou": "\u94a9\u52fe\u6c9f\u82df\u72d7\u57a2\u6784\u8d2d\u591f\u4f5d\u8bdf\u5ca3\u9058\u5abe\u7f11\u89cf\u5f40\u9e32\u7b31\u7bdd\u97b2", "gu": "\u8f9c\u83c7\u5495\u7b8d\u4f30\u6cbd\u5b64\u59d1\u9f13\u53e4\u86ca\u9aa8\u8c37\u80a1\u6545\u987e\u56fa\u96c7\u560f\u8bc2\u83f0\u54cc\u5d2e\u6c69\u688f\u8f71\u726f\u727f\u80cd\u81cc\u6bc2\u77bd\u7f5f\u94b4\u9522\u74e0\u9e2a\u9e44\u75fc\u86c4\u9164\u89da\u9cb4\u9ab0\u9e58", "gua": "\u522e\u74dc\u5250\u5be1\u6302\u8902\u5366\u8bd6\u5471\u681d\u9e39", "guai": "\u4e56\u62d0\u602a\u54d9", "guan": "\u68fa\u5173\u5b98\u51a0\u89c2\u7ba1\u9986\u7f50\u60ef\u704c\u8d2f\u500c\u839e\u63bc\u6dab\u76e5\u9e73\u9ccf", "guang": "\u5149\u5e7f\u901b\u72b7\u6844\u80f1\u7592", "gui": "\u7470\u89c4\u572d\u7845\u5f52\u9f9f\u95fa\u8f68\u9b3c\u8be1\u7678\u6842\u67dc\u8dea\u8d35\u523d\u5326\u523f\u5e8b\u5b84\u59ab\u6867\u7085\u6677\u7688\u7c0b\u9c91\u9cdc", "gun": "\u8f8a\u6eda\u68cd\u4e28\u886e\u7ef2\u78d9\u9ca7", "guo": "\u9505\u90ed\u56fd\u679c\u88f9\u8fc7\u9998\u8803\u57da\u63b4\u5459\u56d7\u5e3c\u5d1e\u7313\u6901\u8662\u951e\u8052\u872e\u873e\u8748", "ha": "\u54c8", "hai": "\u9ab8\u5b69\u6d77\u6c26\u4ea5\u5bb3\u9a87\u54b4\u55e8\u988f\u91a2", "han": "\u9163\u61a8\u90af\u97e9\u542b\u6db5\u5bd2\u51fd\u558a\u7f55\u7ff0\u64bc\u634d\u65f1\u61be\u608d\u710a\u6c57\u6c49\u9097\u83e1\u6496\u961a\u701a\u6657\u7113\u9894\u86b6\u9f3e", "hen": "\u592f\u75d5\u5f88\u72e0\u6068", "hang": "\u676d\u822a\u6c86\u7ed7\u73e9\u6841", "hao": "\u58d5\u568e\u8c6a\u6beb\u90dd\u597d\u8017\u53f7\u6d69\u8585\u55e5\u5686\u6fe0\u704f\u660a\u7693\u98a2\u869d", "he": "\u5475\u559d\u8377\u83cf\u6838\u79be\u548c\u4f55\u5408\u76d2\u8c89\u9602\u6cb3\u6db8\u8d6b\u8910\u9e64\u8d3a\u8bc3\u52be\u58d1\u85ff\u55d1\u55ec\u9616\u76cd\u86b5\u7fee", "hei": "\u563f\u9ed1", "heng": "\u54fc\u4ea8\u6a2a\u8861\u6052\u8a07\u8605", "hong": "\u8f70\u54c4\u70d8\u8679\u9e3f\u6d2a\u5b8f\u5f18\u7ea2\u9ec9\u8ba7\u836d\u85a8\u95f3\u6cd3", "hou": "\u5589\u4faf\u7334\u543c\u539a\u5019\u540e\u5820\u5f8c\u9005\u760a\u7bcc\u7cc7\u9c8e\u9aba", "hu": "\u547c\u4e4e\u5ffd\u745a\u58f6\u846b\u80e1\u8774\u72d0\u7cca\u6e56\u5f27\u864e\u552c\u62a4\u4e92\u6caa\u6237\u51b1\u553f\u56eb\u5cb5\u7322\u6019\u60da\u6d52\u6ef9\u7425\u69f2\u8f77\u89f3\u70c0\u7173\u623d\u6248\u795c\u9e55\u9e71\u7b0f\u9190\u659b", "hua": "\u82b1\u54d7\u534e\u733e\u6ed1\u753b\u5212\u5316\u8bdd\u5290\u6d4d\u9a85\u6866\u94e7\u7a1e", "huai": "\u69d0\u5f8a\u6000\u6dee\u574f\u8fd8\u8e1d", "huan": "\u6b22\u73af\u6853\u7f13\u6362\u60a3\u5524\u75ea\u8c62\u7115\u6da3\u5ba6\u5e7b\u90c7\u5942\u57b8\u64d0\u571c\u6d39\u6d63\u6f36\u5bf0\u902d\u7f33\u953e\u9ca9\u9b1f", "huang": "\u8352\u614c\u9ec4\u78fa\u8757\u7c27\u7687\u51f0\u60f6\u714c\u6643\u5e4c\u604d\u8c0e\u968d\u5fa8\u6e5f\u6f62\u9051\u749c\u8093\u7640\u87e5\u7bc1\u9cc7", "hui": "\u7070\u6325\u8f89\u5fbd\u6062\u86d4\u56de\u6bc1\u6094\u6167\u5349\u60e0\u6666\u8d3f\u79fd\u4f1a\u70e9\u6c47\u8bb3\u8bf2\u7ed8\u8bd9\u8334\u835f\u8559\u54d5\u5599\u96b3\u6d04\u5f57\u7f0b\u73f2\u6656\u605a\u867a\u87ea\u9ebe", "hun": "\u8364\u660f\u5a5a\u9b42\u6d51\u6df7\u8be8\u9984\u960d\u6eb7\u7f17", "huo": "\u8c41\u6d3b\u4f19\u706b\u83b7\u6216\u60d1\u970d\u8d27\u7978\u6509\u56af\u5925\u94ac\u952a\u956c\u8020\u8816", "ji": "\u51fb\u573e\u57fa\u673a\u7578\u7a3d\u79ef\u7b95\u808c\u9965\u8ff9\u6fc0\u8ba5\u9e21\u59ec\u7ee9\u7f09\u5409\u6781\u68d8\u8f91\u7c4d\u96c6\u53ca\u6025\u75be\u6c72\u5373\u5ac9\u7ea7\u6324\u51e0\u810a\u5df1\u84df\u6280\u5180\u5b63\u4f0e\u796d\u5242\u60b8\u6d4e\u5bc4\u5bc2\u8ba1\u8bb0\u65e2\u5fcc\u9645\u5993\u7ee7\u7eaa\u5c45\u4e0c\u4e69\u525e\u4f76\u4f74\u8114\u58bc\u82a8\u82b0\u8401\u84ba\u857a\u638e\u53fd\u54ad\u54dc\u5527\u5c8c\u5d74\u6d0e\u5f50\u5c50\u9aa5\u757f\u7391\u696b\u6b9b\u621f\u6222\u8d4d\u89ca\u7284\u9f51\u77f6\u7f81\u5d47\u7a37\u7620\u7635\u866e\u7b08\u7b04\u66a8\u8dfb\u8dfd\u9701\u9c9a\u9cab\u9afb\u9e82", "jia": "\u5609\u67b7\u5939\u4f73\u5bb6\u52a0\u835a\u988a\u8d3e\u7532\u94be\u5047\u7a3c\u4ef7\u67b6\u9a7e\u5ac1\u4f3d\u90cf\u62ee\u5cac\u6d43\u8fe6\u73c8\u621b\u80db\u605d\u94d7\u9553\u75c2\u86f1\u7b33\u8888\u8dcf", "jian": "\u6b7c\u76d1\u575a\u5c16\u7b3a\u95f4\u714e\u517c\u80a9\u8270\u5978\u7f04\u8327\u68c0\u67ec\u78b1\u7877\u62e3\u6361\u7b80\u4fed\u526a\u51cf\u8350\u69db\u9274\u8df5\u8d31\u89c1\u952e\u7bad\u4ef6\u5065\u8230\u5251\u996f\u6e10\u6e85\u6da7\u5efa\u50ed\u8c0f\u8c2b\u83c5\u84b9\u641b\u56dd\u6e54\u8e47\u8b07\u7f23\u67a7\u67d9\u6957\u620b\u622c\u726e\u728d\u6bfd\u8171\u7751\u950f\u9e63\u88e5\u7b15\u7bb4\u7fe6\u8dbc\u8e3a\u9ca3\u97af", "jiang": "\u50f5\u59dc\u5c06\u6d46\u6c5f\u7586\u848b\u6868\u5956\u8bb2\u5320\u9171\u964d\u8333\u6d1a\u7edb\u7f30\u729f\u7913\u8029\u7ce8\u8c47", "jiao": "\u8549\u6912\u7901\u7126\u80f6\u4ea4\u90ca\u6d47\u9a84\u5a07\u56bc\u6405\u94f0\u77eb\u4fa5\u811a\u72e1\u89d2\u997a\u7f34\u7ede\u527f\u6559\u9175\u8f7f\u8f83\u53eb\u4f7c\u50ec\u832d\u6322\u564d\u5ce4\u5fbc\u59e3\u7e9f\u656b\u768e\u9e6a\u86df\u91ae\u8de4\u9c9b", "jie": "\u7a96\u63ed\u63a5\u7686\u79f8\u8857\u9636\u622a\u52ab\u8282\u6854\u6770\u6377\u776b\u7aed\u6d01\u7ed3\u89e3\u59d0\u6212\u85c9\u82a5\u754c\u501f\u4ecb\u75a5\u8beb\u5c4a\u5048\u8ba6\u8bd8\u5588\u55df\u736c\u5a55\u5b51\u6840\u7352\u78a3\u9534\u7596\u88b7\u9889\u86a7\u7faf\u9c92\u9ab1\u9aeb", "jin": "\u5dfe\u7b4b\u65a4\u91d1\u4eca\u6d25\u895f\u7d27\u9526\u4ec5\u8c28\u8fdb\u9773\u664b\u7981\u8fd1\u70ec\u6d78\u5c3d\u537a\u8369\u5807\u5664\u9991\u5ed1\u5997\u7f19\u747e\u69ff\u8d46\u89d0\u9485\u9513\u887f\u77dc", "jing": "\u52b2\u8346\u5162\u830e\u775b\u6676\u9cb8\u4eac\u60ca\u7cbe\u7cb3\u7ecf\u4e95\u8b66\u666f\u9888\u9759\u5883\u656c\u955c\u5f84\u75c9\u9756\u7adf\u7ade\u51c0\u522d\u5106\u9631\u83c1\u734d\u61ac\u6cfe\u8ff3\u5f2a\u5a67\u80bc\u80eb\u8148\u65cc", "jiong": "\u70af\u7a98\u5182\u8fe5\u6243", "jiu": "\u63ea\u7a76\u7ea0\u7396\u97ed\u4e45\u7078\u4e5d\u9152\u53a9\u6551\u65e7\u81fc\u8205\u548e\u5c31\u759a\u50e6\u557e\u9604\u67e9\u6855\u9e6b\u8d73\u9b0f", "ju": "\u97a0\u62d8\u72d9\u75bd\u9a79\u83ca\u5c40\u5480\u77e9\u4e3e\u6cae\u805a\u62d2\u636e\u5de8\u5177\u8ddd\u8e1e\u952f\u4ff1\u53e5\u60e7\u70ac\u5267\u5028\u8bb5\u82e3\u82f4\u8392\u63ac\u907d\u5c66\u741a\u67b8\u6910\u6998\u6989\u6a58\u728b\u98d3\u949c\u9514\u7aad\u88fe\u8d84\u91b5\u8e3d\u9f83\u96ce\u97ab", "juan": "\u6350\u9e43\u5a1f\u5026\u7737\u5377\u7ee2\u9104\u72f7\u6d93\u684a\u8832\u9529\u954c\u96bd", "jue": "\u6485\u652b\u6289\u6398\u5014\u7235\u89c9\u51b3\u8bc0\u7edd\u53a5\u5282\u8c32\u77cd\u8568\u5658\u5d1b\u7357\u5b53\u73cf\u6877\u6a5b\u721d\u9562\u8e76\u89d6", "jun": "\u5747\u83cc\u94a7\u519b\u541b\u5cfb\u4fca\u7ae3\u6d5a\u90e1\u9a8f\u6343\u72fb\u76b2\u7b60\u9e87", "ka": "\u5580\u5496\u5361\u4f67\u5494\u80e9", "ke": "\u54af\u5777\u82db\u67ef\u68f5\u78d5\u9897\u79d1\u58f3\u54b3\u53ef\u6e34\u514b\u523b\u5ba2\u8bfe\u5ca2\u606a\u6e98\u9a92\u7f02\u73c2\u8f72\u6c2a\u778c\u94b6\u75b4\u7aa0\u874c\u9ac1", "kai": "\u5f00\u63e9\u6977\u51ef\u6168\u5240\u57b2\u8488\u5ffe\u607a\u94e0\u950e", "kan": "\u520a\u582a\u52d8\u574e\u780d\u770b\u4f83\u51f5\u83b0\u83b6\u6221\u9f9b\u77b0", "kang": "\u5eb7\u6177\u7ce0\u625b\u6297\u4ea2\u7095\u5751\u4f09\u95f6\u94aa", "kao": "\u8003\u62f7\u70e4\u9760\u5c3b\u6832\u7292\u94d0", "ken": "\u80af\u5543\u57a6\u6073\u57a0\u88c9\u9880", "keng": "\u542d\u5fd0\u94ff", "kong": "\u7a7a\u6050\u5b54\u63a7\u5025\u5d06\u7b9c", "kou": "\u62a0\u53e3\u6263\u5bc7\u82a4\u853b\u53e9\u770d\u7b58", "ku": "\u67af\u54ed\u7a9f\u82e6\u9177\u5e93\u88e4\u5233\u5800\u55be\u7ed4\u9ab7", "kua": "\u5938\u57ae\u630e\u8de8\u80ef\u4f89", "kuai": "\u5757\u7b77\u4fa9\u5feb\u84af\u90d0\u8489\u72ef\u810d", "kuan": "\u5bbd\u6b3e\u9acb", "kuang": "\u5321\u7b50\u72c2\u6846\u77ff\u7736\u65f7\u51b5\u8bd3\u8bf3\u909d\u5739\u593c\u54d0\u7ea9\u8d36", "kui": "\u4e8f\u76d4\u5cbf\u7aa5\u8475\u594e\u9b41\u5080\u9988\u6127\u6e83\u9997\u532e\u5914\u9697\u63c6\u55b9\u559f\u609d\u6126\u9615\u9035\u668c\u777d\u8069\u8770\u7bd1\u81fe\u8dec", "kun": "\u5764\u6606\u6346\u56f0\u6083\u9603\u7428\u951f\u918c\u9cb2\u9ae1", "kuo": "\u62ec\u6269\u5ed3\u9614\u86de", "la": "\u5783\u62c9\u5587\u8721\u814a\u8fa3\u5566\u524c\u647a\u908b\u65ef\u782c\u760c", "lai": "\u83b1\u6765\u8d56\u5d03\u5f95\u6d9e\u6fd1\u8d49\u7750\u94fc\u765e\u7c41", "lan": "\u84dd\u5a6a\u680f\u62e6\u7bee\u9611\u5170\u6f9c\u8c30\u63fd\u89c8\u61d2\u7f06\u70c2\u6ee5\u5549\u5c9a\u61d4\u6f24\u6984\u6593\u7f71\u9567\u8934", "lang": "\u7405\u6994\u72fc\u5eca\u90ce\u6717\u6d6a\u83a8\u8497\u5577\u9606\u9512\u7a02\u8782", "lao": "\u635e\u52b3\u7262\u8001\u4f6c\u59e5\u916a\u70d9\u6d9d\u5520\u5d02\u6833\u94d1\u94f9\u75e8\u91aa", "le": "\u52d2\u4e50\u808b\u4ec2\u53fb\u561e\u6cd0\u9cd3", "lei": "\u96f7\u956d\u857e\u78ca\u7d2f\u5121\u5792\u64c2\u7c7b\u6cea\u7fb8\u8bd4\u837d\u54a7\u6f2f\u5ad8\u7f27\u6a91\u8012\u9179", "ling": "\u68f1\u51b7\u62ce\u73b2\u83f1\u96f6\u9f84\u94c3\u4f36\u7f9a\u51cc\u7075\u9675\u5cad\u9886\u53e6\u4ee4\u9143\u5844\u82d3\u5464\u56f9\u6ce0\u7eeb\u67c3\u68c2\u74f4\u8046\u86c9\u7fce\u9cae", "leng": "\u695e\u6123", "li": "\u5398\u68a8\u7281\u9ece\u7bf1\u72f8\u79bb\u6f13\u7406\u674e\u91cc\u9ca4\u793c\u8389\u8354\u540f\u6817\u4e3d\u5389\u52b1\u783e\u5386\u5229\u5088\u4f8b\u4fd0\u75e2\u7acb\u7c92\u6ca5\u96b6\u529b\u7483\u54e9\u4fea\u4fda\u90e6\u575c\u82c8\u8385\u84e0\u85dc\u6369\u5456\u5533\u55b1\u7301\u6ea7\u6fa7\u9026\u5a0c\u5ae0\u9a8a\u7f21\u73de\u67a5\u680e\u8f79\u623e\u783a\u8a48\u7f79\u9502\u9e42\u75a0\u75ac\u86ce\u870a\u8821\u7b20\u7be5\u7c9d\u91b4\u8dde\u96f3\u9ca1\u9ce2\u9ee7", "lian": "\u4fe9\u8054\u83b2\u8fde\u9570\u5ec9\u601c\u6d9f\u5e18\u655b\u8138\u94fe\u604b\u70bc\u7ec3\u631b\u8539\u5941\u6f4b\u6fc2\u5a08\u740f\u695d\u6b93\u81c1\u81a6\u88e2\u880a\u9ca2", "liang": "\u7cae\u51c9\u6881\u7cb1\u826f\u4e24\u8f86\u91cf\u667e\u4eae\u8c05\u589a\u690b\u8e09\u9753\u9b49", "liao": "\u64a9\u804a\u50da\u7597\u71ce\u5be5\u8fbd\u6f66\u4e86\u6482\u9563\u5ed6\u6599\u84fc\u5c25\u5639\u7360\u5bee\u7f2d\u948c\u9e69\u8022", "lie": "\u5217\u88c2\u70c8\u52a3\u730e\u51bd\u57d2\u6d0c\u8d94\u8e90\u9b23", "lin": "\u7433\u6797\u78f7\u9716\u4e34\u90bb\u9cde\u6dcb\u51db\u8d41\u541d\u853a\u5d99\u5eea\u9074\u6aa9\u8f9a\u77b5\u7cbc\u8e8f\u9e9f", "liu": "\u6e9c\u7409\u69b4\u786b\u998f\u7559\u5218\u7624\u6d41\u67f3\u516d\u62a1\u507b\u848c\u6cd6\u6d4f\u905b\u9a9d\u7efa\u65d2\u7198\u950d\u954f\u9e68\u938f", "long": "\u9f99\u804b\u5499\u7b3c\u7abf\u9686\u5784\u62e2\u9647\u5f04\u5785\u830f\u6cf7\u73d1\u680a\u80e7\u783b\u7643", "lou": "\u697c\u5a04\u6402\u7bd3\u6f0f\u964b\u55bd\u5d5d\u9542\u7618\u8027\u877c\u9ac5", "lu": "\u82a6\u5362\u9885\u5e90\u7089\u63b3\u5364\u864f\u9c81\u9e93\u788c\u9732\u8def\u8d42\u9e7f\u6f5e\u7984\u5f55\u9646\u622e\u5786\u6445\u64b8\u565c\u6cf8\u6e0c\u6f09\u7490\u680c\u6a79\u8f73\u8f82\u8f98\u6c07\u80ea\u9565\u9e2c\u9e6d\u7c0f\u823b\u9c88", "lv": "\u9a74\u5415\u94dd\u4fa3\u65c5\u5c65\u5c61\u7f15\u8651\u6c2f\u5f8b\u7387\u6ee4\u7eff\u634b\u95fe\u6988\u8182\u7a06\u891b", "luan": "\u5ce6\u5b6a\u6ee6\u5375\u4e71\u683e\u9e3e\u92ae", "lue": "\u63a0\u7565\u950a", "lun": "\u8f6e\u4f26\u4ed1\u6ca6\u7eb6\u8bba\u56f5", "luo": "\u841d\u87ba\u7f57\u903b\u9523\u7ba9\u9aa1\u88f8\u843d\u6d1b\u9a86\u7edc\u502e\u8366\u645e\u7321\u6cfa\u6924\u8136\u9559\u7630\u96d2", "ma": "\u5988\u9ebb\u739b\u7801\u8682\u9a6c\u9a82\u561b\u5417\u551b\u72b8\u5b37\u6769\u9ebd", "mai": "\u57cb\u4e70\u9ea6\u5356\u8fc8\u8109\u52a2\u836c\u54aa\u973e", "man": "\u7792\u9992\u86ee\u6ee1\u8513\u66fc\u6162\u6f2b\u8c29\u5881\u5e54\u7f26\u71b3\u9558\u989f\u87a8\u9cd7\u9794", "mang": "\u8292\u832b\u76f2\u5fd9\u83bd\u9099\u6f2d\u6726\u786d\u87d2", "meng": "\u6c13\u840c\u8499\u6aac\u76df\u9530\u731b\u68a6\u5b5f\u52d0\u750d\u77a2\u61f5\u791e\u867b\u8722\u8813\u824b\u8268\u9efe", "miao": "\u732b\u82d7\u63cf\u7784\u85d0\u79d2\u6e3a\u5e99\u5999\u55b5\u9088\u7f08\u7f2a\u676a\u6dfc\u7707\u9e4b\u8731", "mao": "\u8305\u951a\u6bdb\u77db\u94c6\u536f\u8302\u5192\u5e3d\u8c8c\u8d38\u4f94\u88a4\u52d6\u8306\u5cc1\u7441\u6634\u7266\u8004\u65c4\u61cb\u7780\u86d1\u8765\u87ca\u9ae6", "me": "\u4e48", "mei": "\u73ab\u679a\u6885\u9176\u9709\u7164\u6ca1\u7709\u5a92\u9541\u6bcf\u7f8e\u6627\u5bd0\u59b9\u5a9a\u5776\u8393\u5d4b\u7338\u6d7c\u6e44\u6963\u9545\u9e5b\u8882\u9b45", "men": "\u95e8\u95f7\u4eec\u626a\u739f\u7116\u61d1\u9494", "mi": "\u772f\u919a\u9761\u7cdc\u8ff7\u8c1c\u5f25\u7c73\u79d8\u89c5\u6ccc\u871c\u5bc6\u5e42\u8288\u5196\u8c27\u863c\u5627\u7315\u736f\u6c68\u5b93\u5f2d\u8112\u6549\u7cf8\u7e3b\u9e8b", "mian": "\u68c9\u7720\u7ef5\u5195\u514d\u52c9\u5a29\u7f05\u9762\u6c94\u6e4e\u817c\u7704", "mie": "\u8511\u706d\u54a9\u881b\u7bfe", "min": "\u6c11\u62bf\u76bf\u654f\u60af\u95fd\u82e0\u5cb7\u95f5\u6cef\u73c9", "ming": "\u660e\u879f\u9e23\u94ed\u540d\u547d\u51a5\u8317\u6e9f\u669d\u7791\u9169", "miu": "\u8c2c", "mo": "\u6478\u6479\u8611\u6a21\u819c\u78e8\u6469\u9b54\u62b9\u672b\u83ab\u58a8\u9ed8\u6cab\u6f20\u5bde\u964c\u8c1f\u8309\u84e6\u998d\u5aeb\u9546\u79e3\u763c\u8031\u87c6\u8c8a\u8c98", "mou": "\u8c0b\u725f\u67d0\u53b6\u54de\u5a7a\u7738\u936a", "mu": "\u62c7\u7261\u4ea9\u59c6\u6bcd\u5893\u66ae\u5e55\u52df\u6155\u6728\u76ee\u7766\u7267\u7a46\u4eeb\u82dc\u5452\u6c90\u6bea\u94bc", "na": "\u62ff\u54ea\u5450\u94a0\u90a3\u5a1c\u7eb3\u5185\u637a\u80ad\u954e\u8872\u7bac", "nai": "\u6c16\u4e43\u5976\u8010\u5948\u9f10\u827f\u8418\u67f0", "nan": "\u5357\u7537\u96be\u56ca\u5583\u56e1\u6960\u8169\u877b\u8d67", "nao": "\u6320\u8111\u607c\u95f9\u5b6c\u57b4\u7331\u7459\u7847\u94d9\u86f2", "ne": "\u6dd6\u5462\u8bb7", "nei": "\u9981", "nen": "\u5ae9\u80fd\u6798\u6041", "ni": "\u59ae\u9713\u502a\u6ce5\u5c3c\u62df\u4f60\u533f\u817b\u9006\u6eba\u4f32\u576d\u730a\u6029\u6ee0\u6635\u65ce\u7962\u615d\u7768\u94cc\u9cb5", "nian": "\u852b\u62c8\u5e74\u78be\u64b5\u637b\u5ff5\u5eff\u8f87\u9ecf\u9c87\u9cb6", "niang": "\u5a18\u917f", "niao": "\u9e1f\u5c3f\u8311\u5b32\u8132\u8885", "nie": "\u634f\u8042\u5b7d\u556e\u954a\u954d\u6d85\u4e5c\u9667\u8616\u55eb\u8080\u989e\u81ec\u8e51", "nin": "\u60a8\u67e0", "ning": "\u72de\u51dd\u5b81\u62e7\u6cde\u4f5e\u84e5\u549b\u752f\u804d", "niu": "\u725b\u626d\u94ae\u7ebd\u72c3\u5ff8\u599e\u86b4", "nong": "\u8113\u6d53\u519c\u4fac", "nu": "\u5974\u52aa\u6012\u5476\u5e11\u5f29\u80ec\u5b65\u9a7d", "nv": "\u5973\u6067\u9495\u8844", "nuan": "\u6696", "nuenue": "\u8650", "nue": "\u759f\u8c11", "nuo": "\u632a\u61e6\u7cef\u8bfa\u50a9\u6426\u558f\u9518", "ou": "\u54e6\u6b27\u9e25\u6bb4\u85d5\u5455\u5076\u6ca4\u6004\u74ef\u8026", "pa": "\u556a\u8db4\u722c\u5e15\u6015\u7436\u8469\u7b62", "pai": "\u62cd\u6392\u724c\u5f98\u6e43\u6d3e\u4ff3\u848e", "pan": "\u6500\u6f58\u76d8\u78d0\u76fc\u7554\u5224\u53db\u723f\u6cee\u88a2\u897b\u87e0\u8e52", "pang": "\u4e53\u5e9e\u65c1\u802a\u80d6\u6ec2\u9004", "pao": "\u629b\u5486\u5228\u70ae\u888d\u8dd1\u6ce1\u530f\u72cd\u5e96\u812c\u75b1", "pei": "\u5478\u80da\u57f9\u88f4\u8d54\u966a\u914d\u4f69\u6c9b\u638a\u8f94\u5e14\u6de0\u65c6\u952b\u9185\u9708", "pen": "\u55b7\u76c6\u6e53", "peng": "\u7830\u62a8\u70f9\u6f8e\u5f6d\u84ec\u68da\u787c\u7bf7\u81a8\u670b\u9e4f\u6367\u78b0\u576f\u580b\u562d\u6026\u87db", "pi": "\u7812\u9739\u6279\u62ab\u5288\u7435\u6bd7\u5564\u813e\u75b2\u76ae\u5339\u75de\u50fb\u5c41\u8b6c\u4e15\u9674\u90b3\u90eb\u572e\u9f19\u64d7\u567c\u5e80\u5ab2\u7eb0\u6787\u7513\u7765\u7f74\u94cd\u75e6\u7656\u758b\u868d\u8c94", "pian": "\u7bc7\u504f\u7247\u9a97\u8c1d\u9a88\u728f\u80fc\u890a\u7fe9\u8e41", "piao": "\u98d8\u6f02\u74e2\u7968\u527d\u560c\u5ad6\u7f25\u6b8d\u779f\u87b5", "pie": "\u6487\u77a5\u4e3f\u82e4\u6c15", "pin": "\u62fc\u9891\u8d2b\u54c1\u8058\u62da\u59d8\u5ad4\u6980\u725d\u98a6", "ping": "\u4e52\u576a\u82f9\u840d\u5e73\u51ed\u74f6\u8bc4\u5c4f\u4fdc\u5a09\u67b0\u9c86", "po": "\u5761\u6cfc\u9887\u5a46\u7834\u9b44\u8feb\u7c95\u53f5\u9131\u6ea5\u73c0\u948b\u94b7\u76a4\u7b38", "pou": "\u5256\u88d2\u8e23", "pu": "\u6251\u94fa\u4ec6\u8386\u8461\u83e9\u84b2\u57d4\u6734\u5703\u666e\u6d66\u8c31\u66dd\u7011\u530d\u5657\u6fee\u749e\u6c06\u9564\u9568\u8e7c", "qi": "\u671f\u6b3a\u6816\u621a\u59bb\u4e03\u51c4\u6f06\u67d2\u6c8f\u5176\u68cb\u5947\u6b67\u7566\u5d0e\u8110\u9f50\u65d7\u7948\u7941\u9a91\u8d77\u5c82\u4e5e\u4f01\u542f\u5951\u780c\u5668\u6c14\u8fc4\u5f03\u6c7d\u6ce3\u8bab\u4e9f\u4e93\u573b\u8291\u840b\u847a\u5601\u5c7a\u5c90\u6c54\u6dc7\u9a90\u7eee\u742a\u7426\u675e\u6864\u69ed\u6b39\u797a\u61a9\u789b\u86f4\u871e\u7da6\u7dae\u8dbf\u8e4a\u9ccd\u9e92", "qia": "\u6390\u6070\u6d3d\u845c", "qian": "\u7275\u6266\u948e\u94c5\u5343\u8fc1\u7b7e\u4edf\u8c26\u4e7e\u9ed4\u94b1\u94b3\u524d\u6f5c\u9063\u6d45\u8c34\u5811\u5d4c\u6b20\u6b49\u4f65\u9621\u828a\u82a1\u8368\u63ae\u5c8d\u60ad\u614a\u9a9e\u6434\u8930\u7f31\u6920\u80b7\u6106\u94a4\u8654\u7b9d", "qiang": "\u67aa\u545b\u8154\u7f8c\u5899\u8537\u5f3a\u62a2\u5af1\u6a2f\u6217\u709d\u9516\u9535\u956a\u8941\u8723\u7f9f\u8deb\u8dc4", "qiao": "\u6a47\u9539\u6572\u6084\u6865\u77a7\u4e54\u4fa8\u5de7\u9798\u64ac\u7fd8\u5ced\u4fcf\u7a8d\u5281\u8bee\u8c2f\u835e\u6100\u6194\u7f32\u6a35\u6bf3\u7857\u8df7\u9792", "qie": "\u5207\u8304\u4e14\u602f\u7a83\u90c4\u553c\u60ec\u59be\u6308\u9532\u7ba7", "qin": "\u94a6\u4fb5\u4eb2\u79e6\u7434\u52e4\u82b9\u64d2\u79bd\u5bdd\u6c81\u82a9\u84c1\u8572\u63ff\u5423\u55ea\u5659\u6eb1\u6a8e\u8793\u887e", "qing": "\u9752\u8f7b\u6c22\u503e\u537f\u6e05\u64ce\u6674\u6c30\u60c5\u9877\u8bf7\u5e86\u5029\u82d8\u570a\u6aa0\u78ec\u873b\u7f44\u7b90\u8b26\u9cad\u9ee5", "qiong": "\u743c\u7a77\u909b\u8315\u7a79\u7b47\u928e", "qiu": "\u79cb\u4e18\u90b1\u7403\u6c42\u56da\u914b\u6cc5\u4fc5\u6c3d\u5def\u827d\u72b0\u6e6b\u9011\u9052\u6978\u8d47\u9e20\u866c\u86af\u8764\u88d8\u7cd7\u9cc5\u9f3d", "qu": "\u8d8b\u533a\u86c6\u66f2\u8eaf\u5c48\u9a71\u6e20\u53d6\u5a36\u9f8b\u8da3\u53bb\u8bce\u52ac\u8556\u8627\u5c96\u8862\u9612\u74a9\u89d1\u6c0d\u795b\u78f2\u766f\u86d0\u883c\u9eb4\u77bf\u9ee2", "quan": "\u5708\u98a7\u6743\u919b\u6cc9\u5168\u75ca\u62f3\u72ac\u5238\u529d\u8be0\u8343\u737e\u609b\u7efb\u8f81\u754e\u94e8\u8737\u7b4c\u9b08", "que": "\u7f3a\u7094\u7638\u5374\u9e4a\u69b7\u786e\u96c0\u9619\u60ab", "qun": "\u88d9\u7fa4\u9021", "ran": "\u7136\u71c3\u5189\u67d3\u82d2\u9aef", "rang": "\u74e4\u58e4\u6518\u56b7\u8ba9\u79b3\u7a70", "rao": "\u9976\u6270\u7ed5\u835b\u5a06\u6861", "ruo": "\u60f9\u82e5\u5f31", "re": "\u70ed\u504c", "ren": "\u58ec\u4ec1\u4eba\u5fcd\u97e7\u4efb\u8ba4\u5203\u598a\u7eab\u4ede\u834f\u845a\u996a\u8f6b\u7a14\u887d", "reng": "\u6254\u4ecd", "ri": "\u65e5", "rong": "\u620e\u8338\u84c9\u8363\u878d\u7194\u6eb6\u5bb9\u7ed2\u5197\u5d58\u72e8\u7f1b\u6995\u877e", "rou": "\u63c9\u67d4\u8089\u7cc5\u8e42\u97a3", "ru": "\u8339\u8815\u5112\u5b7a\u5982\u8fb1\u4e73\u6c5d\u5165\u8925\u84d0\u85b7\u5685\u6d33\u6ebd\u6fe1\u94f7\u8966\u98a5", "ruan": "\u8f6f\u962e\u670a", "rui": "\u854a\u745e\u9510\u82ae\u8564\u777f\u868b", "run": "\u95f0\u6da6", "sa": "\u6492\u6d12\u8428\u5345\u4ee8\u6332\u98d2", "sai": "\u816e\u9cc3\u585e\u8d5b\u567b", "san": "\u4e09\u53c1\u4f1e\u6563\u5f61\u9993\u6c35\u6bf5\u7cc1\u9730", "sang": "\u6851\u55d3\u4e27\u6421\u78c9\u98a1", "sao": "\u6414\u9a9a\u626b\u5ac2\u57fd\u81ca\u7619\u9ccb", "se": "\u745f\u8272\u6da9\u556c\u94e9\u94ef\u7a51", "sen": "\u68ee", "seng": "\u50e7", "sha": "\u838e\u7802\u6740\u5239\u6c99\u7eb1\u50bb\u5565\u715e\u810e\u6b43\u75e7\u88df\u970e\u9ca8", "shai": "\u7b5b\u6652\u917e", "shan": "\u73ca\u82eb\u6749\u5c71\u5220\u717d\u886b\u95ea\u9655\u64c5\u8d61\u81b3\u5584\u6c55\u6247\u7f2e\u5261\u8baa\u912f\u57cf\u829f\u6f78\u59d7\u9a9f\u81bb\u9490\u759d\u87ee\u8222\u8dda\u9cdd", "shang": "\u5892\u4f24\u5546\u8d4f\u664c\u4e0a\u5c1a\u88f3\u57a7\u7ef1\u6b87\u71b5\u89de", "shao": "\u68a2\u634e\u7a0d\u70e7\u828d\u52fa\u97f6\u5c11\u54e8\u90b5\u7ecd\u52ad\u82d5\u6f72\u86f8\u7b24\u7b72\u8244", "she": "\u5962\u8d4a\u86c7\u820c\u820d\u8d66\u6444\u5c04\u6151\u6d89\u793e\u8bbe\u538d\u4f58\u731e\u7572\u9e9d", "shen": "\u7837\u7533\u547b\u4f38\u8eab\u6df1\u5a20\u7ec5\u795e\u6c88\u5ba1\u5a76\u751a\u80be\u614e\u6e17\u8bdc\u8c02\u5432\u54c2\u6e16\u6939\u77e7\u8703", "sheng": "\u58f0\u751f\u7525\u7272\u5347\u7ef3\u7701\u76db\u5269\u80dc\u5723\u4e1e\u6e11\u5ab5\u771a\u7b19", "shi": "\u5e08\u5931\u72ee\u65bd\u6e7f\u8bd7\u5c38\u8671\u5341\u77f3\u62fe\u65f6\u4ec0\u98df\u8680\u5b9e\u8bc6\u53f2\u77e2\u4f7f\u5c4e\u9a76\u59cb\u5f0f\u793a\u58eb\u4e16\u67ff\u4e8b\u62ed\u8a93\u901d\u52bf\u662f\u55dc\u566c\u9002\u4ed5\u4f8d\u91ca\u9970\u6c0f\u5e02\u6043\u5ba4\u89c6\u8bd5\u8c25\u57d8\u83b3\u84cd\u5f11\u5511\u9963\u8f7c\u8006\u8d33\u70bb\u793b\u94c8\u94ca\u87ab\u8210\u7b6e\u8c55\u9ca5\u9cba", "shou": "\u6536\u624b\u9996\u5b88\u5bff\u6388\u552e\u53d7\u7626\u517d\u624c\u72e9\u7ef6\u824f", "shu": "\u852c\u67a2\u68b3\u6b8a\u6292\u8f93\u53d4\u8212\u6dd1\u758f\u4e66\u8d4e\u5b70\u719f\u85af\u6691\u66d9\u7f72\u8700\u9ecd\u9f20\u5c5e\u672f\u8ff0\u6811\u675f\u620d\u7ad6\u5885\u5eb6\u6570\u6f31\u6055\u500f\u587e\u83fd\u5fc4\u6cad\u6d91\u6f8d\u59dd\u7ebe\u6bf9\u8167\u6bb3\u956f\u79eb\u9e6c", "shua": "\u5237\u800d\u5530\u6dae", "shuai": "\u6454\u8870\u7529\u5e05\u87c0", "shuan": "\u6813\u62f4\u95e9", "shuang": "\u971c\u53cc\u723d\u5b40", "shui": "\u8c01\u6c34\u7761\u7a0e", "shun": "\u542e\u77ac\u987a\u821c\u6042", "shuo": "\u8bf4\u7855\u6714\u70c1\u84b4\u6420\u55cd\u6fef\u5981\u69ca\u94c4", "si": "\u65af\u6495\u5636\u601d\u79c1\u53f8\u4e1d\u6b7b\u8086\u5bfa\u55e3\u56db\u4f3a\u4f3c\u9972\u5df3\u53ae\u4fdf\u5155\u83e5\u549d\u6c5c\u6cd7\u6f8c\u59d2\u9a77\u7f0c\u7940\u7960\u9536\u9e36\u801c\u86f3\u7b25", "song": "\u677e\u8038\u6002\u9882\u9001\u5b8b\u8bbc\u8bf5\u51c7\u83d8\u5d27\u5d69\u5fea\u609a\u6dde\u7ae6", "sou": "\u641c\u8258\u64de\u55fd\u53df\u55d6\u55fe\u998a\u6eb2\u98d5\u778d\u953c\u878b", "su": "\u82cf\u9165\u4fd7\u7d20\u901f\u7c9f\u50f3\u5851\u6eaf\u5bbf\u8bc9\u8083\u5919\u8c21\u850c\u55c9\u612b\u7c0c\u89eb\u7a23", "suan": "\u9178\u849c\u7b97", "sui": "\u867d\u968b\u968f\u7ee5\u9ad3\u788e\u5c81\u7a57\u9042\u96a7\u795f\u84d1\u51ab\u8c07\u6fc9\u9083\u71e7\u772d\u7762", "sun": "\u5b59\u635f\u7b0b\u836a\u72f2\u98e7\u69ab\u8de3\u96bc", "suo": "\u68ad\u5506\u7f29\u7410\u7d22\u9501\u6240\u5522\u55e6\u5a11\u686b\u7743\u7fa7", "ta": "\u584c\u4ed6\u5b83\u5979\u5854\u736d\u631e\u8e4b\u8e0f\u95fc\u6ebb\u9062\u69bb\u6c93", "tai": "\u80ce\u82d4\u62ac\u53f0\u6cf0\u915e\u592a\u6001\u6c70\u90b0\u85b9\u80bd\u70b1\u949b\u8dc6\u9c90", "tan": "\u574d\u644a\u8d2a\u762b\u6ee9\u575b\u6a80\u75f0\u6f6d\u8c2d\u8c08\u5766\u6bef\u8892\u78b3\u63a2\u53f9\u70ad\u90ef\u8548\u6619\u94bd\u952c\u8983", "tang": "\u6c64\u5858\u642a\u5802\u68e0\u819b\u5510\u7cd6\u50a5\u9967\u6e8f\u746d\u94f4\u9557\u8025\u8797\u87b3\u7fb0\u91a3", "thang": "\u5018\u8eba\u6dcc", "theng": "\u8d9f\u70eb", "tao": "\u638f\u6d9b\u6ed4\u7ee6\u8404\u6843\u9003\u6dd8\u9676\u8ba8\u5957\u6311\u9f17\u5555\u97ec\u9955", "te": "\u7279", "teng": "\u85e4\u817e\u75bc\u8a8a\u6ed5", "ti": "\u68af\u5254\u8e22\u9511\u63d0\u9898\u8e44\u557c\u4f53\u66ff\u568f\u60d5\u6d95\u5243\u5c49\u8351\u608c\u9016\u7ee8\u7f07\u9e48\u88fc\u918d", "tian": "\u5929\u6dfb\u586b\u7530\u751c\u606c\u8214\u8146\u63ad\u5fdd\u9617\u6b84\u754b\u94bf\u86ba", "tiao": "\u6761\u8fe2\u773a\u8df3\u4f7b\u7967\u94eb\u7a95\u9f86\u9ca6", "tie": "\u8d34\u94c1\u5e16\u841c\u992e", "ting": "\u5385\u542c\u70c3\u6c40\u5ef7\u505c\u4ead\u5ead\u633a\u8247\u839b\u8476\u5a77\u6883\u8713\u9706", "tong": "\u901a\u6850\u916e\u77b3\u540c\u94dc\u5f64\u7ae5\u6876\u6345\u7b52\u7edf\u75db\u4f5f\u50ee\u4edd\u833c\u55f5\u6078\u6f7c\u783c", "tou": "\u5077\u6295\u5934\u900f\u4ea0", "tu": "\u51f8\u79c3\u7a81\u56fe\u5f92\u9014\u6d82\u5c60\u571f\u5410\u5154\u580d\u837c\u83df\u948d\u9174", "tuan": "\u6e4d\u56e2\u7583", "tui": "\u63a8\u9893\u817f\u8715\u892a\u9000\u5fd2\u717a", "tun": "\u541e\u5c6f\u81c0\u9968\u66be\u8c5a\u7a80", "tuo": "\u62d6\u6258\u8131\u9e35\u9640\u9a6e\u9a7c\u692d\u59a5\u62d3\u553e\u4e47\u4f57\u5768\u5eb9\u6cb1\u67dd\u7823\u7ba8\u8204\u8dce\u9f0d", "wa": "\u6316\u54c7\u86d9\u6d3c\u5a03\u74e6\u889c\u4f64\u5a32\u817d", "wai": "\u6b6a\u5916", "wan": "\u8c4c\u5f2f\u6e7e\u73a9\u987d\u4e38\u70f7\u5b8c\u7897\u633d\u665a\u7696\u60cb\u5b9b\u5a49\u4e07\u8155\u525c\u8284\u82cb\u83c0\u7ea8\u7efe\u742c\u8118\u7579\u873f\u7ba2", "wang": "\u6c6a\u738b\u4ea1\u6789\u7f51\u5f80\u65fa\u671b\u5fd8\u5984\u7f54\u5c22\u60d8\u8f8b\u9b4d", "wei": "\u5a01\u5dcd\u5fae\u5371\u97e6\u8fdd\u6845\u56f4\u552f\u60df\u4e3a\u6f4d\u7ef4\u82c7\u840e\u59d4\u4f1f\u4f2a\u5c3e\u7eac\u672a\u851a\u5473\u754f\u80c3\u5582\u9b4f\u4f4d\u6e2d\u8c13\u5c09\u6170\u536b\u502d\u504e\u8bff\u9688\u8473\u8587\u5e0f\u5e37\u5d34\u5d6c\u7325\u732c\u95f1\u6ca9\u6d27\u6da0\u9036\u5a13\u73ae\u97ea\u8ece\u709c\u7168\u71a8\u75ff\u8249\u9c94", "wen": "\u761f\u6e29\u868a\u6587\u95fb\u7eb9\u543b\u7a33\u7d0a\u95ee\u520e\u6120\u960c\u6c76\u74ba\u97eb\u6b81\u96ef", "weng": "\u55e1\u7fc1\u74ee\u84ca\u8579", "wo": "\u631d\u8717\u6da1\u7a9d\u6211\u65a1\u5367\u63e1\u6c83\u83b4\u5e44\u6e25\u674c\u809f\u9f8c", "wu": "\u5deb\u545c\u94a8\u4e4c\u6c61\u8bec\u5c4b\u65e0\u829c\u68a7\u543e\u5434\u6bcb\u6b66\u4e94\u6342\u5348\u821e\u4f0d\u4fae\u575e\u620a\u96fe\u6664\u7269\u52ff\u52a1\u609f\u8bef\u5140\u4ef5\u9622\u90ac\u572c\u82b4\u5e91\u6003\u5fe4\u6d6f\u5be4\u8fd5\u59a9\u9a9b\u727e\u7110\u9e49\u9e5c\u8708\u92c8\u9f2f", "xi": "\u6614\u7199\u6790\u897f\u7852\u77fd\u6670\u563b\u5438\u9521\u727a\u7a00\u606f\u5e0c\u6089\u819d\u5915\u60dc\u7184\u70ef\u6eaa\u6c50\u7280\u6a84\u88ad\u5e2d\u4e60\u5ab3\u559c\u94e3\u6d17\u7cfb\u9699\u620f\u7ec6\u50d6\u516e\u96b0\u90d7\u831c\u8478\u84f0\u595a\u550f\u5f99\u9969\u960b\u6d60\u6dc5\u5c63\u5b09\u73ba\u6a28\u66e6\u89cb\u6b37\u71b9\u798a\u79a7\u94b8\u7699\u7a78\u8725\u87cb\u823e\u7fb2\u7c9e\u7fd5\u91af\u9f37", "xia": "\u778e\u867e\u5323\u971e\u8f96\u6687\u5ce1\u4fa0\u72ed\u4e0b\u53a6\u590f\u5413\u6380\u846d\u55c4\u72ce\u9050\u7455\u7856\u7615\u7f45\u9ee0", "xian": "\u9528\u5148\u4ed9\u9c9c\u7ea4\u54b8\u8d24\u8854\u8237\u95f2\u6d8e\u5f26\u5acc\u663e\u9669\u73b0\u732e\u53bf\u817a\u9985\u7fa1\u5baa\u9677\u9650\u7ebf\u51bc\u85d3\u5c98\u7303\u66b9\u5a34\u6c19\u7946\u9e47\u75eb\u86ac\u7b45\u7c7c\u9170\u8df9", "xiang": "\u76f8\u53a2\u9576\u9999\u7bb1\u8944\u6e58\u4e61\u7fd4\u7965\u8be6\u60f3\u54cd\u4eab\u9879\u5df7\u6a61\u50cf\u5411\u8c61\u8297\u8459\u9977\u5ea0\u9aa7\u7f03\u87d3\u9c9e\u98e8", "xiao": "\u8427\u785d\u9704\u524a\u54ee\u56a3\u9500\u6d88\u5bb5\u6dc6\u6653\u5c0f\u5b5d\u6821\u8096\u5578\u7b11\u6548\u54d3\u54bb\u5d24\u6f47\u900d\u9a81\u7ee1\u67ad\u67b5\u7b71\u7bab\u9b48", "xie": "\u6954\u4e9b\u6b47\u874e\u978b\u534f\u631f\u643a\u90aa\u659c\u80c1\u8c10\u5199\u68b0\u5378\u87f9\u61c8\u6cc4\u6cfb\u8c22\u5c51\u5055\u4eb5\u52f0\u71ee\u85a4\u64b7\u5ee8\u7023\u9082\u7ec1\u7f2c\u69ad\u698d\u6b59\u8e9e", "xin": "\u85aa\u82af\u950c\u6b23\u8f9b\u65b0\u5ffb\u5fc3\u4fe1\u8845\u56df\u99a8\u8398\u6b46\u94fd\u946b", "xing": "\u661f\u8165\u7329\u60fa\u5174\u5211\u578b\u5f62\u90a2\u884c\u9192\u5e78\u674f\u6027\u59d3\u9649\u8347\u8365\u64e4\u60bb\u784e", "xiong": "\u5144\u51f6\u80f8\u5308\u6c79\u96c4\u718a\u828e", "xiu": "\u4f11\u4fee\u7f9e\u673d\u55c5\u9508\u79c0\u8896\u7ee3\u83a0\u5cab\u9990\u5ea5\u9e3a\u8c85\u9af9", "xu": "\u589f\u620c\u9700\u865a\u5618\u987b\u5f90\u8bb8\u84c4\u9157\u53d9\u65ed\u5e8f\u755c\u6064\u7d6e\u5a7f\u7eea\u7eed\u8bb4\u8be9\u5729\u84ff\u6035\u6d2b\u6e86\u987c\u6829\u7166\u7809\u76f1\u80e5\u7cc8\u9191", "xuan": "\u8f69\u55a7\u5ba3\u60ac\u65cb\u7384\u9009\u7663\u7729\u7eda\u5107\u8c16\u8431\u63ce\u9994\u6ceb\u6d35\u6e32\u6f29\u7487\u6966\u6684\u70ab\u714a\u78b9\u94c9\u955f\u75c3", "xue": "\u9774\u859b\u5b66\u7a74\u96ea\u8840\u5671\u6cf6\u9cd5", "xun": "\u52cb\u718f\u5faa\u65ec\u8be2\u5bfb\u9a6f\u5de1\u6b89\u6c5b\u8bad\u8baf\u900a\u8fc5\u5dfd\u57d9\u8340\u85b0\u5ccb\u5f87\u6d54\u66db\u7aa8\u91ba\u9c9f", "ya": "\u538b\u62bc\u9e26\u9e2d\u5440\u4e2b\u82bd\u7259\u869c\u5d16\u8859\u6daf\u96c5\u54d1\u4e9a\u8bb6\u4f22\u63e0\u5416\u5c88\u8fd3\u5a05\u740a\u6860\u6c29\u7811\u775a\u75d6", "yan": "\u7109\u54bd\u9609\u70df\u6df9\u76d0\u4e25\u7814\u8712\u5ca9\u5ef6\u8a00\u989c\u960e\u708e\u6cbf\u5944\u63a9\u773c\u884d\u6f14\u8273\u5830\u71d5\u538c\u781a\u96c1\u5501\u5f66\u7130\u5bb4\u8c1a\u9a8c\u53a3\u9765\u8d5d\u4fe8\u5043\u5156\u8ba0\u8c33\u90fe\u9122\u82ab\u83f8\u5d26\u6079\u95eb\u960f\u6d07\u6e6e\u6edf\u598d\u5ae3\u7430\u664f\u80ed\u814c\u7131\u7f68\u7b75\u917d\u9b47\u990d\u9f39", "yang": "\u6b83\u592e\u9e2f\u79e7\u6768\u626c\u4f6f\u75a1\u7f8a\u6d0b\u9633\u6c27\u4ef0\u75d2\u517b\u6837\u6f3e\u5f89\u600f\u6cf1\u7080\u70ca\u6059\u86d8\u9785", "yao": "\u9080\u8170\u5996\u7476\u6447\u5c27\u9065\u7a91\u8c23\u59da\u54ac\u8200\u836f\u8981\u8000\u592d\u723b\u5406\u5d3e\u5fad\u7039\u5e7a\u73e7\u6773\u66dc\u80b4\u9e5e\u7a88\u7e47\u9cd0", "ye": "\u6930\u564e\u8036\u7237\u91ce\u51b6\u4e5f\u9875\u6396\u4e1a\u53f6\u66f3\u814b\u591c\u6db2\u8c12\u90ba\u63f6\u9980\u6654\u70e8\u94d8", "yi": "\u4e00\u58f9\u533b\u63d6\u94f1\u4f9d\u4f0a\u8863\u9890\u5937\u9057\u79fb\u4eea\u80f0\u7591\u6c82\u5b9c\u59e8\u5f5d\u6905\u8681\u501a\u5df2\u4e59\u77e3\u4ee5\u827a\u6291\u6613\u9091\u5c79\u4ebf\u5f79\u81c6\u9038\u8084\u75ab\u4ea6\u88d4\u610f\u6bc5\u5fc6\u4e49\u76ca\u6ea2\u8be3\u8bae\u8c0a\u8bd1\u5f02\u7ffc\u7fcc\u7ece\u5208\u5293\u4f7e\u8bd2\u572a\u572f\u57f8\u61ff\u82e1\u858f\u5f08\u5955\u6339\u5f0b\u5453\u54a6\u54bf\u566b\u5cc4\u5db7\u7317\u9974\u603f\u6021\u6092\u6f2a\u8fe4\u9a7f\u7f22\u6baa\u8d3b\u65d6\u71a0\u9487\u9552\u9571\u75cd\u7617\u7654\u7fca\u8864\u8734\u8223\u7fbf\u7ff3\u914f\u9edf", "yin": "\u8335\u836b\u56e0\u6bb7\u97f3\u9634\u59fb\u541f\u94f6\u6deb\u5bc5\u996e\u5c39\u5f15\u9690\u5370\u80e4\u911e\u5819\u831a\u5591\u72fa\u5924\u6c24\u94df\u763e\u8693\u972a\u9f88", "ying": "\u82f1\u6a31\u5a74\u9e70\u5e94\u7f28\u83b9\u8424\u8425\u8367\u8747\u8fce\u8d62\u76c8\u5f71\u9896\u786c\u6620\u5b34\u90e2\u8314\u83ba\u8426\u6484\u5624\u81ba\u6ee2\u6f46\u701b\u745b\u748e\u6979\u9e66\u763f\u988d\u7f42", "yo": "\u54df\u5537", "yong": "\u62e5\u4f63\u81c3\u75c8\u5eb8\u96cd\u8e0a\u86f9\u548f\u6cf3\u6d8c\u6c38\u607f\u52c7\u7528\u4fd1\u58c5\u5889\u6175\u9095\u955b\u752c\u9cd9\u9954", "you": "\u5e7d\u4f18\u60a0\u5fe7\u5c24\u7531\u90ae\u94c0\u72b9\u6cb9\u6e38\u9149\u6709\u53cb\u53f3\u4f51\u91c9\u8bf1\u53c8\u5e7c\u5363\u6538\u4f91\u83b8\u5466\u56ff\u5ba5\u67da\u7337\u7256\u94d5\u75a3\u8763\u9c7f\u9edd\u9f2c", "yu": "\u8fc2\u6de4\u4e8e\u76c2\u6986\u865e\u611a\u8206\u4f59\u4fde\u903e\u9c7c\u6109\u6e1d\u6e14\u9685\u4e88\u5a31\u96e8\u4e0e\u5c7f\u79b9\u5b87\u8bed\u7fbd\u7389\u57df\u828b\u90c1\u5401\u9047\u55bb\u5cea\u5fa1\u6108\u6b32\u72f1\u80b2\u8a89\u6d74\u5bd3\u88d5\u9884\u8c6b\u9a6d\u79ba\u6bd3\u4f1b\u4fe3\u8c00\u8c15\u8438\u84e3\u63c4\u5581\u5704\u5709\u5d5b\u72f3\u996b\u5ebe\u9608\u59aa\u59a4\u7ea1\u745c\u6631\u89ce\u8174\u6b24\u65bc\u715c\u71e0\u807f\u94b0\u9e46\u7610\u7600\u7ab3\u8753\u7afd\u8201\u96e9\u9f89", "yuan": "\u9e33\u6e0a\u51a4\u5143\u57a3\u8881\u539f\u63f4\u8f95\u56ed\u5458\u5706\u733f\u6e90\u7f18\u8fdc\u82d1\u613f\u6028\u9662\u586c\u6c85\u5a9b\u7457\u6a7c\u7230\u7722\u9e22\u8788\u9f0b", "yue": "\u66f0\u7ea6\u8d8a\u8dc3\u94a5\u5cb3\u7ca4\u6708\u60a6\u9605\u9fa0\u6a3e\u5216\u94ba", "yun": "\u8018\u4e91\u90e7\u5300\u9668\u5141\u8fd0\u8574\u915d\u6655\u97f5\u5b55\u90d3\u82b8\u72c1\u607d\u7ead\u6b92\u6600\u6c32", "za": "\u531d\u7838\u6742\u62f6\u5482", "zai": "\u683d\u54c9\u707e\u5bb0\u8f7d\u518d\u5728\u54b1\u5d3d\u753e", "zan": "\u6512\u6682\u8d5e\u74d2\u661d\u7c2a\u7ccc\u8db1\u933e", "zang": "\u8d43\u810f\u846c\u5958\u6215\u81e7", "zao": "\u906d\u7cdf\u51ff\u85fb\u67a3\u65e9\u6fa1\u86a4\u8e81\u566a\u9020\u7682\u7076\u71e5\u5523\u7f2b", "ze": "\u8d23\u62e9\u5219\u6cfd\u4ec4\u8d5c\u5567\u8fee\u6603\u7b2e\u7ba6\u8234", "zei": "\u8d3c", "zen": "\u600e\u8c2e", "zeng": "\u589e\u618e\u66fe\u8d60\u7f2f\u7511\u7f7e\u9503", "zha": "\u624e\u55b3\u6e23\u672d\u8f67\u94e1\u95f8\u7728\u6805\u69a8\u548b\u4e4d\u70b8\u8bc8\u63f8\u5412\u54a4\u54f3\u600d\u781f\u75c4\u86b1\u9f44", "zhai": "\u6458\u658b\u5b85\u7a84\u503a\u5be8\u7826", "zhan": "\u77bb\u6be1\u8a79\u7c98\u6cbe\u76cf\u65a9\u8f97\u5d2d\u5c55\u8638\u6808\u5360\u6218\u7ad9\u6e5b\u7efd\u8c35\u640c\u65c3", "zhang": "\u6a1f\u7ae0\u5f70\u6f33\u5f20\u638c\u6da8\u6756\u4e08\u5e10\u8d26\u4ed7\u80c0\u7634\u969c\u4ec9\u9123\u5e5b\u5d82\u7350\u5adc\u748b\u87d1", "zhao": "\u62db\u662d\u627e\u6cbc\u8d75\u7167\u7f69\u5146\u8087\u53ec\u722a\u8bcf\u68f9\u948a\u7b0a", "zhe": "\u906e\u6298\u54f2\u86f0\u8f99\u8005\u9517\u8517\u8fd9\u6d59\u8c2a\u966c\u67d8\u8f84\u78d4\u9e67\u891a\u8707\u8d6d", "zhen": "\u73cd\u659f\u771f\u7504\u7827\u81fb\u8d1e\u9488\u4fa6\u6795\u75b9\u8bca\u9707\u632f\u9547\u9635\u7f1c\u6862\u699b\u8f78\u8d48\u80d7\u6715\u796f\u755b\u9e29", "zheng": "\u84b8\u6323\u7741\u5f81\u72f0\u4e89\u6014\u6574\u62ef\u6b63\u653f\u5e27\u75c7\u90d1\u8bc1\u8be4\u5ce5\u94b2\u94ee\u7b5d", "zhi": "\u829d\u679d\u652f\u5431\u8718\u77e5\u80a2\u8102\u6c41\u4e4b\u7ec7\u804c\u76f4\u690d\u6b96\u6267\u503c\u4f84\u5740\u6307\u6b62\u8dbe\u53ea\u65e8\u7eb8\u5fd7\u631a\u63b7\u81f3\u81f4\u7f6e\u5e1c\u5cd9\u5236\u667a\u79e9\u7a1a\u8d28\u7099\u75d4\u6ede\u6cbb\u7a92\u536e\u965f\u90c5\u57f4\u82b7\u646d\u5e19\u5fee\u5f58\u54ab\u9a98\u6809\u67b3\u6800\u684e\u8f75\u8f7e\u6534\u8d3d\u81a3\u7949\u7957\u9ef9\u96c9\u9e37\u75e3\u86ed\u7d77\u916f\u8dd6\u8e2c\u8e2f\u8c78\u89ef", "zhong": "\u4e2d\u76c5\u5fe0\u949f\u8877\u7ec8\u79cd\u80bf\u91cd\u4ef2\u4f17\u51a2\u953a\u87bd\u8202\u822f\u8e35", "zhou": "\u821f\u5468\u5dde\u6d32\u8bcc\u7ca5\u8f74\u8098\u5e1a\u5492\u76b1\u5b99\u663c\u9aa4\u5544\u7740\u501c\u8bf9\u836e\u9b3b\u7ea3\u80c4\u78a1\u7c40\u8233\u914e\u9cb7", "zhu": "\u73e0\u682a\u86db\u6731\u732a\u8bf8\u8bdb\u9010\u7af9\u70db\u716e\u62c4\u77a9\u5631\u4e3b\u8457\u67f1\u52a9\u86c0\u8d2e\u94f8\u7b51\u4f4f\u6ce8\u795d\u9a7b\u4f2b\u4f8f\u90be\u82ce\u8331\u6d19\u6e1a\u6f74\u9a7a\u677c\u69e0\u6a65\u70b7\u94e2\u75b0\u7603\u86b0\u7afa\u7bb8\u7fe5\u8e85\u9e88", "zhua": "\u6293", "zhuai": "\u62fd", "zhuan": "\u4e13\u7816\u8f6c\u64b0\u8d5a\u7bc6\u629f\u556d\u989b", "zhuang": "\u6869\u5e84\u88c5\u5986\u649e\u58ee\u72b6\u4e2c", "zhui": "\u690e\u9525\u8ffd\u8d58\u5760\u7f00\u8411\u9a93\u7f12", "zhun": "\u8c06\u51c6", "zhuo": "\u6349\u62d9\u5353\u684c\u7422\u8301\u914c\u707c\u6d4a\u502c\u8bfc\u5ef4\u855e\u64e2\u555c\u6d5e\u6dbf\u6753\u712f\u799a\u65ab", "zi": "\u5179\u54a8\u8d44\u59ff\u6ecb\u6dc4\u5b5c\u7d2b\u4ed4\u7c7d\u6ed3\u5b50\u81ea\u6e0d\u5b57\u8c18\u5d6b\u59ca\u5b73\u7f01\u6893\u8f8e\u8d40\u6063\u7726\u9531\u79ed\u8014\u7b2b\u7ca2\u89dc\u8a3e\u9cbb\u9aed", "zong": "\u9b03\u68d5\u8e2a\u5b97\u7efc\u603b\u7eb5\u8159\u7cbd", "zou": "\u90b9\u8d70\u594f\u63cd\u9139\u9cb0", "zu": "\u79df\u8db3\u5352\u65cf\u7956\u8bc5\u963b\u7ec4\u4fce\u83f9\u5550\u5f82\u9a75\u8e74", "zuan": "\u94bb\u7e82\u6525\u7f35", "zui": "\u5634\u9189\u6700\u7f6a", "zun": "\u5c0a\u9075\u6499\u6a3d\u9cdf", "zuo": "\u6628\u5de6\u4f50\u67de\u505a\u4f5c\u5750\u5ea7\u961d\u963c\u80d9\u795a\u9162", "cou": "\u85ae\u6971\u8f8f\u8160", "nang": "\u652e\u54dd\u56d4\u9995\u66e9", "o": "\u5594", "dia": "\u55f2", "chuai": "\u562c\u81aa\u8e39", "cen": "\u5c91\u6d94", "diu": "\u94e5", "nou": "\u8028", "fou": "\u7f36", "bia": "\u9adf"&#125;;// 汉字转拼音function ConvertPinyin(ChineseCharacter) &#123; var ChineseCharacterLength = ChineseCharacter.length; var phoneticTranscription = ""; var reg = new RegExp('[a-zA-Z0-9\- ]'); for (var i = 0; i &lt; ChineseCharacterLength; i++) &#123; var val = ChineseCharacter.substr(i, 1); var name = arraySearch(val, phoneticTranscriptionObj); if (reg.test(val)) &#123; phoneticTranscription += val; &#125; else if (name !== false) &#123; phoneticTranscription += name; &#125; &#125; phoneticTranscription = phoneticTranscription.replace(/ /g, '-'); while (phoneticTranscription.indexOf('--') &gt; 0) &#123; phoneticTranscription = phoneticTranscription.replace('--', '-'); &#125; return phoneticTranscription;&#125;// 在对象中搜索function arraySearch(litter, phoneticTranscriptionObj) &#123; for (var name in phoneticTranscriptionObj) &#123; if (phoneticTranscriptionObj[name].indexOf(litter) != -1) &#123; return ucfirst(name); break; &#125; &#125; return false;&#125;// 首字母大写function ucfirst(initial) &#123; if (initial.length &gt; 0) &#123; var first = initial.substr(0, 1).toUpperCase(); var spare = initial.substr(1, initial.length); // 返回首字母大写的全拼 return first + spare; // 只返回首字母 // return first; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[全国城市JSON列表——制作城市选择器]]></title>
      <url>%2F2017%2F04%2F26%2F%E5%85%A8%E5%9B%BD%E5%9F%8E%E5%B8%82JSON%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94%E5%88%B6%E4%BD%9C%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[省市县三级 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180[ &#123; "name": "北京", "city": [&#123; "name": "北京", "area": ["东城区", "西城区", "崇文区", "宣武区", "朝阳区", "丰台区", "石景山区", "海淀区", "门头沟区", "房山区", "通州区", "顺义区", "昌平区", "大兴区", "平谷区", "怀柔区", "密云县", "延庆县"] &#125;] &#125;, &#123; "name": "天津", "city": [&#123; "name": "天津", "area": ["和平区", "河东区", "河西区", "南开区", "河北区", "红桥区", "塘沽区", "汉沽区", "大港区", "东丽区", "西青区", "津南区", "北辰区", "武清区", "宝坻区", "宁河县", "静海县", "蓟 县"] &#125;] &#125;, &#123; "name": "河北", "city": [ &#123; "name": "石家庄", "area": ["长安区", "桥东区", "桥西区", "新华区", "郊 区", "井陉矿区", "井陉县", "正定县", "栾城县", "行唐县", "灵寿县", "高邑县", "深泽县", "赞皇县", "无极县", "平山县", "元氏县", "赵 县", "辛集市", "藁", "晋州市", "新乐市", "鹿泉市"] &#125;, &#123; "name": "唐山", "area": ["路南区", "路北区", "古冶区", "开平区", "新 区", "丰润县", "滦 县", "滦南县", "乐亭县", "迁西县", "玉田县", "唐海县", "遵化市", "丰南市", "迁安市"] &#125;, &#123; "name": "秦皇岛", "area": ["海港区", "山海关区", "北戴河区", "青龙满族自治县", "昌黎县", "抚宁县", "卢龙县"] &#125;, &#123; "name": "邯郸", "area": ["邯山区", "丛台区", "复兴区", "峰峰矿区", "邯郸县", "临漳县", "成安县", "大名县", "涉 县", "磁 县", "肥乡县", "永年县", "邱 县", "鸡泽县", "广平县", "馆陶县", "魏 县", "曲周县", "武安市"] &#125;, &#123; "name": "邢台", "area": ["桥东区", "桥西区", "邢台县", "临城县", "内丘县", "柏乡县", "隆尧县", "任 县", "南和县", "宁晋县", "巨鹿县", "新河县", "广宗县", "平乡县", "威 县", "清河县", "临西县", "南宫市", "沙河市"] &#125;, &#123; "name": "保定", "area": ["新市区", "北市区", "南市区", "满城县", "清苑县", "涞水县", "阜平县", "徐水县", "定兴县", "唐 县", "高阳县", "容城县", "涞源县", "望都县", "安新县", "易 县", "曲阳县", "蠡 县", "顺平县", "博野", "雄县", "涿州市", "定州市", "安国市", "高碑店市"] &#125;, &#123; "name": "张家口", "area": ["桥东区", "桥西区", "宣化区", "下花园区", "宣化县", "张北县", "康保县", "沽源县", "尚义县", "蔚 县", "阳原县", "怀安县", "万全县", "怀来县", "涿鹿县", "赤城县", "崇礼县"] &#125;, &#123; "name": "承德", "area": ["双桥区", "双滦区", "鹰手营子矿区", "承德县", "兴隆县", "平泉县", "滦平县", "隆化县", "丰宁满族自治县", "宽城满族自治县", "围场满族蒙古族自治县"] &#125;, &#123; "name": "沧州", "area": ["新华区", "运河区", "沧 县", "青 县", "东光县", "海兴县", "盐山县", "肃宁县", "南皮县", "吴桥县", "献 县", "孟村回族自治县", "泊头市", "任丘市", "黄骅市", "河间市"] &#125;, &#123; "name": "廊坊", "area": ["安次区", "固安县", "永清县", "香河县", "大城县", "文安县", "大厂回族自治县", "霸州市", "三河市"] &#125;, &#123; "name": "衡水", "area": ["桃城区", "枣强县", "武邑县", "武强县", "饶阳县", "安平县", "故城县", "景 县", "阜城县", "冀州市", "深州市"] &#125; ] &#125;, &#123; "name": "山西", "city": [ &#123; "name": "太原", "area": ["小店区", "迎泽区", "杏花岭区", "尖草坪区", "万柏林区", "晋源区", "清徐县", "阳曲县", "娄烦县", "古交市"] &#125;, &#123; "name": "大同", "area": ["城 区", "矿 区", "南郊区", "新荣区", "阳高县", "天镇县", "广灵县", "灵丘县", "浑源县", "左云县", "大同县"] &#125;, &#123; "name": "阳泉", "area": ["城 区", "矿 区", "郊 区", "平定县", "盂 县"] &#125;, &#123; "name": "长治", "area": ["城 区", "郊 区", "长治县", "襄垣县", "屯留县", "平顺县", "黎城县", "壶关县", "长子县", "武乡县", "沁 县", "沁源县", "潞城市"] &#125;, &#123; "name": "晋城", "area": ["城 区", "沁水县", "阳城县", "陵川县", "泽州县", "高平市"] &#125;, &#123; "name": "朔州", "area": ["朔城区", "平鲁区", "山阴县", "应 县", "右玉县", "怀仁县"] &#125;, &#123; "name": "忻州", "area": ["忻府区", "原平市", "定襄县", "五台县", "代 县", "繁峙县", "宁武县", "静乐县", "神池县", "五寨县", "岢岚县", "河曲县", "保德县", "偏关县"] &#125;, &#123; "name": "吕梁", "area": ["离石区", "孝义市", "汾阳市", "文水县", "交城县", "兴 县", "临 县", "柳林县", "石楼县", "岚 县", "方山县", "中阳县", "交口县"] &#125;, &#123; "name": "晋中", "area": ["榆次市", "介休市", "榆社县", "左权县", "和顺县", "昔阳县", "寿阳县", "太谷县", "祁 县", "平遥县", "灵石县"] &#125;, &#123; "name": "临汾", "area": ["临汾市", "侯马市", "霍州市", "曲沃县", "翼城县", "襄汾县", "洪洞县", "古 县", "安泽县", "浮山县", "吉 县", "乡宁县", "蒲 县", "大宁县", "永和县", "隰 县", "汾西县"] &#125;, &#123; "name": "运城", "area": ["运城市", "永济市", "河津市", "芮城县", "临猗县", "万荣县", "新绛县", "稷山县", "闻喜县", "夏 县", "绛 县", "平陆县", "垣曲县"] &#125; ] &#125;, &#123; "name": "内蒙古", "city": [ &#123; "name": "呼和浩特", "area": ["新城区", "回民区", "玉泉区", "郊 区", "土默特左旗", "托克托县", "和林格尔县", "清水河县", "武川县"] &#125;, &#123; "name": "包头", "area": ["东河区", "昆都伦区", "青山区", "石拐矿区", "白云矿区", "郊 区", "土默特右旗", "固阳县", "达尔罕茂明安联合旗"] &#125;, &#123; "name": "乌海", "area": ["海勃湾区", "海南区", "乌达区"] &#125;, &#123; "name": "赤峰", "area": ["红山区", "元宝山区", "松山区", "阿鲁科尔沁旗", "巴林左旗", "巴林右旗", "林西县", "克什克腾旗", "翁牛特旗", "喀喇沁旗", "宁城县", "敖汉旗"] &#125;, &#123; "name": "呼伦贝尔", "area": ["海拉尔市", "满洲里市", "扎兰屯市", "牙克石市", "根河市", "额尔古纳市", "阿荣旗", "莫力达瓦达斡尔族自治旗", "鄂伦春自治旗", "鄂温克族自治旗", "新巴尔虎右旗", "新巴尔虎左旗", "陈巴尔虎旗"] &#125;, &#123; "name": "兴安盟", "area": ["乌兰浩特市", "阿尔山市", "科尔沁右翼前旗", "科尔沁右翼中旗", "扎赉特旗", "突泉县"] &#125;, &#123; "name": "通辽", "area": ["科尔沁区", "霍林郭勒市", "科尔沁左翼中旗", "科尔沁左翼后旗", "开鲁县", "库伦旗", "奈曼旗", "扎鲁特旗"] &#125;, &#123; "name": "锡林郭勒盟", "area": ["二连浩特市", "锡林浩特市", "阿巴嘎旗", "苏尼特左旗", "苏尼特右旗", "东乌珠穆沁旗", "西乌珠穆沁旗", "太仆寺旗", "镶黄旗", "正镶白旗", "正蓝旗", "多伦县"] &#125;, &#123; "name": "乌兰察布盟", "area": ["集宁市", "丰镇市", "卓资县", "化德县", "商都县", "兴和县", "凉城县", "察哈尔右翼前旗", "察哈尔右翼中旗", "察哈尔右翼后旗", "四子王旗"] &#125;, &#123; "name": "伊克昭盟", "area": ["东胜市", "达拉特旗", "准格尔旗", "鄂托克前旗", "鄂托克旗", "杭锦旗", "乌审旗", "伊金霍洛旗"] &#125;, &#123; "name": "巴彦淖尔盟", "area": ["临河市", "五原县", "磴口县", "乌拉特前旗", "乌拉特中旗", "乌拉特后旗", "杭锦后旗"] &#125;, &#123; "name": "阿拉善盟", "area": ["阿拉善左旗", "阿拉善右旗", "额济纳旗"] &#125; ] &#125;, &#123; "name": "辽宁", "city": [ &#123; "name": "沈阳", "area": ["沈河区", "皇姑区", "和平区", "大东区", "铁西区", "苏家屯区", "东陵区", "于洪区", "新民市", "法库县", "辽中县", "康平县", "新城子区", "其他"] &#125;, &#123; "name": "大连", "area": ["西岗区", "中山区", "沙河口区", "甘井子区", "旅顺口区", "金州区", "瓦房店市", "普兰店市", "庄河市", "长海县", "其他"] &#125;, &#123; "name": "鞍山", "area": ["铁东区", "铁西区", "立山区", "千山区", "海城市", "台安县", "岫岩满族自治县", "其他"] &#125;, &#123; "name": "抚顺", "area": ["顺城区", "新抚区", "东洲区", "望花区", "抚顺县", "清原满族自治县", "新宾满族自治县", "其他"] &#125;, &#123; "name": "本溪", "area": ["平山区", "明山区", "溪湖区", "南芬区", "本溪满族自治县", "桓仁满族自治县", "其他"] &#125;, &#123; "name": "丹东", "area": ["振兴区", "元宝区", "振安区", "东港市", "凤城市", "宽甸满族自治县", "其他"] &#125;, &#123; "name": "锦州", "area": ["太和区", "古塔区", "凌河区", "凌海市", "黑山县", "义县", "北宁市", "其他"] &#125;, &#123; "name": "营口", "area": ["站前区", "西市区", "鲅鱼圈区", "老边区", "大石桥市", "盖州市", "其他"] &#125;, &#123; "name": "阜新", "area": ["海州区", "新邱区", "太平区", "清河门区", "细河区", "彰武县", "阜新蒙古族自治县", "其他"] &#125;, &#123; "name": "辽阳", "area": ["白塔区", "文圣区", "宏伟区", "太子河区", "弓长岭区", "灯塔市", "辽阳县", "其他"] &#125;, &#123; "name": "盘锦", "area": ["双台子区", "兴隆台区", "盘山县", "大洼县", "其他"] &#125;, &#123; "name": "铁岭", "area": ["银州区", "清河区", "调兵山市", "开原市", "铁岭县", "昌图县", "西丰县", "其他"] &#125;, &#123; "name": "朝阳", "area": ["双塔区", "龙城区", "凌源市", "北票市", "朝阳县", "建平县", "喀喇沁左翼蒙古族自治县", "其他"] &#125;, &#123; "name": "葫芦岛", "area": ["龙港区", "南票区", "连山区", "兴城市", "绥中县", "建昌县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "吉林", "city": [ &#123; "name": "长春", "area": ["朝阳区", "宽城区", "二道区", "南关区", "绿园区", "双阳区", "九台市", "榆树市", "德惠市", "农安县", "其他"] &#125;, &#123; "name": "吉林", "area": ["船营区", "昌邑区", "龙潭区", "丰满区", "舒兰市", "桦甸市", "蛟河市", "磐石市", "永吉县", "其他"] &#125;, &#123; "name": "四平", "area": ["铁西区", "铁东区", "公主岭市", "双辽市", "梨树县", "伊通满族自治县", "其他"] &#125;, &#123; "name": "辽源", "area": ["龙山区", "西安区", "东辽县", "东丰县", "其他"] &#125;, &#123; "name": "通化", "area": ["东昌区", "二道江区", "梅河口市", "集安市", "通化县", "辉南县", "柳河县", "其他"] &#125;, &#123; "name": "白山", "area": ["八道江区", "江源区", "临江市", "靖宇县", "抚松县", "长白朝鲜族自治县", "其他"] &#125;, &#123; "name": "松原", "area": ["宁江区", "乾安县", "长岭县", "扶余县", "前郭尔罗斯蒙古族自治县", "其他"] &#125;, &#123; "name": "白城", "area": ["洮北区", "大安市", "洮南市", "镇赉县", "通榆县", "其他"] &#125;, &#123; "name": "延边朝鲜族自治州", "area": ["延吉市", "图们市", "敦化市", "龙井市", "珲春市", "和龙市", "安图县", "汪清县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "黑龙江", "city": [ &#123; "name": "哈尔滨", "area": ["松北区", "道里区", "南岗区", "平房区", "香坊区", "道外区", "呼兰区", "阿城区", "双城市", "尚志市", "五常市", "宾县", "方正县", "通河县", "巴彦县", "延寿县", "木兰县", "依兰县", "其他"] &#125;, &#123; "name": "齐齐哈尔", "area": ["龙沙区", "昂昂溪区", "铁锋区", "建华区", "富拉尔基区", "碾子山区", "梅里斯达斡尔族区", "讷河市", "富裕县", "拜泉县", "甘南县", "依安县", "克山县", "泰来县", "克东县", "龙江县", "其他"] &#125;, &#123; "name": "鹤岗", "area": ["兴山区", "工农区", "南山区", "兴安区", "向阳区", "东山区", "萝北县", "绥滨县", "其他"] &#125;, &#123; "name": "双鸭山", "area": ["尖山区", "岭东区", "四方台区", "宝山区", "集贤县", "宝清县", "友谊县", "饶河县", "其他"] &#125;, &#123; "name": "鸡西", "area": ["鸡冠区", "恒山区", "城子河区", "滴道区", "梨树区", "麻山区", "密山市", "虎林市", "鸡东县", "其他"] &#125;, &#123; "name": "大庆", "area": ["萨尔图区", "红岗区", "龙凤区", "让胡路区", "大同区", "林甸县", "肇州县", "肇源县", "杜尔伯特蒙古族自治县", "其他"] &#125;, &#123; "name": "伊春", "area": ["伊春区", "带岭区", "南岔区", "金山屯区", "西林区", "美溪区", "乌马河区", "翠峦区", "友好区", "上甘岭区", "五营区", "红星区", "新青区", "汤旺河区", "乌伊岭区", "铁力市", "嘉荫县", "其他"] &#125;, &#123; "name": "牡丹江", "area": ["爱民区", "东安区", "阳明区", "西安区", "绥芬河市", "宁安市", "海林市", "穆棱市", "林口县", "东宁县", "其他"] &#125;, &#123; "name": "佳木斯", "area": ["向阳区", "前进区", "东风区", "郊区", "同江市", "富锦市", "桦川县", "抚远县", "桦南县", "汤原县", "其他"] &#125;, &#123; "name": "七台河", "area": ["桃山区", "新兴区", "茄子河区", "勃利县", "其他"] &#125;, &#123; "name": "黑河", "area": ["爱辉区", "北安市", "五大连池市", "逊克县", "嫩江县", "孙吴县", "其他"] &#125;, &#123; "name": "绥化", "area": ["北林区", "安达市", "肇东市", "海伦市", "绥棱县", "兰西县", "明水县", "青冈县", "庆安县", "望奎县", "其他"] &#125;, &#123; "name": "大兴安岭地区", "area": ["呼玛县", "塔河县", "漠河县", "大兴安岭辖区", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "上海", "city": [ &#123; "name": "上海", "area": ["黄浦区", "卢湾区", "徐汇区", "长宁区", "静安区", "普陀区", "闸北区", "虹口区", "杨浦区", "宝山区", "闵行区", "嘉定区", "松江区", "金山区", "青浦区", "南汇区", "奉贤区", "浦东新区", "崇明县", "其他"] &#125; ] &#125;, &#123; "name": "江苏", "city": [ &#123; "name": "南京", "area": ["玄武区", "白下区", "秦淮区", "建邺区", "鼓楼区", "下关区", "栖霞区", "雨花台区", "浦口区", "江宁区", "六合区", "溧水县", "高淳县", "其他"] &#125;, &#123; "name": "苏州", "area": ["金阊区", "平江区", "沧浪区", "虎丘区", "吴中区", "相城区", "常熟市", "张家港市", "昆山市", "吴江市", "太仓市", "其他"] &#125;, &#123; "name": "无锡", "area": ["崇安区", "南长区", "北塘区", "滨湖区", "锡山区", "惠山区", "江阴市", "宜兴市", "其他"] &#125;, &#123; "name": "常州", "area": ["钟楼区", "天宁区", "戚墅堰区", "新北区", "武进区", "金坛市", "溧阳市", "其他"] &#125;, &#123; "name": "镇江", "area": ["京口区", "润州区", "丹徒区", "丹阳市", "扬中市", "句容市", "其他"] &#125;, &#123; "name": "南通", "area": ["崇川区", "港闸区", "通州市", "如皋市", "海门市", "启东市", "海安县", "如东县", "其他"] &#125;, &#123; "name": "泰州", "area": ["海陵区", "高港区", "姜堰市", "泰兴市", "靖江市", "兴化市", "其他"] &#125;, &#123; "name": "扬州", "area": ["广陵区", "维扬区", "邗江区", "江都市", "仪征市", "高邮市", "宝应县", "其他"] &#125;, &#123; "name": "盐城", "area": ["亭湖区", "盐都区", "大丰市", "东台市", "建湖县", "射阳县", "阜宁县", "滨海县", "响水县", "其他"] &#125;, &#123; "name": "连云港", "area": ["新浦区", "海州区", "连云区", "东海县", "灌云县", "赣榆县", "灌南县", "其他"] &#125;, &#123; "name": "徐州", "area": ["云龙区", "鼓楼区", "九里区", "泉山区", "贾汪区", "邳州市", "新沂市", "铜山县", "睢宁县", "沛县", "丰县", "其他"] &#125;, &#123; "name": "淮安", "area": ["清河区", "清浦区", "楚州区", "淮阴区", "涟水县", "洪泽县", "金湖县", "盱眙县", "其他"] &#125;, &#123; "name": "宿迁", "area": ["宿城区", "宿豫区", "沭阳县", "泗阳县", "泗洪县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "浙江", "city": [ &#123; "name": "杭州", "area": ["拱墅区", "西湖区", "上城区", "下城区", "江干区", "滨江区", "余杭区", "萧山区", "建德市", "富阳市", "临安市", "桐庐县", "淳安县", "其他"] &#125;, &#123; "name": "宁波", "area": ["海曙区", "江东区", "江北区", "镇海区", "北仑区", "鄞州区", "余姚市", "慈溪市", "奉化市", "宁海县", "象山县", "其他"] &#125;, &#123; "name": "温州", "area": ["鹿城区", "龙湾区", "瓯海区", "瑞安市", "乐清市", "永嘉县", "洞头县", "平阳县", "苍南县", "文成县", "泰顺县", "其他"] &#125;, &#123; "name": "嘉兴", "area": ["秀城区", "秀洲区", "海宁市", "平湖市", "桐乡市", "嘉善县", "海盐县", "其他"] &#125;, &#123; "name": "湖州", "area": ["吴兴区", "南浔区", "长兴县", "德清县", "安吉县", "其他"] &#125;, &#123; "name": "绍兴", "area": ["越城区", "诸暨市", "上虞市", "嵊州市", "绍兴县", "新昌县", "其他"] &#125;, &#123; "name": "金华", "area": ["婺城区", "金东区", "兰溪市", "义乌市", "东阳市", "永康市", "武义县", "浦江县", "磐安县", "其他"] &#125;, &#123; "name": "衢州", "area": ["柯城区", "衢江区", "江山市", "龙游县", "常山县", "开化县", "其他"] &#125;, &#123; "name": "舟山", "area": ["定海区", "普陀区", "岱山县", "嵊泗县", "其他"] &#125;, &#123; "name": "台州", "area": ["椒江区", "黄岩区", "路桥区", "临海市", "温岭市", "玉环县", "天台县", "仙居县", "三门县", "其他"] &#125;, &#123; "name": "丽水", "area": ["莲都区", "龙泉市", "缙云县", "青田县", "云和县", "遂昌县", "松阳县", "庆元县", "景宁畲族自治县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "安徽", "city": [ &#123; "name": "合肥", "area": ["庐阳区", "瑶海区", "蜀山区", "包河区", "长丰县", "肥东县", "肥西县", "其他"] &#125;, &#123; "name": "芜湖", "area": ["镜湖区", "弋江区", "鸠江区", "三山区", "芜湖县", "南陵县", "繁昌县", "其他"] &#125;, &#123; "name": "蚌埠", "area": ["蚌山区", "龙子湖区", "禹会区", "淮上区", "怀远县", "固镇县", "五河县", "其他"] &#125;, &#123; "name": "淮南", "area": ["田家庵区", "大通区", "谢家集区", "八公山区", "潘集区", "凤台县", "其他"] &#125;, &#123; "name": "马鞍山", "area": ["雨山区", "花山区", "金家庄区", "当涂县", "其他"] &#125;, &#123; "name": "淮北", "area": ["相山区", "杜集区", "烈山区", "濉溪县", "其他"] &#125;, &#123; "name": "铜陵", "area": ["铜官山区", "狮子山区", "郊区", "铜陵县", "其他"] &#125;, &#123; "name": "安庆", "area": ["迎江区", "大观区", "宜秀区", "桐城市", "宿松县", "枞阳县", "太湖县", "怀宁县", "岳西县", "望江县", "潜山县", "其他"] &#125;, &#123; "name": "黄山", "area": ["屯溪区", "黄山区", "徽州区", "休宁县", "歙县", "祁门县", "黟县", "其他"] &#125;, &#123; "name": "滁州", "area": ["琅琊区", "南谯区", "天长市", "明光市", "全椒县", "来安县", "定远县", "凤阳县", "其他"] &#125;, &#123; "name": "阜阳", "area": ["颍州区", "颍东区", "颍泉区", "界首市", "临泉县", "颍上县", "阜南县", "太和县", "其他"] &#125;, &#123; "name": "宿州", "area": ["埇桥区", "萧县", "泗县", "砀山县", "灵璧县", "其他"] &#125;, &#123; "name": "巢湖", "area": ["居巢区", "含山县", "无为县", "庐江县", "和县", "其他"] &#125;, &#123; "name": "六安", "area": ["金安区", "裕安区", "寿县", "霍山县", "霍邱县", "舒城县", "金寨县", "其他"] &#125;, &#123; "name": "亳州", "area": ["谯城区", "利辛县", "涡阳县", "蒙城县", "其他"] &#125;, &#123; "name": "池州", "area": ["贵池区", "东至县", "石台县", "青阳县", "其他"] &#125;, &#123; "name": "宣城", "area": ["宣州区", "宁国市", "广德县", "郎溪县", "泾县", "旌德县", "绩溪县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "福建", "city": [ &#123; "name": "福州", "area": ["鼓楼区", "台江区", "仓山区", "马尾区", "晋安区", "福清市", "长乐市", "闽侯县", "闽清县", "永泰县", "连江县", "罗源县", "平潭县", "其他"] &#125;, &#123; "name": "厦门", "area": ["思明区", "海沧区", "湖里区", "集美区", "同安区", "翔安区", "其他"] &#125;, &#123; "name": "莆田", "area": ["城厢区", "涵江区", "荔城区", "秀屿区", "仙游县", "其他"] &#125;, &#123; "name": "三明", "area": ["梅列区", "三元区", "永安市", "明溪县", "将乐县", "大田县", "宁化县", "建宁县", "沙县", "尤溪县", "清流县", "泰宁县", "其他"] &#125;, &#123; "name": "泉州", "area": ["鲤城区", "丰泽区", "洛江区", "泉港区", "石狮市", "晋江市", "南安市", "惠安县", "永春县", "安溪县", "德化县", "金门县", "其他"] &#125;, &#123; "name": "漳州", "area": ["芗城区", "龙文区", "龙海市", "平和县", "南靖县", "诏安县", "漳浦县", "华安县", "东山县", "长泰县", "云霄县", "其他"] &#125;, &#123; "name": "南平", "area": ["延平区", "建瓯市", "邵武市", "武夷山市", "建阳市", "松溪县", "光泽县", "顺昌县", "浦城县", "政和县", "其他"] &#125;, &#123; "name": "龙岩", "area": ["新罗区", "漳平市", "长汀县", "武平县", "上杭县", "永定县", "连城县", "其他"] &#125;, &#123; "name": "宁德", "area": ["蕉城区", "福安市", "福鼎市", "寿宁县", "霞浦县", "柘荣县", "屏南县", "古田县", "周宁县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "江西", "city": [ &#123; "name": "南昌", "area": ["东湖区", "西湖区", "青云谱区", "湾里区", "青山湖区", "新建县", "南昌县", "进贤县", "安义县", "其他"] &#125;, &#123; "name": "景德镇", "area": ["珠山区", "昌江区", "乐平市", "浮梁县", "其他"] &#125;, &#123; "name": "萍乡", "area": ["安源区", "湘东区", "莲花县", "上栗县", "芦溪县", "其他"] &#125;, &#123; "name": "九江", "area": ["浔阳区", "庐山区", "瑞昌市", "九江县", "星子县", "武宁县", "彭泽县", "永修县", "修水县", "湖口县", "德安县", "都昌县", "其他"] &#125;, &#123; "name": "新余", "area": ["渝水区", "分宜县", "其他"] &#125;, &#123; "name": "鹰潭", "area": ["月湖区", "贵溪市", "余江县", "其他"] &#125;, &#123; "name": "赣州", "area": ["章贡区", "瑞金市", "南康市", "石城县", "安远县", "赣县", "宁都县", "寻乌县", "兴国县", "定南县", "上犹县", "于都县", "龙南县", "崇义县", "信丰县", "全南县", "大余县", "会昌县", "其他"] &#125;, &#123; "name": "吉安", "area": ["吉州区", "青原区", "井冈山市", "吉安县", "永丰县", "永新县", "新干县", "泰和县", "峡江县", "遂川县", "安福县", "吉水县", "万安县", "其他"] &#125;, &#123; "name": "宜春", "area": ["袁州区", "丰城市", "樟树市", "高安市", "铜鼓县", "靖安县", "宜丰县", "奉新县", "万载县", "上高县", "其他"] &#125;, &#123; "name": "抚州", "area": ["临川区", "南丰县", "乐安县", "金溪县", "南城县", "东乡县", "资溪县", "宜黄县", "广昌县", "黎川县", "崇仁县", "其他"] &#125;, &#123; "name": "上饶", "area": ["信州区", "德兴市", "上饶县", "广丰县", "鄱阳县", "婺源县", "铅山县", "余干县", "横峰县", "弋阳县", "玉山县", "万年县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "山东", "city": [ &#123; "name": "济南", "area": ["市中区", "历下区", "天桥区", "槐荫区", "历城区", "长清区", "章丘市", "平阴县", "济阳县", "商河县", "其他"] &#125;, &#123; "name": "青岛", "area": ["市南区", "市北区", "城阳区", "四方区", "李沧区", "黄岛区", "崂山区", "胶南市", "胶州市", "平度市", "莱西市", "即墨市", "其他"] &#125;, &#123; "name": "淄博", "area": ["张店区", "临淄区", "淄川区", "博山区", "周村区", "桓台县", "高青县", "沂源县", "其他"] &#125;, &#123; "name": "枣庄", "area": ["市中区", "山亭区", "峄城区", "台儿庄区", "薛城区", "滕州市", "其他"] &#125;, &#123; "name": "东营", "area": ["东营区", "河口区", "垦利县", "广饶县", "利津县", "其他"] &#125;, &#123; "name": "烟台", "area": ["芝罘区", "福山区", "牟平区", "莱山区", "龙口市", "莱阳市", "莱州市", "招远市", "蓬莱市", "栖霞市", "海阳市", "长岛县", "其他"] &#125;, &#123; "name": "潍坊", "area": ["潍城区", "寒亭区", "坊子区", "奎文区", "青州市", "诸城市", "寿光市", "安丘市", "高密市", "昌邑市", "昌乐县", "临朐县", "其他"] &#125;, &#123; "name": "济宁", "area": ["市中区", "任城区", "曲阜市", "兖州市", "邹城市", "鱼台县", "金乡县", "嘉祥县", "微山县", "汶上县", "泗水县", "梁山县", "其他"] &#125;, &#123; "name": "泰安", "area": ["泰山区", "岱岳区", "新泰市", "肥城市", "宁阳县", "东平县", "其他"] &#125;, &#123; "name": "威海", "area": ["环翠区", "乳山市", "文登市", "荣成市", "其他"] &#125;, &#123; "name": "日照", "area": ["东港区", "岚山区", "五莲县", "莒县", "其他"] &#125;, &#123; "name": "莱芜", "area": ["莱城区", "钢城区", "其他"] &#125;, &#123; "name": "临沂", "area": ["兰山区", "罗庄区", "河东区", "沂南县", "郯城县", "沂水县", "苍山县", "费县", "平邑县", "莒南县", "蒙阴县", "临沭县", "其他"] &#125;, &#123; "name": "德州", "area": ["德城区", "乐陵市", "禹城市", "陵县", "宁津县", "齐河县", "武城县", "庆云县", "平原县", "夏津县", "临邑县", "其他"] &#125;, &#123; "name": "聊城", "area": ["东昌府区", "临清市", "高唐县", "阳谷县", "茌平县", "莘县", "东阿县", "冠县", "其他"] &#125;, &#123; "name": "滨州", "area": ["滨城区", "邹平县", "沾化县", "惠民县", "博兴县", "阳信县", "无棣县", "其他"] &#125;, &#123; "name": "菏泽", "area": ["牡丹区", "鄄城县", "单县", "郓城县", "曹县", "定陶县", "巨野县", "东明县", "成武县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "河南", "city": [ &#123; "name": "郑州", "area": ["中原区", "金水区", "二七区", "管城回族区", "上街区", "惠济区", "巩义市", "新郑市", "新密市", "登封市", "荥阳市", "中牟县", "其他"] &#125;, &#123; "name": "开封", "area": ["鼓楼区", "龙亭区", "顺河回族区", "禹王台区", "金明区", "开封县", "尉氏县", "兰考县", "杞县", "通许县", "其他"] &#125;, &#123; "name": "洛阳", "area": ["西工区", "老城区", "涧西区", "瀍河回族区", "洛龙区", "吉利区", "偃师市", "孟津县", "汝阳县", "伊川县", "洛宁县", "嵩县", "宜阳县", "新安县", "栾川县", "其他"] &#125;, &#123; "name": "平顶山", "area": ["新华区", "卫东区", "湛河区", "石龙区", "汝州市", "舞钢市", "宝丰县", "叶县", "郏县", "鲁山县", "其他"] &#125;, &#123; "name": "安阳", "area": ["北关区", "文峰区", "殷都区", "龙安区", "林州市", "安阳县", "滑县", "内黄县", "汤阴县", "其他"] &#125;, &#123; "name": "鹤壁", "area": ["淇滨区", "山城区", "鹤山区", "浚县", "淇县", "其他"] &#125;, &#123; "name": "新乡", "area": ["卫滨区", "红旗区", "凤泉区", "牧野区", "卫辉市", "辉县市", "新乡县", "获嘉县", "原阳县", "长垣县", "封丘县", "延津县", "其他"] &#125;, &#123; "name": "焦作", "area": ["解放区", "中站区", "马村区", "山阳区", "沁阳市", "孟州市", "修武县", "温县", "武陟县", "博爱县", "其他"] &#125;, &#123; "name": "濮阳", "area": ["华龙区", "濮阳县", "南乐县", "台前县", "清丰县", "范县", "其他"] &#125;, &#123; "name": "许昌", "area": ["魏都区", "禹州市", "长葛市", "许昌县", "鄢陵县", "襄城县", "其他"] &#125;, &#123; "name": "漯河", "area": ["源汇区", "郾城区", "召陵区", "临颍县", "舞阳县", "其他"] &#125;, &#123; "name": "三门峡", "area": ["湖滨区", "义马市", "灵宝市", "渑池县", "卢氏县", "陕县", "其他"] &#125;, &#123; "name": "南阳", "area": ["卧龙区", "宛城区", "邓州市", "桐柏县", "方城县", "淅川县", "镇平县", "唐河县", "南召县", "内乡县", "新野县", "社旗县", "西峡县", "其他"] &#125;, &#123; "name": "商丘", "area": ["梁园区", "睢阳区", "永城市", "宁陵县", "虞城县", "民权县", "夏邑县", "柘城县", "睢县", "其他"] &#125;, &#123; "name": "信阳", "area": ["浉河区", "平桥区", "潢川县", "淮滨县", "息县", "新县", "商城县", "固始县", "罗山县", "光山县", "其他"] &#125;, &#123; "name": "周口", "area": ["川汇区", "项城市", "商水县", "淮阳县", "太康县", "鹿邑县", "西华县", "扶沟县", "沈丘县", "郸城县", "其他"] &#125;, &#123; "name": "驻马店", "area": ["驿城区", "确山县", "新蔡县", "上蔡县", "西平县", "泌阳县", "平舆县", "汝南县", "遂平县", "正阳县", "其他"] &#125;, &#123; "name": "焦作", "area": ["济源市", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "湖北", "city": [ &#123; "name": "武汉", "area": ["江岸区", "武昌区", "江汉区", "硚口区", "汉阳区", "青山区", "洪山区", "东西湖区", "汉南区", "蔡甸区", "江夏区", "黄陂区", "新洲区", "其他"] &#125;, &#123; "name": "黄石", "area": ["黄石港区", "西塞山区", "下陆区", "铁山区", "大冶市", "阳新县", "其他"] &#125;, &#123; "name": "十堰", "area": ["张湾区", "茅箭区", "丹江口市", "郧县", "竹山县", "房县", "郧西县", "竹溪县", "其他"] &#125;, &#123; "name": "荆州", "area": ["沙市区", "荆州区", "洪湖市", "石首市", "松滋市", "监利县", "公安县", "江陵县", "其他"] &#125;, &#123; "name": "宜昌", "area": ["西陵区", "伍家岗区", "点军区", "猇亭区", "夷陵区", "宜都市", "当阳市", "枝江市", "秭归县", "远安县", "兴山县", "五峰土家族自治县", "长阳土家族自治县", "其他"] &#125;, &#123; "name": "襄樊", "area": ["襄城区", "樊城区", "襄阳区", "老河口市", "枣阳市", "宜城市", "南漳县", "谷城县", "保康县", "其他"] &#125;, &#123; "name": "鄂州", "area": ["鄂城区", "华容区", "梁子湖区", "其他"] &#125;, &#123; "name": "荆门", "area": ["东宝区", "掇刀区", "钟祥市", "京山县", "沙洋县", "其他"] &#125;, &#123; "name": "孝感", "area": ["孝南区", "应城市", "安陆市", "汉川市", "云梦县", "大悟县", "孝昌县", "其他"] &#125;, &#123; "name": "黄冈", "area": ["黄州区", "麻城市", "武穴市", "红安县", "罗田县", "浠水县", "蕲春县", "黄梅县", "英山县", "团风县", "其他"] &#125;, &#123; "name": "咸宁", "area": ["咸安区", "赤壁市", "嘉鱼县", "通山县", "崇阳县", "通城县", "其他"] &#125;, &#123; "name": "随州", "area": ["曾都区", "广水市", "其他"] &#125;, &#123; "name": "恩施土家族苗族自治州", "area": ["恩施市", "利川市", "建始县", "来凤县", "巴东县", "鹤峰县", "宣恩县", "咸丰县", "其他"] &#125;, &#123; "name": "仙桃", "area": ["仙桃"] &#125;, &#123; "name": "天门", "area": ["天门"] &#125;, &#123; "name": "潜江", "area": ["潜江"] &#125;, &#123; "name": "神农架林区", "area": ["神农架林区"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "湖南", "city": [ &#123; "name": "长沙", "area": ["岳麓区", "芙蓉区", "天心区", "开福区", "雨花区", "浏阳市", "长沙县", "望城县", "宁乡县", "其他"] &#125;, &#123; "name": "株洲", "area": ["天元区", "荷塘区", "芦淞区", "石峰区", "醴陵市", "株洲县", "炎陵县", "茶陵县", "攸县", "其他"] &#125;, &#123; "name": "湘潭", "area": ["岳塘区", "雨湖区", "湘乡市", "韶山市", "湘潭县", "其他"] &#125;, &#123; "name": "衡阳", "area": ["雁峰区", "珠晖区", "石鼓区", "蒸湘区", "南岳区", "耒阳市", "常宁市", "衡阳县", "衡东县", "衡山县", "衡南县", "祁东县", "其他"] &#125;, &#123; "name": "邵阳", "area": ["双清区", "大祥区", "北塔区", "武冈市", "邵东县", "洞口县", "新邵县", "绥宁县", "新宁县", "邵阳县", "隆回县", "城步苗族自治县", "其他"] &#125;, &#123; "name": "岳阳", "area": ["岳阳楼区", "云溪区", "君山区", "临湘市", "汨罗市", "岳阳县", "湘阴县", "平江县", "华容县", "其他"] &#125;, &#123; "name": "常德", "area": ["武陵区", "鼎城区", "津市市", "澧县", "临澧县", "桃源县", "汉寿县", "安乡县", "石门县", "其他"] &#125;, &#123; "name": "张家界", "area": ["永定区", "武陵源区", "慈利县", "桑植县", "其他"] &#125;, &#123; "name": "益阳", "area": ["赫山区", "资阳区", "沅江市", "桃江县", "南县", "安化县", "其他"] &#125;, &#123; "name": "郴州", "area": ["北湖区", "苏仙区", "资兴市", "宜章县", "汝城县", "安仁县", "嘉禾县", "临武县", "桂东县", "永兴县", "桂阳县", "其他"] &#125;, &#123; "name": "永州", "area": ["冷水滩区", "零陵区", "祁阳县", "蓝山县", "宁远县", "新田县", "东安县", "江永县", "道县", "双牌县", "江华瑶族自治县", "其他"] &#125;, &#123; "name": "怀化", "area": ["鹤城区", "洪江市", "会同县", "沅陵县", "辰溪县", "溆浦县", "中方县", "新晃侗族自治县", "芷江侗族自治县", "通道侗族自治县", "靖州苗族侗族自治县", "麻阳苗族自治县", "其他"] &#125;, &#123; "name": "娄底", "area": ["娄星区", "冷水江市", "涟源市", "新化县", "双峰县", "其他"] &#125;, &#123; "name": "湘西土家族苗族自治州", "area": ["吉首市", "古丈县", "龙山县", "永顺县", "凤凰县", "泸溪县", "保靖县", "花垣县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "广东", "city": [ &#123; "name": "广州", "area": ["越秀区", "荔湾区", "海珠区", "天河区", "白云区", "黄埔区", "番禺区", "花都区", "南沙区", "萝岗区", "增城市", "从化市", "其他"] &#125;, &#123; "name": "深圳", "area": ["福田区", "罗湖区", "南山区", "宝安区", "龙岗区", "盐田区", "其他"] &#125;, &#123; "name": "东莞", "area": ["莞城", "常平", "塘厦", "塘厦", "塘厦", "其他"] &#125;, &#123; "name": "中山", "area": ["中山"] &#125;, &#123; "name": "潮州", "area": ["湘桥区", "潮安县", "饶平县", "其他"] &#125;, &#123; "name": "揭阳", "area": ["榕城区", "揭东县", "揭西县", "惠来县", "普宁市", "其他"] &#125;, &#123; "name": "云浮", "area": ["云城区", "新兴县", "郁南县", "云安县", "罗定市", "其他"] &#125;, &#123; "name": "珠海", "area": ["香洲区", "斗门区", "金湾区", "其他"] &#125;, &#123; "name": "汕头", "area": ["金平区", "濠江区", "龙湖区", "潮阳区", "潮南区", "澄海区", "南澳县", "其他"] &#125;, &#123; "name": "韶关", "area": ["浈江区", "武江区", "曲江区", "乐昌市", "南雄市", "始兴县", "仁化县", "翁源县", "新丰县", "乳源瑶族自治县", "其他"] &#125;, &#123; "name": "佛山", "area": ["禅城区", "南海区", "顺德区", "三水区", "高明区", "其他"] &#125;, &#123; "name": "江门", "area": ["蓬江区", "江海区", "新会区", "恩平市", "台山市", "开平市", "鹤山市", "其他"] &#125;, &#123; "name": "湛江", "area": ["赤坎区", "霞山区", "坡头区", "麻章区", "吴川市", "廉江市", "雷州市", "遂溪县", "徐闻县", "其他"] &#125;, &#123; "name": "茂名", "area": ["茂南区", "茂港区", "化州市", "信宜市", "高州市", "电白县", "其他"] &#125;, &#123; "name": "肇庆", "area": ["端州区", "鼎湖区", "高要市", "四会市", "广宁县", "怀集县", "封开县", "德庆县", "其他"] &#125;, &#123; "name": "惠州", "area": ["惠城区", "惠阳区", "博罗县", "惠东县", "龙门县", "其他"] &#125;, &#123; "name": "梅州", "area": ["梅江区", "兴宁市", "梅县", "大埔县", "丰顺县", "五华县", "平远县", "蕉岭县", "其他"] &#125;, &#123; "name": "汕尾", "area": ["城区", "陆丰市", "海丰县", "陆河县", "其他"] &#125;, &#123; "name": "河源", "area": ["源城区", "紫金县", "龙川县", "连平县", "和平县", "东源县", "其他"] &#125;, &#123; "name": "阳江", "area": ["江城区", "阳春市", "阳西县", "阳东县", "其他"] &#125;, &#123; "name": "清远", "area": ["清城区", "英德市", "连州市", "佛冈县", "阳山县", "清新县", "连山壮族瑶族自治县", "连南瑶族自治县", "其他"] &#125; ] &#125;, &#123; "name": "广西", "city": [ &#123; "name": "南宁", "area": ["青秀区", "兴宁区", "西乡塘区", "良庆区", "江南区", "邕宁区", "武鸣县", "隆安县", "马山县", "上林县", "宾阳县", "横县", "其他"] &#125;, &#123; "name": "柳州", "area": ["城中区", "鱼峰区", "柳北区", "柳南区", "柳江县", "柳城县", "鹿寨县", "融安县", "融水苗族自治县", "三江侗族自治县", "其他"] &#125;, &#123; "name": "桂林", "area": ["象山区", "秀峰区", "叠彩区", "七星区", "雁山区", "阳朔县", "临桂县", "灵川县", "全州县", "平乐县", "兴安县", "灌阳县", "荔浦县", "资源县", "永福县", "龙胜各族自治县", "恭城瑶族自治县", "其他"] &#125;, &#123; "name": "梧州", "area": ["万秀区", "蝶山区", "长洲区", "岑溪市", "苍梧县", "藤县", "蒙山县", "其他"] &#125;, &#123; "name": "北海", "area": ["海城区", "银海区", "铁山港区", "合浦县", "其他"] &#125;, &#123; "name": "防城港", "area": ["港口区", "防城区", "东兴市", "上思县", "其他"] &#125;, &#123; "name": "钦州", "area": ["钦南区", "钦北区", "灵山县", "浦北县", "其他"] &#125;, &#123; "name": "贵港", "area": ["港北区", "港南区", "覃塘区", "桂平市", "平南县", "其他"] &#125;, &#123; "name": "玉林", "area": ["玉州区", "北流市", "容县", "陆川县", "博白县", "兴业县", "其他"] &#125;, &#123; "name": "百色", "area": ["右江区", "凌云县", "平果县", "西林县", "乐业县", "德保县", "田林县", "田阳县", "靖西县", "田东县", "那坡县", "隆林各族自治县", "其他"] &#125;, &#123; "name": "贺州", "area": ["八步区", "钟山县", "昭平县", "富川瑶族自治县", "其他"] &#125;, &#123; "name": "河池", "area": ["金城江区", "宜州市", "天峨县", "凤山县", "南丹县", "东兰县", "都安瑶族自治县", "罗城仫佬族自治县", "巴马瑶族自治县", "环江毛南族自治县", "大化瑶族自治县", "其他"] &#125;, &#123; "name": "来宾", "area": ["兴宾区", "合山市", "象州县", "武宣县", "忻城县", "金秀瑶族自治县", "其他"] &#125;, &#123; "name": "崇左", "area": ["江州区", "凭祥市", "宁明县", "扶绥县", "龙州县", "大新县", "天等县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "海南", "city": [ &#123; "name": "海口", "area": ["龙华区", "秀英区", "琼山区", "美兰区", "其他"] &#125;, &#123; "name": "三亚", "area": ["三亚市", "其他"] &#125;, &#123; "name": "五指山", "area": ["五指山"] &#125;, &#123; "name": "琼海", "area": ["琼海"] &#125;, &#123; "name": "儋州", "area": ["儋州"] &#125;, &#123; "name": "文昌", "area": ["文昌"] &#125;, &#123; "name": "万宁", "area": ["万宁"] &#125;, &#123; "name": "东方", "area": ["东方"] &#125;, &#123; "name": "澄迈县", "area": ["澄迈县"] &#125;, &#123; "name": "定安县", "area": ["定安县"] &#125;, &#123; "name": "屯昌县", "area": ["屯昌县"] &#125;, &#123; "name": "临高县", "area": ["临高县"] &#125;, &#123; "name": "白沙黎族自治县", "area": ["白沙黎族自治县"] &#125;, &#123; "name": "昌江黎族自治县", "area": ["昌江黎族自治县"] &#125;, &#123; "name": "乐东黎族自治县", "area": ["乐东黎族自治县"] &#125;, &#123; "name": "陵水黎族自治县", "area": ["陵水黎族自治县"] &#125;, &#123; "name": "保亭黎族苗族自治县", "area": ["保亭黎族苗族自治县"] &#125;, &#123; "name": "琼中黎族苗族自治县", "area": ["琼中黎族苗族自治县"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "重庆", "city": [ &#123; "name": "重庆", "area": ["渝中区", "大渡口区", "江北区", "南岸区", "北碚区", "渝北区", "巴南区", "长寿区", "双桥区", "沙坪坝区", "万盛区", "万州区", "涪陵区", "黔江区", "永川区", "合川区", "江津区", "九龙坡区", "南川区", "綦江县", "潼南县", "荣昌县", "璧山县", "大足县", "铜梁县", "梁平县", "开县", "忠县", "城口县", "垫江县", "武隆县", "丰都县", "奉节县", "云阳县", "巫溪县", "巫山县", "石柱土家族自治县", "秀山土家族苗族自治县", "酉阳土家族苗族自治县", "彭水苗族土家族自治县", "其他"] &#125; ] &#125;, &#123; "name": "四川", "city": [ &#123; "name": "成都", "area": ["青羊区", "锦江区", "金牛区", "武侯区", "成华区", "龙泉驿区", "青白江区", "新都区", "温江区", "都江堰市", "彭州市", "邛崃市", "崇州市", "金堂县", "郫县", "新津县", "双流县", "蒲江县", "大邑县", "其他"] &#125;, &#123; "name": "自贡", "area": ["大安区", "自流井区", "贡井区", "沿滩区", "荣县", "富顺县", "其他"] &#125;, &#123; "name": "攀枝花", "area": ["仁和区", "米易县", "盐边县", "东区", "西区", "其他"] &#125;, &#123; "name": "泸州", "area": ["江阳区", "纳溪区", "龙马潭区", "泸县", "合江县", "叙永县", "古蔺县", "其他"] &#125;, &#123; "name": "德阳", "area": ["旌阳区", "广汉市", "什邡市", "绵竹市", "罗江县", "中江县", "其他"] &#125;, &#123; "name": "绵阳", "area": ["涪城区", "游仙区", "江油市", "盐亭县", "三台县", "平武县", "安县", "梓潼县", "北川羌族自治县", "其他"] &#125;, &#123; "name": "广元", "area": ["元坝区", "朝天区", "青川县", "旺苍县", "剑阁县", "苍溪县", "市中区", "其他"] &#125;, &#123; "name": "遂宁", "area": ["船山区", "安居区", "射洪县", "蓬溪县", "大英县", "其他"] &#125;, &#123; "name": "内江", "area": ["市中区", "东兴区", "资中县", "隆昌县", "威远县", "其他"] &#125;, &#123; "name": "乐山", "area": ["市中区", "五通桥区", "沙湾区", "金口河区", "峨眉山市", "夹江县", "井研县", "犍为县", "沐川县", "马边彝族自治县", "峨边彝族自治县", "其他"] &#125;, &#123; "name": "南充", "area": ["顺庆区", "高坪区", "嘉陵区", "阆中市", "营山县", "蓬安县", "仪陇县", "南部县", "西充县", "其他"] &#125;, &#123; "name": "眉山", "area": ["东坡区", "仁寿县", "彭山县", "洪雅县", "丹棱县", "青神县", "其他"] &#125;, &#123; "name": "宜宾", "area": ["翠屏区", "宜宾县", "兴文县", "南溪县", "珙县", "长宁县", "高县", "江安县", "筠连县", "屏山县", "其他"] &#125;, &#123; "name": "广安", "area": ["广安区", "华蓥市", "岳池县", "邻水县", "武胜县", "其他"] &#125;, &#123; "name": "达州", "area": ["通川区", "万源市", "达县", "渠县", "宣汉县", "开江县", "大竹县", "其他"] &#125;, &#123; "name": "雅安", "area": ["雨城区", "芦山县", "石棉县", "名山县", "天全县", "荥经县", "宝兴县", "汉源县", "其他"] &#125;, &#123; "name": "巴中", "area": ["巴州区", "南江县", "平昌县", "通江县", "其他"] &#125;, &#123; "name": "资阳", "area": ["雁江区", "简阳市", "安岳县", "乐至县", "其他"] &#125;, &#123; "name": "阿坝藏族羌族自治州", "area": ["马尔康县", "九寨沟县", "红原县", "汶川县", "阿坝县", "理县", "若尔盖县", "小金县", "黑水县", "金川县", "松潘县", "壤塘县", "茂县", "其他"] &#125;, &#123; "name": "甘孜藏族自治州", "area": ["康定县", "丹巴县", "炉霍县", "九龙县", "甘孜县", "雅江县", "新龙县", "道孚县", "白玉县", "理塘县", "德格县", "乡城县", "石渠县", "稻城县", "色达县", "巴塘县", "泸定县", "得荣县", "其他"] &#125;, &#123; "name": "凉山彝族自治州", "area": ["西昌市", "美姑县", "昭觉县", "金阳县", "甘洛县", "布拖县", "雷波县", "普格县", "宁南县", "喜德县", "会东县", "越西县", "会理县", "盐源县", "德昌县", "冕宁县", "木里藏族自治县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "贵州", "city": [ &#123; "name": "贵阳", "area": ["南明区", "云岩区", "花溪区", "乌当区", "白云区", "小河区", "清镇市", "开阳县", "修文县", "息烽县", "其他"] &#125;, &#123; "name": "六盘水", "area": ["钟山区", "水城县", "盘县", "六枝特区", "其他"] &#125;, &#123; "name": "遵义", "area": ["红花岗区", "汇川区", "赤水市", "仁怀市", "遵义县", "绥阳县", "桐梓县", "习水县", "凤冈县", "正安县", "余庆县", "湄潭县", "道真仡佬族苗族自治县", "务川仡佬族苗族自治县", "其他"] &#125;, &#123; "name": "安顺", "area": ["西秀区", "普定县", "平坝县", "镇宁布依族苗族自治县", "紫云苗族布依族自治县", "关岭布依族苗族自治县", "其他"] &#125;, &#123; "name": "铜仁地区", "area": ["铜仁市", "德江县", "江口县", "思南县", "石阡县", "玉屏侗族自治县", "松桃苗族自治县", "印江土家族苗族自治县", "沿河土家族自治县", "万山特区", "其他"] &#125;, &#123; "name": "毕节地区", "area": ["毕节市", "黔西县", "大方县", "织金县", "金沙县", "赫章县", "纳雍县", "威宁彝族回族苗族自治县", "其他"] &#125;, &#123; "name": "黔西南布依族苗族自治州", "area": ["兴义市", "望谟县", "兴仁县", "普安县", "册亨县", "晴隆县", "贞丰县", "安龙县", "其他"] &#125;, &#123; "name": "黔东南苗族侗族自治州", "area": ["凯里市", "施秉县", "从江县", "锦屏县", "镇远县", "麻江县", "台江县", "天柱县", "黄平县", "榕江县", "剑河县", "三穗县", "雷山县", "黎平县", "岑巩县", "丹寨县", "其他"] &#125;, &#123; "name": "黔南布依族苗族自治州", "area": ["都匀市", "福泉市", "贵定县", "惠水县", "罗甸县", "瓮安县", "荔波县", "龙里县", "平塘县", "长顺县", "独山县", "三都水族自治县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "云南", "city": [ &#123; "name": "昆明", "area": ["盘龙区", "五华区", "官渡区", "西山区", "东川区", "安宁市", "呈贡县", "晋宁县", "富民县", "宜良县", "嵩明县", "石林彝族自治县", "禄劝彝族苗族自治县", "寻甸回族彝族自治县", "其他"] &#125;, &#123; "name": "曲靖", "area": ["麒麟区", "宣威市", "马龙县", "沾益县", "富源县", "罗平县", "师宗县", "陆良县", "会泽县", "其他"] &#125;, &#123; "name": "玉溪", "area": ["红塔区", "江川县", "澄江县", "通海县", "华宁县", "易门县", "峨山彝族自治县", "新平彝族傣族自治县", "元江哈尼族彝族傣族自治县", "其他"] &#125;, &#123; "name": "保山", "area": ["隆阳区", "施甸县", "腾冲县", "龙陵县", "昌宁县", "其他"] &#125;, &#123; "name": "昭通", "area": ["昭阳区", "鲁甸县", "巧家县", "盐津县", "大关县", "永善县", "绥江县", "镇雄县", "彝良县", "威信县", "水富县", "其他"] &#125;, &#123; "name": "丽江", "area": ["古城区", "永胜县", "华坪县", "玉龙纳西族自治县", "宁蒗彝族自治县", "其他"] &#125;, &#123; "name": "普洱", "area": ["思茅区", "普洱哈尼族彝族自治县", "墨江哈尼族自治县", "景东彝族自治县", "景谷傣族彝族自治县", "镇沅彝族哈尼族拉祜族自治县", "江城哈尼族彝族自治县", "孟连傣族拉祜族佤族自治县", "澜沧拉祜族自治县", "西盟佤族自治县", "其他"] &#125;, &#123; "name": "临沧", "area": ["临翔区", "凤庆县", "云县", "永德县", "镇康县", "双江拉祜族佤族布朗族傣族自治县", "耿马傣族佤族自治县", "沧源佤族自治县", "其他"] &#125;, &#123; "name": "德宏傣族景颇族自治州", "area": ["潞西市", "瑞丽市", "梁河县", "盈江县", "陇川县", "其他"] &#125;, &#123; "name": "怒江傈僳族自治州", "area": ["泸水县", "福贡县", "贡山独龙族怒族自治县", "兰坪白族普米族自治县", "其他"] &#125;, &#123; "name": "迪庆藏族自治州", "area": ["香格里拉县", "德钦县", "维西傈僳族自治县", "其他"] &#125;, &#123; "name": "大理白族自治州", "area": ["大理市", "祥云县", "宾川县", "弥渡县", "永平县", "云龙县", "洱源县", "剑川县", "鹤庆县", "漾濞彝族自治县", "南涧彝族自治县", "巍山彝族回族自治县", "其他"] &#125;, &#123; "name": "楚雄彝族自治州", "area": ["楚雄市", "双柏县", "牟定县", "南华县", "姚安县", "大姚县", "永仁县", "元谋县", "武定县", "禄丰县", "其他"] &#125;, &#123; "name": "红河哈尼族彝族自治州", "area": ["蒙自县", "个旧市", "开远市", "绿春县", "建水县", "石屏县", "弥勒县", "泸西县", "元阳县", "红河县", "金平苗族瑶族傣族自治县", "河口瑶族自治县", "屏边苗族自治县", "其他"] &#125;, &#123; "name": "文山壮族苗族自治州", "area": ["文山县", "砚山县", "西畴县", "麻栗坡县", "马关县", "丘北县", "广南县", "富宁县", "其他"] &#125;, &#123; "name": "西双版纳傣族自治州", "area": ["景洪市", "勐海县", "勐腊县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "西藏", "city": [ &#123; "name": "拉萨", "area": ["城关区", "林周县", "当雄县", "尼木县", "曲水县", "堆龙德庆县", "达孜县", "墨竹工卡县", "其他"] &#125;, &#123; "name": "那曲地区", "area": ["那曲县", "嘉黎县", "比如县", "聂荣县", "安多县", "申扎县", "索县", "班戈县", "巴青县", "尼玛县", "其他"] &#125;, &#123; "name": "昌都地区", "area": ["昌都县", "江达县", "贡觉县", "类乌齐县", "丁青县", "察雅县", "八宿县", "左贡县", "芒康县", "洛隆县", "边坝县", "其他"] &#125;, &#123; "name": "林芝地区", "area": ["林芝县", "工布江达县", "米林县", "墨脱县", "波密县", "察隅县", "朗县", "其他"] &#125;, &#123; "name": "山南地区", "area": ["乃东县", "扎囊县", "贡嘎县", "桑日县", "琼结县", "曲松县", "措美县", "洛扎县", "加查县", "隆子县", "错那县", "浪卡子县", "其他"] &#125;, &#123; "name": "日喀则地区", "area": ["日喀则市", "南木林县", "江孜县", "定日县", "萨迦县", "拉孜县", "昂仁县", "谢通门县", "白朗县", "仁布县", "康马县", "定结县", "仲巴县", "亚东县", "吉隆县", "聂拉木县", "萨嘎县", "岗巴县", "其他"] &#125;, &#123; "name": "阿里地区", "area": ["噶尔县", "普兰县", "札达县", "日土县", "革吉县", "改则县", "措勤县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "陕西", "city": [ &#123; "name": "西安", "area": ["莲湖区", "新城区", "碑林区", "雁塔区", "灞桥区", "未央区", "阎良区", "临潼区", "长安区", "高陵县", "蓝田县", "户县", "周至县", "其他"] &#125;, &#123; "name": "铜川", "area": ["耀州区", "王益区", "印台区", "宜君县", "其他"] &#125;, &#123; "name": "宝鸡", "area": ["渭滨区", "金台区", "陈仓区", "岐山县", "凤翔县", "陇县", "太白县", "麟游县", "扶风县", "千阳县", "眉县", "凤县", "其他"] &#125;, &#123; "name": "咸阳", "area": ["秦都区", "渭城区", "杨陵区", "兴平市", "礼泉县", "泾阳县", "永寿县", "三原县", "彬县", "旬邑县", "长武县", "乾县", "武功县", "淳化县", "其他"] &#125;, &#123; "name": "渭南", "area": ["临渭区", "韩城市", "华阴市", "蒲城县", "潼关县", "白水县", "澄城县", "华县", "合阳县", "富平县", "大荔县", "其他"] &#125;, &#123; "name": "延安", "area": ["宝塔区", "安塞县", "洛川县", "子长县", "黄陵县", "延川县", "富县", "延长县", "甘泉县", "宜川县", "志丹县", "黄龙县", "吴起县", "其他"] &#125;, &#123; "name": "汉中", "area": ["汉台区", "留坝县", "镇巴县", "城固县", "南郑县", "洋县", "宁强县", "佛坪县", "勉县", "西乡县", "略阳县", "其他"] &#125;, &#123; "name": "榆林", "area": ["榆阳区", "清涧县", "绥德县", "神木县", "佳县", "府谷县", "子洲县", "靖边县", "横山县", "米脂县", "吴堡县", "定边县", "其他"] &#125;, &#123; "name": "安康", "area": ["汉滨区", "紫阳县", "岚皋县", "旬阳县", "镇坪县", "平利县", "石泉县", "宁陕县", "白河县", "汉阴县", "其他"] &#125;, &#123; "name": "商洛", "area": ["商州区", "镇安县", "山阳县", "洛南县", "商南县", "丹凤县", "柞水县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "甘肃", "city": [ &#123; "name": "兰州", "area": ["城关区", "七里河区", "西固区", "安宁区", "红古区", "永登县", "皋兰县", "榆中县", "其他"] &#125;, &#123; "name": "嘉峪关", "area": ["嘉峪关市", "其他"] &#125;, &#123; "name": "金昌", "area": ["金川区", "永昌县", "其他"] &#125;, &#123; "name": "白银", "area": ["白银区", "平川区", "靖远县", "会宁县", "景泰县", "其他"] &#125;, &#123; "name": "天水", "area": ["清水县", "秦安县", "甘谷县", "武山县", "张家川回族自治县", "北道区", "秦城区", "其他"] &#125;, &#123; "name": "武威", "area": ["凉州区", "民勤县", "古浪县", "天祝藏族自治县", "其他"] &#125;, &#123; "name": "酒泉", "area": ["肃州区", "玉门市", "敦煌市", "金塔县", "肃北蒙古族自治县", "阿克塞哈萨克族自治县", "安西县", "其他"] &#125;, &#123; "name": "张掖", "area": ["甘州区", "民乐县", "临泽县", "高台县", "山丹县", "肃南裕固族自治县", "其他"] &#125;, &#123; "name": "庆阳", "area": ["西峰区", "庆城县", "环县", "华池县", "合水县", "正宁县", "宁县", "镇原县", "其他"] &#125;, &#123; "name": "平凉", "area": ["崆峒区", "泾川县", "灵台县", "崇信县", "华亭县", "庄浪县", "静宁县", "其他"] &#125;, &#123; "name": "定西", "area": ["安定区", "通渭县", "临洮县", "漳县", "岷县", "渭源县", "陇西县", "其他"] &#125;, &#123; "name": "陇南", "area": ["武都区", "成县", "宕昌县", "康县", "文县", "西和县", "礼县", "两当县", "徽县", "其他"] &#125;, &#123; "name": "临夏回族自治州", "area": ["临夏市", "临夏县", "康乐县", "永靖县", "广河县", "和政县", "东乡族自治县", "积石山保安族东乡族撒拉族自治县", "其他"] &#125;, &#123; "name": "甘南藏族自治州", "area": ["合作市", "临潭县", "卓尼县", "舟曲县", "迭部县", "玛曲县", "碌曲县", "夏河县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "青海", "city": [ &#123; "name": "西宁", "area": ["城中区", "城东区", "城西区", "城北区", "湟源县", "湟中县", "大通回族土族自治县", "其他"] &#125;, &#123; "name": "海东地区", "area": ["平安县", "乐都县", "民和回族土族自治县", "互助土族自治县", "化隆回族自治县", "循化撒拉族自治县", "其他"] &#125;, &#123; "name": "海北藏族自治州", "area": ["海晏县", "祁连县", "刚察县", "门源回族自治县", "其他"] &#125;, &#123; "name": "海南藏族自治州", "area": ["共和县", "同德县", "贵德县", "兴海县", "贵南县", "其他"] &#125;, &#123; "name": "黄南藏族自治州", "area": ["同仁县", "尖扎县", "泽库县", "河南蒙古族自治县", "其他"] &#125;, &#123; "name": "果洛藏族自治州", "area": ["玛沁县", "班玛县", "甘德县", "达日县", "久治县", "玛多县", "其他"] &#125;, &#123; "name": "玉树藏族自治州", "area": ["玉树县", "杂多县", "称多县", "治多县", "囊谦县", "曲麻莱县", "其他"] &#125;, &#123; "name": "海西蒙古族藏族自治州", "area": ["德令哈市", "格尔木市", "乌兰县", "都兰县", "天峻县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "宁夏", "city": [ &#123; "name": "银川", "area": ["兴庆区", "西夏区", "金凤区", "灵武市", "永宁县", "贺兰县", "其他"] &#125;, &#123; "name": "石嘴山", "area": ["大武口区", "惠农区", "平罗县", "其他"] &#125;, &#123; "name": "吴忠", "area": ["利通区", "青铜峡市", "盐池县", "同心县", "其他"] &#125;, &#123; "name": "固原", "area": ["原州区", "西吉县", "隆德县", "泾源县", "彭阳县", "其他"] &#125;, &#123; "name": "中卫", "area": ["沙坡头区", "中宁县", "海原县", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "新疆", "city": [ &#123; "name": "乌鲁木齐", "area": ["天山区", "沙依巴克区", "新市区", "水磨沟区", "头屯河区", "达坂城区", "东山区", "乌鲁木齐县", "其他"] &#125;, &#123; "name": "克拉玛依", "area": ["克拉玛依区", "独山子区", "白碱滩区", "乌尔禾区", "其他"] &#125;, &#123; "name": "吐鲁番地区", "area": ["吐鲁番市", "托克逊县", "鄯善县", "其他"] &#125;, &#123; "name": "哈密地区", "area": ["哈密市", "伊吾县", "巴里坤哈萨克自治县", "其他"] &#125;, &#123; "name": "和田地区", "area": ["和田市", "和田县", "洛浦县", "民丰县", "皮山县", "策勒县", "于田县", "墨玉县", "其他"] &#125;, &#123; "name": "阿克苏地区", "area": ["阿克苏市", "温宿县", "沙雅县", "拜城县", "阿瓦提县", "库车县", "柯坪县", "新和县", "乌什县", "其他"] &#125;, &#123; "name": "喀什地区", "area": ["喀什市", "巴楚县", "泽普县", "伽师县", "叶城县", "岳普湖县", "疏勒县", "麦盖提县", "英吉沙县", "莎车县", "疏附县", "塔什库尔干塔吉克自治县", "其他"] &#125;, &#123; "name": "克孜勒苏柯尔克孜自治州", "area": ["阿图什市", "阿合奇县", "乌恰县", "阿克陶县", "其他"] &#125;, &#123; "name": "巴音郭楞蒙古自治州", "area": ["库尔勒市", "和静县", "尉犁县", "和硕县", "且末县", "博湖县", "轮台县", "若羌县", "焉耆回族自治县", "其他"] &#125;, &#123; "name": "昌吉回族自治州", "area": ["昌吉市", "阜康市", "奇台县", "玛纳斯县", "吉木萨尔县", "呼图壁县", "木垒哈萨克自治县", "米泉市", "其他"] &#125;, &#123; "name": "博尔塔拉蒙古自治州", "area": ["博乐市", "精河县", "温泉县", "其他"] &#125;, &#123; "name": "石河子", "area": ["石河子"] &#125;, &#123; "name": "阿拉尔", "area": ["阿拉尔"] &#125;, &#123; "name": "图木舒克", "area": ["图木舒克"] &#125;, &#123; "name": "五家渠", "area": ["五家渠"] &#125;, &#123; "name": "伊犁哈萨克自治州", "area": ["伊宁市", "奎屯市", "伊宁县", "特克斯县", "尼勒克县", "昭苏县", "新源县", "霍城县", "巩留县", "察布查尔锡伯自治县", "塔城地区", "阿勒泰地区", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "台湾", "city": [ &#123; "name": "台湾", "area": ["台北市", "高雄市", "台北县", "桃园县", "新竹县", "苗栗县", "台中县", "彰化县", "南投县", "云林县", "嘉义县", "台南县", "高雄县", "屏东县", "宜兰县", "花莲县", "台东县", "澎湖县", "基隆市", "新竹市", "台中市", "嘉义市", "台南市", "其他"] &#125;, &#123; "name": "其他", "area": ["其他"] &#125; ] &#125;, &#123; "name": "澳门", "city": [ &#123; "name": "澳门", "area": ["花地玛堂区", "圣安多尼堂区", "大堂区", "望德堂区", "风顺堂区", "嘉模堂区", "圣方济各堂区", "路凼", "其他"] &#125; ] &#125;, &#123; "name": "香港", "city": [ &#123; "name": "香港", "area": ["中西区", "湾仔区", "东区", "南区", "深水埗区", "油尖旺区", "九龙城区", "黄大仙区", "观塘区", "北区", "大埔区", "沙田区", "西贡区", "元朗区", "屯门区", "荃湾区", "葵青区", "离岛区", "其他"] &#125; ] &#125;, &#123; "name": "钓鱼岛", "city": [ &#123; "name": "钓鱼岛", "area": ["钓鱼岛"] &#125; ] &#125;] 省市列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583[ &#123; "title": "北京", "contents": [ "东城区", "西城区", "崇文区", "宣武区", "朝阳区", "丰台区", "石景山区", "海淀区", "门头沟区", "房山区", "通州区", "顺义区", "昌平区", "大兴区", "平谷区", "怀柔区", "密云县", "延庆县" ] &#125;, &#123; "title": "天津", "contents": [ "天津" ] &#125;, &#123; "title": "河北", "contents": [ "石家庄", "唐山", "秦皇岛", "邯郸", "邢台", "保定", "张家口", "承德", "沧州", "廊坊", "衡水" ] &#125;, &#123; "title": "山西", "contents": [ "太原", "大同", "阳泉", "长治", "晋城", "朔州", "忻州", "吕梁", "晋中", "临汾", "运城" ] &#125;, &#123; "title": "内蒙古", "contents": [ "呼和浩特", "包头", "乌海", "赤峰", "呼伦贝尔", "兴安盟", "通辽", "锡林郭勒盟", "乌兰察布盟", "伊克昭盟", "巴彦淖尔盟", "阿拉善盟" ] &#125;, &#123; "title": "辽宁", "contents": [ "沈阳", "大连", "鞍山", "抚顺", "本溪", "丹东", "锦州", "营口", "阜新", "辽阳", "盘锦", "铁岭", "朝阳", "葫芦岛", "其他" ] &#125;, &#123; "title": "吉林", "contents": [ "长春", "吉林", "四平", "辽源", "通化", "白山", "松原", "白城", "延边朝鲜族自治州", "其他" ] &#125;, &#123; "title": "黑龙江", "contents": [ "哈尔滨", "齐齐哈尔", "鹤岗", "双鸭山", "鸡西", "大庆", "伊春", "牡丹江", "佳木斯", "七台河", "黑河", "绥化", "大兴安岭地区", "其他" ] &#125;, &#123; "title": "上海", "contents": [ "上海" ] &#125;, &#123; "title": "江苏", "contents": [ "南京", "苏州", "无锡", "常州", "镇江", "南通", "泰州", "扬州", "盐城", "连云港", "徐州", "淮安", "宿迁", "其他" ] &#125;, &#123; "title": "浙江", "contents": [ "杭州", "宁波", "温州", "嘉兴", "湖州", "绍兴", "金华", "衢州", "舟山", "台州", "丽水", "其他" ] &#125;, &#123; "title": "安徽", "contents": [ "合肥", "芜湖", "蚌埠", "淮南", "马鞍山", "淮北", "铜陵", "安庆", "黄山", "滁州", "阜阳", "宿州", "巢湖", "六安", "亳州", "池州", "宣城", "其他" ] &#125;, &#123; "title": "福建", "contents": [ "福州", "厦门", "莆田", "三明", "泉州", "漳州", "南平", "龙岩", "宁德", "其他" ] &#125;, &#123; "title": "江西", "contents": [ "南昌", "景德镇", "萍乡", "九江", "新余", "鹰潭", "赣州", "吉安", "宜春", "抚州", "上饶", "其他" ] &#125;, &#123; "title": "山东", "contents": [ "济南", "青岛", "淄博", "枣庄", "东营", "烟台", "潍坊", "济宁", "泰安", "威海", "日照", "莱芜", "临沂", "德州", "聊城", "滨州", "菏泽", "其他" ] &#125;, &#123; "title": "河南", "contents": [ "郑州", "开封", "洛阳", "平顶山", "安阳", "鹤壁", "新乡", "焦作", "濮阳", "许昌", "漯河", "三门峡", "南阳", "商丘", "信阳", "周口", "驻马店", "焦作", "其他" ] &#125;, &#123; "title": "湖北", "contents": [ "武汉", "黄石", "十堰", "荆州", "宜昌", "襄樊", "鄂州", "荆门", "孝感", "黄冈", "咸宁", "随州", "恩施土家族苗族自治州", "仙桃", "天门", "潜江", "神农架林区", "其他" ] &#125;, &#123; "title": "湖南", "contents": [ "长沙", "株洲", "湘潭", "衡阳", "邵阳", "岳阳", "常德", "张家界", "益阳", "郴州", "永州", "怀化", "娄底", "湘西土家族苗族自治州", "其他" ] &#125;, &#123; "title": "广东", "contents": [ "广州", "深圳", "东莞", "中山", "潮州", "揭阳", "云浮", "珠海", "汕头", "韶关", "佛山", "江门", "湛江", "茂名", "肇庆", "惠州", "梅州", "汕尾", "河源", "阳江", "清远" ] &#125;, &#123; "title": "广西", "contents": [ "南宁", "柳州", "桂林", "梧州", "北海", "防城港", "钦州", "贵港", "玉林", "百色", "贺州", "河池", "来宾", "崇左", "其他" ] &#125;, &#123; "title": "海南", "contents": [ "海口", "三亚", "五指山", "琼海", "儋州", "文昌", "万宁", "东方", "澄迈县", "定安县", "屯昌县", "临高县", "白沙黎族自治县", "昌江黎族自治县", "乐东黎族自治县", "陵水黎族自治县", "保亭黎族苗族自治县", "琼中黎族苗族自治县", "其他" ] &#125;, &#123; "title": "重庆", "contents": [ "重庆" ] &#125;, &#123; "title": "四川", "contents": [ "成都", "自贡", "攀枝花", "泸州", "德阳", "绵阳", "广元", "遂宁", "内江", "乐山", "南充", "眉山", "宜宾", "广安", "达州", "雅安", "巴中", "资阳", "阿坝藏族羌族自治州", "甘孜藏族自治州", "凉山彝族自治州", "其他" ] &#125;, &#123; "title": "贵州", "contents": [ "贵阳", "六盘水", "遵义", "安顺", "铜仁地区", "毕节地区", "黔西南布依族苗族自治州", "黔东南苗族侗族自治州", "黔南布依族苗族自治州", "其他" ] &#125;, &#123; "title": "云南", "contents": [ "昆明", "曲靖", "玉溪", "保山", "昭通", "丽江", "普洱", "临沧", "德宏傣族景颇族自治州", "怒江傈僳族自治州", "迪庆藏族自治州", "大理白族自治州", "楚雄彝族自治州", "红河哈尼族彝族自治州", "文山壮族苗族自治州", "西双版纳傣族自治州", "其他" ] &#125;, &#123; "title": "西藏", "contents": [ "拉萨", "那曲地区", "昌都地区", "林芝地区", "山南地区", "日喀则地区", "阿里地区", "其他" ] &#125;, &#123; "title": "陕西", "contents": [ "西安", "铜川", "宝鸡", "咸阳", "渭南", "延安", "汉中", "榆林", "安康", "商洛", "其他" ] &#125;, &#123; "title": "甘肃", "contents": [ "兰州", "嘉峪关", "金昌", "白银", "天水", "武威", "酒泉", "张掖", "庆阳", "平凉", "定西", "陇南", "临夏回族自治州", "甘南藏族自治州", "其他" ] &#125;, &#123; "title": "青海", "contents": [ "西宁", "海东地区", "海北藏族自治州", "海南藏族自治州", "黄南藏族自治州", "果洛藏族自治州", "玉树藏族自治州", "海西蒙古族藏族自治州", "其他" ] &#125;, &#123; "title": "宁夏", "contents": [ "银川", "石嘴山", "吴忠", "固原", "中卫", "其他" ] &#125;, &#123; "title": "新疆", "contents": [ "乌鲁木齐", "克拉玛依", "吐鲁番地区", "哈密地区", "和田地区", "阿克苏地区", "喀什地区", "克孜勒苏柯尔克孜自治州", "巴音郭楞蒙古自治州", "昌吉回族自治州", "博尔塔拉蒙古自治州", "石河子", "阿拉尔", "图木舒克", "五家渠", "伊犁哈萨克自治州", "其他" ] &#125;, &#123; "title": "台湾", "contents": [ "台湾", "其他" ] &#125;, &#123; "title": "澳门", "contents": [ "澳门" ] &#125;, &#123; "title": "香港", "contents": [ "香港" ] &#125;, &#123; "title": "钓鱼岛", "contents": [ "钓鱼岛" ] &#125;]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——UISelecto模块的年月日选择器数据源]]></title>
      <url>%2F2017%2F04%2F25%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94UISelecto%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B9%B4%E6%9C%88%E6%97%A5%E9%80%89%E6%8B%A9%E5%99%A8%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
      <content type="text"><![CDATA[今天使用到了UISelector这个选择器模块,可以自定义数据源, 基本格式, 模块文档已经写的很清楚了, 如果要用他来作为日期选择器就必须要自定义一个数据源 实现代码12345678910111213141516171819202122232425262728293031323334353637383940function getData() &#123; var data = []; // 添加年份 var year = new Date().getFullYear(); // 获取1950年到2027年的日期 for (var i = year + 10; i &gt; 1950; i--) &#123; data.push(&#123;title:i&#125;) &#125; // 添加月份 for(var j= 0; j &lt; data.length;j++) &#123; data[j].contents = []; for (var q = 0; q &lt; 12;q++) &#123; data[j].contents.push(&#123;title:q+1&#125;); &#125; &#125; // 添加日期 for(var w = 0; w &lt; data.length;w++) &#123; for (var e = 0; e &lt; 12;e++) &#123; // 1 3 5 7 8 10 12 31天 var d = 31; data[w].contents[e].contents = []; // 闰年2月29天 平年2月28天 if (e === 1) &#123; if (data[w].title % 4 === 0 &amp;&amp; (data[w].title % 100 !== 0 || data[w].title % 400 === 0) ) &#123; d = 29 &#125; else &#123; d = 28 &#125; // 4 6 9 11 30天 &#125; else if (e === 3 || e === 5 || e === 8 || e === 10) &#123; d = 30; &#125; for (var r = 0; r &lt; d;r++) &#123; data[w].contents[e].contents.push(r + 1) &#125; &#125; &#125; return data; &#125; 使用的时候 把数据源改成这个函数的返回值, 或者把函数的返回值储存在一个json文件中, 使用widget:// 或者fs:// 使用本地文件 在app中使用, 点击按钮打开一个新的frame, 然后在frame页面的apiready函数中直接调用UISelector.open({})]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个简单的倒计时函数]]></title>
      <url>%2F2017%2F04%2F22%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[今天写app的注册页面, 牵扯到了发送验证吗的间隔时间, 就要写一个倒计时函数, 倒计时期间禁用发送验证码的按钮, 页面显示倒计时秒数 APICloud的方法12345678910111213141516171819202122232425262728// 倒计时 function countDown() &#123; var n = 60; var inta = setInterval(function()&#123; // 设置.time的文本 $api.text($api.dom('.time'), n); // 显示倒计时标签 $api.css($api.dom('p'), 'display:block'); // 禁用发送验证码按钮 $api.attr($api.dom('.hqyzm'), 'disabled', 'true'); // 修改发送验证码按钮颜色 $api.css($api.dom('.hqyzm'), 'border: 1px solid #d0d0d0;color: #9d9d9d;'); // 减去倒计时 n--; if (n &lt; -1) &#123; // 清除定时器 clearInterval(inta); // 倒计时完毕后修改按钮颜色 iptChange(); // 隐藏倒计时标签 $api.css($api.dom('p'), 'display:none'); // 把倒计时标签清空 $api.text($api.dom('.time'), ''); // 初始化时间 n = 60; &#125; &#125;,1000) &#125; 可以设置页面中的倒计时1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;input id="ipt" type="text" placeholder="你要设置多少秒倒计时？" name=""&gt;&lt;button onclick="countDown()"&gt;开始&lt;/button&gt;&lt;div id="time"&gt;&lt;/div&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; // 倒计时 function countDown() &#123; var n = document.getElementById('ipt').value; var inta = setInterval(function()&#123; document.getElementById('time').innerHTML = n; // 减去倒计时 n--; if (n &lt; -1) &#123; // 清除定时器 clearInterval(inta); // 初始化时间 n = document.getElementById('ipt').value; &#125; &#125;,1000) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——聊天窗口功能实现]]></title>
      <url>%2F2017%2F04%2F21%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E8%81%8A%E5%A4%A9%E7%AA%97%E5%8F%A3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[接上一篇实现收发消息这一篇实现聊天窗口的功能 接收到消息或者发送消息，让页面显示最新的消息内容 就像qq微信聊天那样，接收到消息，或者你发送消息之后，让最新的消息显示在最下面 实现思路就是, 监听发送和接收消息事件, 一旦触发了事件, 就让聊天内容所在的元素的底端和其所在滚动区的可视区域的底端对齐(滚动到最底部) ele.scrollIntoView(true | false)这个方法就是让当前的元素滚动到浏览器窗口的可视区域内 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。 利用这个方法达到想要的目的12345678// 滚动到页面底部function slideBut() &#123; // 所有的聊天内容都放置在.main这个div中 $api.dom('.main').scrollIntoView(false);&#125;// 接收消息 or 发送消息都调用一下此函数, 就可以达到想要的效果 接收或着发送消息之后,append一个标签12345678910// 接收消息后新建消息 function addReceMsg(msg, headImg) &#123; $api.append($api.dom('.main'),'&lt;div class="other clearfix"&gt;&lt;img class="fl" src="../../image/tx_5.jpg"&gt;&lt;p class="fl"&gt;' + msg + '&lt;/p&gt;&lt;/div&gt;'); slideBut(); &#125; // 发送消息后新建消息 function addSendMsg(msg, headImg) &#123; $api.append($api.dom('.main'),'&lt;div class="oneself clearfix"&gt;&lt;img class="fr" src="'+ headImg +'"&gt;&lt;p class="fr"&gt; ' + msg + ' &lt;/p&gt;&lt;/div&gt;'); slideBut(); &#125; 查看聊天记录 下拉加载历史聊天记录，显示在页面上部 利用UIPullRefreshFlash这个下拉刷新模块实现, 下拉发送请求获取历史聊天记录 每次查询20条,查询完就把oldestMessageId这个参数减去20, 这样就能保证每次查询的都是不同的内容 如果oldestMessageId的值小于0, 不再进行请求. 我这里是页面加载完请求最新的消息记录, 获得oldestMessageId这个值, 把它保存在一个全局变量中, 每次请求完把这个变量减去20123456789101112131415161718// 最新聊天记录rong.getLatestMessages(&#123; conversationType: 'PRIVATE', targetId: 'testUser1', count: 20&#125;, function(ret, err) &#123; for (var i = ret.result.length-1; i &gt;= 0 ; i--) &#123; if (ret.result[i].messageDirection == 'RECEIVE') &#123; // 消息方向：SEND(发送) 或者 RECEIVE(接受) addReceMsg(ret.result[i].content.text) &#125; else &#123; addSendMsg(ret.result[i].content.text, headImg); &#125; &#125; // 最新的消息的messageId就是oldestMessageId,获取历史记录函数内部-20处理 messageId = ret.result[0].messageId;&#125;) 查询完, 把历史消息插入到聊天窗口上面 // 查看历史记录 往上面添加消息 function addSendMsgTop(msg, headImg) { $api.prepend($api.dom('.main'),'&lt;div class="oneself clearfix"&gt;&lt;img class="fr" src="'+ headImg +'"&gt;&lt;p class="fr"&gt; ' + msg + ' &lt;/p&gt;&lt;/div&gt;'); } function addReceMsgTop(msg, headImg) { $api.prepend($api.dom('.main'),'&lt;div class="other clearfix"&gt;&lt;img class="fl" src="../../image/tx_5.jpg"&gt;&lt;p class="fl"&gt;' + msg + '&lt;/p&gt;&lt;/div&gt;'); } 欢迎访问我的博客:www.yuanjingzhuang.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——融云+UIChatTools实现即时通讯聊天]]></title>
      <url>%2F2017%2F04%2F19%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E8%9E%8D%E4%BA%91-UIChatTools%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E8%81%8A%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[今天完成了公司app的聊天界面的收发消息功能，结合融云2和UIChatTools模块实现，只是实现了基本功能，好多细节还没有实现，废话不多说，上代码 输入框页面（win）先引入所需模块12345// 融云模块var rong = api.require('rongCloud2');//聊天界面模块var UIChatTools = api.require('UIChatTools'); 初始化聊天输入框UIChatTools模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 聊天界面function chatTools() &#123; UIChatTools.open(&#123; chatBox: &#123; placeholder: '聊天内容', autoFocuse: true, maxRows: 6 &#125;, styles: &#123; bgColor: '#D1D1D1', margin: 10, &#125;, tools: &#123; h: 35, iconSize: 30, recorder: &#123; normal: 'fs://UIChatTolls/recorder.png', selected: 'fs://UIChatTolls/recorder1.png' &#125;, image: &#123; normal: 'fs://UIChatTolls/image.png', selected: 'fs://UIChatTolls/image1.png' &#125;, video: &#123; normal: 'fs://UIChatTolls/video.png', selected: 'fs://UIChatTolls/video1.png' &#125;, face: &#123; normal: 'fs://UIChatTolls/face2.png', selected: 'fs://UIChatTolls/face1.png' &#125;, append: &#123; normal: 'fs://UIChatTolls/append.png', selected: 'fs://UIChatTolls/append1.png' &#125; &#125;, // 表情 // emotions:['widget://image/chatPage/emoticons/basic','widget://image/chatPage/emoticons/append1','widget://image/chatPage/emoticons/append2']&#125;, function(ret) &#123; if (ret) &#123; if (ret.eventType === 'send') &#123; // 发送消息 sendMsg(ret.msg); &#125; &#125; &#125;);// 附加按钮UIChatTools.setAppendButton(&#123; styles: &#123; row: 2, column: 4, iconSize: 50, titleSize: 13, titleColor: '#f00' &#125;, buttons: [ &#123; normal: 'widget://image/chatPage/album2.png', highlight: 'widget://image/chatPage/album2.png', title: '电话' &#125;,&#123; normal: 'widget://image/chatPage/album2.png', highlight: 'widget://image/chatPage/album2.png', title: '收藏' &#125;,&#123; normal: 'widget://image/chatPage/album2.png', highlight: 'widget://image/chatPage/album2.png', title: '发红包' &#125; ]&#125;, function(ret) &#123; api.alert(&#123;msg:'点击了第'+ret.index+'个按钮'&#125;);&#125;);// 监听功能按钮UIChatTools.toolsListener(function(ret) &#123; if (ret.eventType == 'video') &#123; api.alert(&#123; title: 'title', msg: 'video', &#125;, function(ret, err) &#123; if (ret) &#123; alert(JSON.stringify(ret)); &#125; else &#123; alert(JSON.stringify(err)); &#125; &#125;); &#125;&#125;);// 接入融云rongyun();&#125; 接入融云1234567891011121314151617181920// 接入融云function rongyun () &#123; rong.init(function(ret, err) &#123; if (ret.status == 'error') api.toast(&#123; msg: err.code &#125;); &#125;); // 监听接收消息 receiveMsg(); rong.connect( &#123; // 用户1 // token: '用户1token' // 用户2 token: '用户2token' &#125;,function(ret, err) &#123; if (ret.status == 'success') api.toast(&#123; msg: ret.result.userId &#125;); &#125;);&#125; 监听接收消息123456789101112// 监听接收消息function receiveMsg() &#123; rong.setOnReceiveMessageListener(function(ret, err) &#123; // 由于聊天框界面和聊天内容不是一个页面所以要使用事件监听的方式通知聊天内容页面，传递参数 api.sendEvent(&#123; name: 'receiveMsg', extra: &#123; msg: ret.result.message.content.text &#125; &#125;); &#125;)&#125; 发送消息123456789101112131415161718192021222324252627282930313233343536function sendMsg(msg) &#123; var sendMsg; rong.sendTextMessage(&#123; conversationType: 'PRIVATE', targetId: 'testUser1', text: msg, extra: '' &#125;, function(ret, err) &#123; if (ret.status == 'prepare') &#123; // 获取发送的消息内容 sendMsg = ret.result.message.content.text; &#125; else if (ret.status == 'success') &#123; // 广播发送消息事件 api.sendEvent(&#123; name: 'sendMsg', extra: &#123; msg: sendMsg &#125; &#125;); &#125; else if (ret.status == 'error') &#123; api.alert(&#123; title: 'title', msg: err.code, &#125;, function(ret, err) &#123; if (ret) &#123; alert(JSON.stringify(ret)); &#125; else &#123; alert(JSON.stringify(err)); &#125; &#125;); &#125; &#125;);&#125; 聊天内容页面（Frame）监听发送消息123456api.addEventListener(&#123; name: 'sendMsg'&#125;, function(ret, err) &#123; // 发送消息后, 添加消息内容到页面 $api.append($api.dom('.main'),'&lt;div class="oneself clearfix"&gt;&lt;img class="fr" src="../../image/tx_2.jpg"&gt;&lt;p class="fr"&gt; ' + ret.value.msg + ' &lt;/p&gt;&lt;/div&gt;');&#125;); 监听页面接收消息123456api.addEventListener(&#123; name: 'receiveMsg'&#125;, function(ret, err) &#123; // 收到消息后, 添加消息内容到页面 $api.append($api.dom('.main'),'&lt;div class="other clearfix"&gt;&lt;img class="fl" src="../../image/tx_2.jpg"&gt;&lt;p class="fl"&gt;' + ret.value.msg + '&lt;/p&gt;&lt;/div&gt;');&#125;); 基本功能已经实现，效果如图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架——获取本地图片信息]]></title>
      <url>%2F2017%2F04%2F18%2FAPICloud%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[api.getPicture 获取本地图片放置到服务器上或者在app中预览是app的基本功能，今天使用了APICloud框架的api.getPicture这个api获取到的本地图片预览在app中，就像上传qq头像一样，其实就是这个需求，获取本地照片（拍摄照片）设置为头像，先预览一下。 这个api的文档写的很清楚，每个参数的功能，可是其中还是有点坑的123456789101112131415api.getPicture(&#123; sourceType: 'library', encodingType: 'jpg', mediaValue: 'pic', destinationType: 'base64', quality: 50, targetWidth: 100, targetHeight: 100&#125;, function(ret, err) &#123; if (ret) &#123; $api.attr($api.dom('img'),'src', ret.base64Data) &#125; else &#123; alert(JSON.stringify(err)); &#125;&#125;); 这个是没有坑的代码123456789101112131415 api.getPicture(&#123; sourceType: 'library', encodingType: 'jpg', mediaValue: 'pic', destinationType: 'base64', quality: 50, targetWidth: 750, targetHeight: 750&#125;, function(ret, err) &#123; if (ret) &#123; $api.attr($api.dom('img'),'src', ret.base64Data) &#125; else &#123; alert(JSON.stringify(err)); &#125;&#125;); 对比以上两段代码，第一段是官方文档给的，一开始我直接拷贝过来使用的时候，拿到图片后显示在页面中就会非常模糊，就像下面这样，这个问题纠结了好久，又回头仔细看了一遍文档才发现targetWidth: 750, targetHeight: 750这两个属性；官方给的都是100，我就直接拷贝过来的，然后预览图就变成下面这个样子了。 targetWidth： 类型：数字 默认值：原图宽度 描述：（可选项）压缩后的图片宽度，图片会按比例适配此宽度 targetHeight： 类型：数字 默认值：原图高度 描述：（可选项）压缩后的图片高度，图片会按比例适配此高度 如果targetWidth和targetHeight设置过小的时候（比如官方的100），图片就会照成失真，就是上面的显示结果，所以这两个属性设置不要太小,同时把quality（1-100）图片质量设置的低一点,只是预览效果,设置好这三个属性后就可以正常的预览图片了。 由于后台还没有写好,所以今天就暂时先不写上传图片了 欢迎大家访问我的博客www.yuanjingzhuang.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架sublime使用自定义loader]]></title>
      <url>%2F2017%2F04%2F17%2FAPICloud%E6%A1%86%E6%9E%B6--sublime%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89loader%2F</url>
      <content type="text"><![CDATA[官方的apploader调试器，只是有官方的一些模块，如果我们使用非官方的模块就要使用自定义loader进行调试。接下来就走一边sublime设置自定义loader的步骤 修改config.xml打开本地创建的 moduleTest 应用的 config.xml 文件，把其中的 id 修改成云平台创建的应用 ID 把代码放置到云空间这一步大家都应该会，进入开发控制台，选择代码，有三种方式可以使用 官方的SVN git或者码云 上传代码压缩包（不推荐） 不管你采用何种方式，代码和云联系起来就可以了 编译自定义loader在 APICloud 控制台中，配置好应用的端设置、证书、包名等，再进入 -&gt; 模块页面 -&gt; 添加自己需要的模块 到 APICloud 平台 -&gt; 模块页面 -&gt; 选择’自定义Loader’标签 点击自定义 Loader 编译按钮 -&gt; 等待编译完成 -&gt; 下载(不用安装) 真机同步Android 应用的真机同步找到 Sublime Text 安装目录 -&gt; 浏览插件目录\Packages\APICloudLoader\appLoader\custom-loader（Mac 系统为：/Users/用户名/Library/Application Support/Sublime Text 3/Packages/APICloudLoader/appLoader/custom-loader） IOS应用的真机同步找到 Sublime Text 安装目录 -&gt; D:\安装目录\Data\Packages\APICloudLoader\appLoader\custom-loader-ios（Mac 系统为：/Users/用户名/Library/Application Support/Sublime Text 3/Packages/APICloudLoader/appLoader/custom-loader-ios） 新建一个文件夹，以云端应用 ID 命名，把刚下载的自定义 Loader 放入此目录，Android 应用重命名为 ‘load.apk,iOS 应用则为load.ipa’。 获取应用包名 新建一个 ‘load.conf’ 文件（version - 自定义 Loader 版本号，packageName - 应用包名），格式如图： 注意：iOS平台的自定义loader，如果没有上传自己的iOS证书，则所有app项目的自定义loader统一包名为“com.api.customloader” 测试回到我们的sublime编辑器中,右键项目文件夹,选择’Android真机同步..’ 或 ‘iOS真机同步..’ 等待真机同步完成， Android 手机自动打开刚同步的应用，代表同步成功，iOS不会自动打开应用，需要手动打开同步完的应用。 暂不支持iOS 10 以上版本的手机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Felx布局（三）]]></title>
      <url>%2F2017%2F04%2F14%2FFelx%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[flex网格布局平均分布 最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放 html代码123456&lt;!-- 几个元素就几个标签 --&gt;&lt;div class="Grid"&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt;&lt;/div&gt; css代码 1234567.Grid &#123; display: flex;&#125;/* 平均分布 */.Grid-cell &#123; flex: 1;&#125; 百分比分布 某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。 html代码 12345&lt;div class="Grid"&gt; &lt;div class="Grid-cell u-1of4"&gt;...&lt;/div&gt; &lt;div class="Grid-cell"&gt;...&lt;/div&gt; &lt;div class="Grid-cell u-1of3"&gt;...&lt;/div&gt;&lt;/div&gt; css代码1234567891011121314151617181920212223.Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 1;&#125;.Grid-cell.u-full &#123; flex: 0 0 100%;&#125;.Grid-cell.u-1of2 &#123; flex: 0 0 50%;&#125;.Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%;&#125;.Grid-cell.u-1of4 &#123; flex: 0 0 25%;&#125; # 圣杯布局 圣杯布局（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。 html代码123456789&lt;body class="HolyGrail"&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class="HolyGrail-body"&gt; &lt;main class="HolyGrail-content"&gt;...&lt;/main&gt; &lt;nav class="HolyGrail-nav"&gt;...&lt;/nav&gt; &lt;aside class="HolyGrail-ads"&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; css代码1234567891011121314151617181920212223242526272829.HolyGrail &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;header,footer &#123; flex: 1;&#125;.HolyGrail-body &#123; display: flex; flex: 1;&#125;.HolyGrail-content &#123; flex: 1;&#125;.HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em;&#125;.HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1;&#125; 如果是小屏幕，躯干的三栏自动变为垂直叠加。 1234567891011@media (max-width: 768px) &#123; .HolyGrail-body &#123; flex-direction: column; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content &#123; flex: auto; &#125;&#125; 输入框的布局 我们常常需要在输入框的前方添加提示，后方添加按钮。 html代码12345&lt;div class="InputAddOn"&gt; &lt;span class="InputAddOn-item"&gt;...&lt;/span&gt; &lt;input class="InputAddOn-field"&gt; &lt;button class="InputAddOn-item"&gt;...&lt;/button&gt;&lt;/div&gt; css代码1234567.InputAddOn &#123; display: flex;&#125;.InputAddOn-field &#123; flex: 1;&#125; 悬挂式布局 主栏的左侧或右侧，需要添加一个图片栏。 html代码1234&lt;div class="Media"&gt; &lt;img class="Media-figure" src="" alt=""&gt; &lt;p class="Media-body"&gt;...&lt;/p&gt;&lt;/div&gt; css代码123456789101112.Media &#123; display: flex; align-items: flex-start;&#125;.Media-figure &#123; margin-right: 1em;&#125;.Media-body &#123; flex: 1;&#125; # 固定的底栏 有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。 12345&lt;body class="Site"&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class="Site-content"&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/body&gt; css代码123456789.Site &#123; display: flex; min-height: 100vh; flex-direction: column;&#125;.Site-content &#123; flex: 1;&#125; 流式布局 html代码1234567 &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; css代码 12345678910111213141516.parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-flow: row wrap; align-content: flex-start;&#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red;&#125; 转自阮一峰博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局（二）]]></title>
      <url>%2F2017%2F04%2F13%2FFlex%E5%B8%83%E5%B1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[接上一篇，说一下flex布局的实例，转自阮一峰老师的博客 骰子的布局 html页面模版123&lt;div class="box"&gt; &lt;span class="item"&gt;&lt;/span&gt;&lt;/div&gt; div代表容器,span代表骰子的点 一个 左上对齐 123.box &#123; display: flex;&#125; 居中对齐 1234.box &#123; display: flex; justify-content: center;&#125; 左对齐 1234.box &#123; display: flex; justify-content: flex-end;&#125; 垂直靠左居中 1234.box &#123; display: flex; align-items: center;&#125; 水平垂直居中 12345.box &#123; display: flex; align-items: center; justify-content: center;&#125; 靠下水平居中 12345.box &#123; display: flex; align-items: flex-end; justify-content: center;&#125; 左下角 12345.box &#123; display: flex; align-items: flex-end; justify-content: flex-end;&#125; 两个 分散对齐 1234.box &#123; display: flex; justify-content: space-between;&#125; 垂直分散对齐 12345.box &#123; display: flex; flex-direction: column; justify-content: space-between;&#125; 水平居中\垂直分散对齐123456.box &#123; display: flex; flex-direction: column; justify-content: space-between; align-items: center;&#125; 水平靠右\垂直分散对齐123456.box &#123; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end;&#125; 一个左上角,一个水平垂直居中 123456.box &#123; display: flex;&#125;.box .item:nth-child(2) &#123; align-self: center;&#125; 一个左上角一个右下角 12345678.box &#123; display: flex; justify-content: space-between;&#125;.item:nth-child(2) &#123; align-self: flex-end;&#125; 三个 1234567891011.box &#123; display: flex;&#125;.item:nth-child(2) &#123; align-self: center;&#125;.item:nth-child(3) &#123; align-self: flex-end;&#125; 四个 123456789101112131415161718192021.box &#123; display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between;&#125;``` ![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAADzCAMAAACfdrC+AAAAhFBMVEUsLCwpKSnn5+czMzMuLi7X19e7u7v///9VVVUREREkJCRSUlJDQ0MhISFJSUloaGhAQEAaGhrc3NxNTU02Nja/v79vb2+RkZE+Pj709PTi4uLR0dF8fHw6OjoVFRWdnZ1XV1fOzs5zc3P5+fmIiIhgYGDt7e3Kysrk5OSwsLCamprBwcGWC6HtAAAFiElEQVR42uzRMQEAAAzDoM2/6drIARa4J0VIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIGTt2uKMqDIRh2E6ZDEVhBc1q68Zd5YRsvP8LPMhJLORsnZQfONn0uYDvR18tAWFSEGFSEGFSEGFSEGFSEGEkBbmebEuLae3pquSRE+RmaXH2pqQRE8TRSzgljJAgO0svYislipAgll7GKlFkBHEU41ffWiKC3GjQ2q6DxXSdbWkg6skuIoilnoXFOWfFXVoSglypBwjLQwTqSXofkRDkREQOG1heg+iI6KLkkBDE3nugg7HDtqiNqYvtAWbj9xwiOll3loQgLQEifsPDZWdGdg3Mw+99Yw+oVXJICEIWe/BwPZuJ8wfMw+/hnSUlh4ggbhJkOxxaoVZar1QxHGYFs/B7eOdSkKkWx0H2xpgy0w9ZaYzZwxz8Hg7SlTXV4Z3/PdeZnsjqmf8Rfg8HnZJDQhA3CnI1ptD/KY35gHj8Hg4kfTyREKTxQS5nf35jhTk3EI3fw0Gj5JAQBH2QnT+/qdLsIBq/h/8oOYQFMbUOqA3EYfdSkBAf5I/JdEBmDhCF30tBAnyQbamDyi1E4fdSkAAfpMx0UFZCFH4vBQnwQQr9hIIo/F4KEuCDrPQTK4jC76UgAT7IUT9xhCj8XgoS4INU+okKovB7KUiAD/K10UGbL4jC76UgAT7I23qvA/b5G0Th91KQAB/kM690QJV/QhR+LwUJ8EFgnW8CF0y+hjjsXvp0EjAO8p7nR/2DY56/Qxx2LwX5y94Z9CYIRGFwfVwWMKJi1KRQpdH//xeLB5ul8LawadxNO7P3d2Acr5+CK+SttHY99Xu25V4C8N1DiIIrRG7W2s0hG3DYWGtPEoD3HkI0XCFS2Z71t59zyB+W/14lCNEYCpG7fVBv2zbL2nZb2wd3CUO/hxCdoRCp7IjQPvR7CFEZCZFTaQeUJwlDv4cQnbEQ2R9L5/Md9xKGfg8hHhwhDpfqanuu1UVC0e8hxIcj5CUg5AcQ4oAQhIxAiANCEDICIQ4ISU+IWUV/CQiJ/g2ej0IohEIohEIohEIohEIoRIRCKIRCfFAIhVCIDwqhkH/44gsx0b/B16MQCqEQCqEQCqEQCqEQChEKoRAK8UEhFPLilwIJCEmIVfyXgJDo34BCKIRCKIRCKIRCKIRCKMSBQiiEQnxQCIVQiI+/X0gCICQxEJIYCEkMhCQGQhIDIYkxJaR57p83Eoh2DyHLhXT1uzO2XXcShH4PIcuEfOS/s6eu30PIEiFt3rMrVlnPqtjlPVsJQr+HEK+QCHvqCJkr5Dy9f36WIPR7CJknpJncPy+C99T1ewiZI6TLtf3zvJMAfPcQojFnT70I3VPX7yFEI/6euoFpIY1v//wmi/HfQ4hC/D11Ay7x99QNKEIyDyFCMg8I0Yi/p27AJf6eugGX+HvqBlzi76kb+GzvDlIUBoIogDZDqKVCoBHMbAQhBu9/vzGuWtFhBiTVi/f+ET5UErL4rfw99UIrf0+90MrfUy+0puw99anQmnL21BXyztz8oDp8eE/98Jc99bnQqtl76rXQiil3T32KQiuuuXvqVSGPIubMPfU5FPKoxnq0Lgl76pf7wQrPkOdC1kaOCXvqx7UPhTxb4mYev7Y33u7VzVJo7WN1TWhkqrHaFx7UuKunccNSxvFUI8LFeuEcqb4LTyKRl95XaiRxsF7bpTVSd4WerlbhjXONzVXP89/sl7phKbUuvj8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA/mOQrkJvBukq9GaQrkJvBukq9GaQrkJvBukqGuksP6e/lCXHzcpvAAAAAElFTkSuQmCC)```html&lt;div class="box"&gt; &lt;div class="column"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125;.column &#123; flex-basis: 100%; display: flex; justify-content: space-between;&#125; 六个 12345.box &#123; display: flex; flex-wrap: wrap; align-content: space-between;&#125; 123456.box &#123; display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;&#125; 1234567891011121314&lt;div class="box"&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;span class="item"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box &#123; display: flex; flex-wrap: wrap;&#125;.row&#123; flex-basis: 100%; display:flex;&#125;.row:nth-child(2)&#123; justify-content: center;&#125;.row:nth-child(3)&#123; justify-content: space-between;&#125; 九个 1234.box &#123; display: flex; flex-wrap: wrap;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局（一）]]></title>
      <url>%2F2017%2F04%2F12%2FFlex%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[FlexFlex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。display: flex;, 行内元素也可以使用display: inline-flex; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”元素”。 容器的属性6个属性 flex-direction: 主轴方向 flex-wrap: 是否换行 flex-flow: 集合属性flex-direction||flex-wrap justify-content: 主轴对齐方式 align-items: 侧轴对齐方式 align-content: 多根轴线对齐方式 1.flex-direction: 主轴方向1flex-direction: row | row-reverse | column | column-reverse; 4个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。2.flex-wrap: 是否换行1flex-wrap: nowrap | wrap | wrap-reverse; 3个值 nowrap: 不换行 wrap: 换行,第一行在第二行上面 wrap-reverse: 换行,第一行在第二行下面 3.flex-flow 简写样式flex-direction和flex-wrap的简写形式 4.justify-content: 主轴对齐方式1justify-content: flex-start | flex-end | center | space-between | space-around; 5个值 flex-start: 主轴开始方向对齐 flex-end: 主轴结束方向对齐 center: 居中对齐 space-between: 两端对齐 space-around: 分散对齐 5.align-items: 侧轴对齐方式1align-items: flex-start | flex-end | center | baseline | stretch; 5个值 flex-start: 侧轴开始方向对齐 flex-end: 侧轴结束方向对齐 center: 居中对齐 baseline: 第一个元素的文字基线对齐 stretch: 默认值 6.align-content 多根轴线对齐方式1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 6个值 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴- 线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴 元素的属性6个属性 order: 顺序 flex-grow: 放大 flex-shrink: 缩小 flex-basis: 占据的主轴控件 flex: 复合属性 align-self: 单个元素和其他的不一样 1.order: 元素排列顺序默认0,越大越靠后 2.flex-grow: 放大默认0,不放大,充满父级元素后,不再放大 3.flex-shrink: 缩小默认1,不缩小,设置为0,如果空间不够元素也不缩小 4.flex-basis:flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5.flex: 复合属性flex-grow flex-shrink flex-basis 0 1 auto 6.flex-self: 不一样的align-self属性允许单个项目有与其他项目不一样的对齐方式， 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APICloud框架db数据库模块的使用]]></title>
      <url>%2F2017%2F04%2F11%2FAPICloud%E6%A1%86%E6%9E%B6--db%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[db数据库模块db 模块封装了手机常用数据库 sqlite 的增删改查语句，可实现数据的本地存储，极大的简化了数据持久化问题，本模块已支持同步接口。官方文档地址 打开/新建一个数据库1234567891011function openDb() &#123; db.openDatabase(&#123; name: 'test' &#125;, function(ret, err)&#123; if( ret.status )&#123; alert('打开成功'); &#125;else&#123; alert( JSON.stringify( err ) ); &#125; &#125;);&#125; 执行sql语句，创建一个Persons表格，表格有Id_P，LastName, FirstName, Address, Cuty五个字段123456789101112function newTable() &#123; db.executeSql(&#123; name: 'test', sql: 'CREATE TABLE Persons(Id_P int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255))' &#125;, function(ret, err) &#123; if (ret.status) &#123; alert(JSON.stringify(ret)); &#125; else &#123; alert(JSON.stringify(err)); &#125; &#125;);&#125; 执行sql储存数据语句 INSERT INTO 表名（字段）VALUES（数据）123456789101112 function insertDb() &#123; db.executeSql(&#123; name: 'test', sql: 'INSERT INTO Persons (Id_P, LastName, FirstName, Address, City) VALUES (01, "jack", "rosr", "address", "Beijing")' &#125;, function(ret, err)&#123; if( ret.status )&#123; alert('储存成功'); &#125;else&#123; alert( JSON.stringify( err ) ); &#125; &#125;);&#125; 查询数据库，SELECT * FROM 表名123456789101112function selectDb() &#123; db.selectSql(&#123; name: 'test', sql: 'SELECT * FROM Persons' &#125;, function(ret, err)&#123; if( ret.status )&#123; alert(JSON.stringify(ret.data)); &#125;else&#123; alert( JSON.stringify( err ) ); &#125; &#125;);&#125; 关闭数据库1234567891011 function closeDb() &#123; db.closeDatabase(&#123; name: 'test' &#125;, function(ret, err)&#123; if( ret.status )&#123; alert('关闭成功'); &#125;else&#123; alert( JSON.stringify( err ) ); &#125; &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[H5C3新特性]]></title>
      <url>%2F2017%2F04%2F09%2FH5C3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[H5新特性总览移除的元素纯表现的元素： basefont、big、center、font等 对可用性产生负面影响的元素： frame、frameset、noframes 新增的API语义： 能够让你更恰当地描述你的内容是什么。 连通性： 能够让你和服务器之间通过创新的新技术方法进行通信（web sockets等）。 离线 &amp; 存储：能够让网页在客户端本地存储数据以及更高效地离线运行（离线资源、在线和离线事件、DOM存储、IndexDB、自web应用程序中使用文件[FileReader]）。 多媒体：使 video 和 audio 成为了在所有 Web 中的一等公民。2D/3D 绘图 &amp; 效果：提供了一个更加分化范围的呈现选择(canvas、webGL)。 性能 &amp; 集成：提供了非常显著的性能优化和更有效的计算机硬件使用（WebWorkers、XMLHttpRequest2、HistoryAPI、拖放、requestAnimationFrame、全屏API、指针锁定API、在线和离线事件）。 设备访问 Device Access：能够处理各种输入和输出设备（触控事件touch、使用地理位置定位、检测设备方向）。 history对象history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。 使用Go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的‘后退’按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮） 123history.go(-1);//后退一页history.go(1);//前进一页history.go(2);//前进两页 也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置–可能后退，也可能前进，具体看那个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做1history.go('wrox.com');//跳到最近的wrox.com页面 另外，还可以使用两个简写方法back()和forward()来代替go()。这两个方法都可以模仿浏览器的‘后退’和‘前进’按钮。 12history.back();//后退一页history.forward();//前进一页 history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有的历史记录，即所有向后和向前的记录。 history在h5中新增的属性和方法 h5中的history对象新增了两个新方法：history.pushState()和history.replaeState(); 两种方法都允许我们添加和更新历史记录，它们的工作原理相同并且可以添加数量相同的参数。但是pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。除了方法之外，还有popstate 事件pushState(data，title[,url])和replaceState(data，title[,url])参数一样，参数说明如下： data:一个表示状态的对象，json格式数据 title：一个string格式的标题（大多数浏览器不支持或忽略这个参数，最好用null代替） url：一个url（用于替换当前URL） 当浏览会话记录的时候，不管点击前进或者后退按钮，还是使用history.go和history.back方法，popstate事件都会被触发。当事件发生时，浏览器会从history中取出URL和对应的state对象替换当前的URL和history.state。通过event.state也可以获取history.state 需要说明的是pushState只是将当前页面保存到history的历史记录中（并作为最近的一个记录），并且将当前浏览器的地址栏改为参数url指定的值，但并不会加载它。这点与普通的通过链接打开或浏览器地址输入url完全不一样。所以如果想在url改变的时候需要监听popstate事件。 利用history可以弥补ajax无法回退的缺陷。如下方法是模拟ajax操作的实现方法。 2D绘图（canvas和svg） SVG SVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。 您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。 如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 canvas Canvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。 如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较 下表列出了 canvas 与 SVG 之间的一些不同之处。Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 CSS3新特性CSS3 选择器（Selector）E:nth-last-child(n) E:nth-child(n) E:nth-of-type(n) E:nth-last-of-type(n) E:last-child E:first-of-type E:only-child E:only-of-type E:empty E:checked E:enabled E:disabled E::selection E:not(s) @Font-face 特性Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。 1234567891011@font-face &#123; font-family: BorderWeb; src:url(BORDERW0.eot); &#125; @font-face &#123; font-family: Runic; src:url(RUNICMT0.eot); &#125; .border &#123; FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: "BorderWeb" &#125; .event &#123; FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: "Runic" &#125; 声明的两个服务端字体，其字体源指向“BORDERW0.eot”和“RUNICMT0.eot”文件，并分别冠以“BorderWeb”和“Runic”的字体名称。声明之后，我们就可以在页面中使用了：“ FONT-FAMILY: “BorderWeb” ” 和 “ FONT-FAMILY: “Runic” ”。 这种做法使得我们在开发中如果需要使用一些特殊字体，而又不确定客户端是否已安装时，便可以使用这种方式。 Word-wrap &amp; Text-overflow 样式加入了“word-wrap: break-word”，设置或检索当当前行超过指定容器的边界时是否断开转行。 Text-overflow: clip|ellipsis 则设置或检索当当前行超过指定容器的边界时如何显示 文字渲染（Text-decoration）Text-fill-color: 文字内部填充颜色 Text-stroke-color: 文字边界填充颜色 Text-stroke-width: 文字边界宽度 CSS3 的多列布局（multi-column layout）Column-count：表示布局几列。 Column-rule：表示列与列之间的间隔条的样式 Column-gap：表示列于列之间的间隔 边框和颜色（color, border）关于颜色，CSS3 已经提供透明度的支持了： CSS3 的渐变效果（Gradient） 线性渐变左上（0% 0%）到右上（0% 100%）即从左到右水平渐变：1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E)); 这里 linear 表示线性渐变，从左到右，由蓝色（#2A8BBE）到红色（#FE280E）的渐变。 复杂线性渐变 1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E)); 径向渐变 径向渐变（radial），这不是从一个点到一个点的渐变，而从一个圆到一个圆的渐变。不是放射渐变而是径向渐变。 1backgroud: -webkit-gradient(radial,50 50,50,50 50,0,from(black),color-stop(0.5,red),to(blue)); 前面“50,50,50”是起始圆的圆心坐标和半径，“50,50,0”蓝色是目标圆的圆心坐标和半径，“color-stop(0.5,red)”是断点的位置和色彩。这里需要说明一下，和放射由内至外不一样，径向渐变刚好相反，是由外到内的渐变。清单 15 标识的是两个同心圆，外圆半径为 50px，内圆半径为 0，那么就是从黑色到红色再到蓝色的正圆形渐变。 CSS3 的阴影（Shadow）和反射（Reflect）效果 阴影效果，阴影效果既可用于普通元素，也可用于文字， 1234567.class1&#123; text-shadow:5px 2px 6px rgba(64, 64, 64, 0.5); &#125; .class2&#123; box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); &#125; 反射 反射，他看起来像水中的倒影，其设置也很简单 12345 .classReflect&#123; -webkit-box-reflect: below 10px -webkit-gradient(linear, left top, left bottom, from(transparent), to(rgba(255, 255, 255, 0.51))); &#125; CSS3 的背景效果 CSS3 多出了几种关于背景（background）的属性，我们这里会简单介绍一下：首先：“Background Clip”，该属确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从 border 开始显示 ; background-clip: padding-box; 背景从 padding 开始显示 ; background-clip: content-box; 背景显 content 区域开始显示 ; background-clip: no-clip; 默认属性，等同于 border-box; 通常情况，我们的背景都是覆盖整个元素的，现在 CSS3 让您可以设置是否一定要这样做。这里您可以设定背景颜色或图片的覆盖范围。 其次：“Background Origin”，用于确定背景的位置，它通常与 background-position 联合使用，您可以从 border、padding、content 来计算 background-position（就像 background-clip）。 background-origin: border-box; 从 border. 开始计算 background-position; background-origin: padding-box; 从 padding. 开始计算 background-position; background-origin: content-box; 从 content. 开始计算 background-position; 还有，“Background Size”，常用来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 . background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 . 最后，“Background Break”属性，CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元 素没有分成多个盒子，依然是一个整体一 样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景。 这种属性让您可以设定复杂元素的背景属性。最为重要的一点，CSS3 中支持多背景图片 CSS3 的 Transitions, Transforms 和 Animation, Transitions Transitions Transition 有下面些具体属性： transition-property：用于指定过渡的性质，比如 transition-property:backgrond 就是指 backgound 参与这个过渡 transition-duration：用于指定这个过渡的持续时间 transition-delay：用于制定延迟过渡的时间 transition-timing-function：用于指定过渡类型，有 ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 123456789101112&lt;div id="transDiv" class="transStart"&gt; transition &lt;/div&gt; .transStart &#123; background-color: white; -webkit-transition: background-color 0.3s linear; -moz-transition: background-color 0.3s linear; -o-transition: background-color 0.3s linear; transition: background-color 0.3s linear; &#125; .transEnd &#123; background-color: red; &#125; 这里他说明的是，这里 id 为“transDiv”的 div，当它的初始“background-color”属性变化时（被 JavaScript 修改），会呈现出一种变化效果，持续时间为 0.3 秒，效果为均匀变换（linear）。如：该 div 的 class 属性由“transStart”改为“transEnd”，其背景会由白（white）渐变到红（red）。 Transform 再来看看 Transform，其实就是指拉伸，压缩，旋转，偏移等等一些图形学里面的基本变换。 12345678910111213141516171819.skew &#123; -webkit-transform: skew(50deg); &#125; .scale &#123; -webkit-transform: scale(2, 0.5); &#125; .rotate &#123; -webkit-transform: rotate(30deg); &#125; .translate &#123; -webkit-transform: translate(50px, 50px); &#125; .all_in_one_transform &#123; -webkit-transform: skew(20deg) scale(1.1, 1.1) rotate(40deg) translate(10px, 15px); &#125; “skew”是倾斜，“scale”是缩放，“rotate”是旋转，“translate”是平移。最后需要说明一点，transform 支持综合变换。 Animation 1234567891011121314151617@-webkit-keyframes anim1 &#123; 0% &#123; Opacity: 0; Font-size: 12px; &#125; 100% &#123; Opacity: 1; Font-size: 24px; &#125; &#125; .anim1Div &#123; -webkit-animation-name: anim1 ; -webkit-animation-duration: 1.5s; -webkit-animation-iteration-count: 4; -webkit-animation-direction: alternate; -webkit-animation-timing-function: ease-in-out; &#125; 首先，定义动画的内容，如清单 28 所示，定义动画“anim1”，变化方式为由“透明”（opacity: 0）变到“不透明”（opacity: 1），同时，内部字体大小由“12px”变到“24px”。然后，再来定义 animation 的变化参数，其中，“duration”表示动画持续时间，“iteration-count”表示动画重复次数，direction 表示动画执行完一次后方向的变化方式（如第一次从右向左，第二次则从左向右），最后，“timing-function”表示变化的模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[碰到的一些面试问题]]></title>
      <url>%2F2017%2F04%2F08%2F%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[position的值， relative和absolute分别是相对于谁进行定位的？ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 如何解决跨域问题 JSONP 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); &#125; createJs('jsonp.js'); box(&#123; 'name': 'test' &#125;); function box(json)&#123; alert(json.name); &#125;&lt;script&gt; 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 XML和JSON的区别？(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。 JSON对数据的描述性比XML较差。 (4).传输速度方面。 JSON的速度要远远快于XML。 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 创建ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新.123456789101112&lt;script type="text/javascript" &gt; var XHR = new XMLHttpRequest(); XHR.open( 'get', './a.php'); XHR.send(null); XHR.onreadystatechange = function () &#123; if ( XHR.readyState === 4 ) &#123; if ( XHR.status === 200 ) &#123; alert(XHR.responseText); &#125; &#125; &#125;&lt;script&gt; HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 对前端模块化的认识 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 12345define(function(require, exports, module) &#123; // 模块代码 &#125;); 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 12345678开启GPU加速-webkit-transform:transition3d(0,0,0)或者-webkit-transform:translateZ(0);，其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。 栈和队列的区别?栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 快速排序“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较12345678910111213141516171819var arr = [1,4,7,8,5,2,6]; function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; &#125; var num = Math.floor(arr.length / 2); var numValue = arr.splice(num, 1); var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; numValue) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(numValue,quickSort(right));//递归不断重复比较 &#125; console.log(quickSort(arr)); 你觉得jQuery或zepto源码有哪些写的好的地方jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; &#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 ES6的了解 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、 箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。let命令实际上就增加了块级作用域。 ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。 还有就是引入module模块的概念 Symbol数据类型 js继承方式及其优缺点 原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 浮动产生原因 一般是一个盒子里使用了CSS float浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了 清除方法 对父级设置适合CSS高度 clear:both清除浮动, 增加标签,不推荐使用. 在父盒子后添加一个空标签,标签样式为clear:both; 父级div定义 overflow:hidden 最高大上的伪元素清除12345678910.clearfix &#123; zoom:1; //兼容ie 6 7&#125;.clearfix:after &#123; content:".";display:block;height:0;clear:both; visibility:hidden;&#125; 用过哪些设计模式？ 工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。 12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () &#123; return this.name + ' at ' + this.age + ' engaged in ' + this.profession; &#125;; return obj;&#125;var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 1.构造函数方法没有显示的创建对象 (new Object()); 2.直接将属性和方法赋值给 this 对象; 3.没有 renturn 语句。 你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 弊端: 数量和长度的限制 IE6或更低版本最多20个cookie IE7和之后的版本最后可以有50个cookie。 Firefox最多50个cookie chrome和Safari没有做硬性限制 cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 优点: 极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别： 1. cookie数据存放在客户的浏览器上，session数据放在服务器上。 2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4. 个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cooki。 5. 所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 ## display:none和visibility:hidden的区别？ display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 ## position:absolute和float属性的异同 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 ## 介绍一下box-sizing属性？box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 - content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 - border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 ## CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 1. id选择器（ # myid） 2. 类选择器（.myclassname） 3. 标签选择器（div, h1, p） 4. 相邻选择器（h1 + p） 5. 子选择器（ul &gt; li） 6. 后代选择器（li a） 7. 通配符选择器（ * ） 8. 属性选择器（a[rel = &quot;external&quot;]） 9. 伪类选择器（a: hover, li:nth-child） 优先级 !important &gt; 内联 &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例：p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 CSS3有哪些新特性？CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认） 布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box 布局所占宽度Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) 对BFC规范的理解？BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 说说你对语义化的理解？1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构 2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 如何区分： DOCTYPE声明\新增的结构元素\功能元素 null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 new操作符具体干了什么呢?1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js ## 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） ## 列举IE 与其他浏览器不一样的特性？ IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 javascript对象的几种创建方式1，工厂模式 2，构造函数模式 3，原型模式 4，混合构造函数和原型模式 5，动态原型模式 6，寄生构造函数模式 7，稳妥构造函数模式 javascript继承的6种方法1，原型链继承 2，借用构造函数继承 3，组合继承(原型+借用构造) 4，原型式继承 5，寄生式继承 6，寄生组合式继承 GET和POST的区别，何时使用POST？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 ajax的缺点和在IE下的问题？ ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： var promise = new Promise(function(resolve, reject) { if (...) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制123456789101112Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === "object" ? this[e].clone() : this[e]; &#125; return o; &#125; 编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节12345678910 function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as")); 说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： 弱一致性（最终一致），更能保证用户的访问速度： 文档结构的存储方式，能够更便捷的获取数据。 attribute和property的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的 请解释什么是事件代理(事件委托)事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 说说你对MVC和MVVM的理解 MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack最基本的用法]]></title>
      <url>%2F2017%2F03%2F24%2Fwebpack%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[webpack安装webpack是所以Node.js开发的工具,可通过npm安装,首先要保证node已经安装完毕,可以去node官网下载, 然后通过npm下载webpack， webpack可以处理css/less，图片，json文件，js文件1npm install webpack -g 我们只需要webpack构建项目, 项目上线后是不需要依赖webpack的 所以我们在项目文件夹下安装时候可以安装在dev-dependencies中, 即:1npm install webpack --save-dev 在这里我们采用第一种安装方法 编写代码接下来我们使用webpack构建一个简单的hello word应用, 包括两个js模块 1 生成文本”Hello word”的hello模块(hello.js)1module.exports = &quot;Hello word&quot;; 2 打印文本的index模块(index.js), 入口模块12var text = require(&apos;./hello&apos;);console.log(text); 3 页面内容(index.html)12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入的bundle.js并不存在,他就是我们使用webpack构建出来的js文件现在我们的目录结构应该是这样的: index.jshello.jsindex.html 构建此时在项目文件夹下使用命令行工具(没有安装git可以按住shift右键,可以直接打开控制台)输入命令1webpack ./index bundle.js 这个命令会告诉webpack 将index.js作为项目入口文件进行构建, 并将结果输出为bundle.js, 然后在项目文件夹下就可以看到bundle.js文件了, 现在在浏览器中打开index.html文件就会在控制台看到输入Hello word了 bundle.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******//******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // identity function for calling harmony imports with the correct context/******/ __webpack_require__.i = function(value) &#123; return value; &#125;;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123;/******/ configurable: false,/******/ enumerable: true,/******/ get: getter/******/ &#125;);/******/ &#125;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = "";/******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = 1);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) &#123;module.exports = "hello word!";/***/ &#125;),/* 1 *//***/ (function(module, exports, __webpack_require__) &#123;var text = __webpack_require__(0);console.log(text);/***/ &#125;)/******/ ]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习（2）--类（class）]]></title>
      <url>%2F2017%2F03%2F22%2FES6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E7%B1%BB%EF%BC%88class%EF%BC%89%2F</url>
      <content type="text"><![CDATA[class类通过class关键字，可以定义类。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; constructor方法，这就是构造方法，而this关键字则代表实例对象。 ==一个类必须有constructor方法==，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 还有一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ==类的数据类型就是函数==，类本身就指向构造函数12typeof Point // "function"Point === Point.prototype.constructor // true 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，==类的所有方法都定义在类的prototype属性上面==。 类的使用方法和构造函数一样,通过new关键字新建12var cla = new Point(1,2);cla.toString(); // (12) Object.assign方法可以很方便地一次向类添加多个方法。12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); ==prototype对象的constructor属性，直接指向“类”的本身== ,类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 类的属性名可以用表达式 类的实例化对象通过new关键字创建 类的属性默认定义在原型上 this制定的定义在本身 类的所有实例共享一个原型对象 , 可以通过实例的__proto__属性为Class添加方法。原型上添加了一个方法后,所有的实例化对象都可以调用 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。12new Foo(); // ReferenceError 报错class Foo &#123;&#125; Class表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 采用Class表达式，可以写出立即执行的Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 私有方法利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向 类的方法内部的this默认指向类的实例,如果单独使用带this的方法会报错 12345678910111213 class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined class的继承Class之间可以通过extends关键字实现继承。1class ColorPiont extends Point&#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。123constructor(...args) &#123; super(...args);&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。 类的prototype属性和__proto__属性大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true Extends 的继承目标extends关键字后面可以跟多种类型的值。123class B extends A &#123; &#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 第二种情况，super作为对象时，指向父类的原型对象。1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 实例的proto属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 通过子类实例的proto.proto属性，可以修改父类实例的行为。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。 ==注意，继承Object的子类，有一个行为差异==1234567class NewObj extends Object&#123; constructor()&#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);console.log(o.attr === true); // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 父类的静态方法，可以被子类继承。12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' 静态方法也是可以从super对象上调用的。12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // hello, too Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。目前，只有这种写法可行，==因为ES6明确规定，Class内部只有静态方法，没有静态属性。== 类的私有属性目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示 , 私有属性可以指定初始值，在构造函数执行时进行初始化。它也可以用来写私有方法。 new.target属性Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见排序算法]]></title>
      <url>%2F2017%2F03%2F20%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[排序算法 冒泡排序 , 选择排序 , 插入排序, 快速排序 冒泡排序: 最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。 举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。 首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。 同理4和8交换，变成5,3,4,8,6,3和4无需交换。 5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。 对剩下的序列依次冒泡就会得到一个有序序列。 冒泡排序的时间复杂度为O(n^2)。 1234567891011121314var arr = [7,4,1,0,8,5,2,9,6,3];function fn(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; for(var j = 0; j&lt; arr.length - 1; j++) &#123; if (arr[i] &lt; arr[j])&#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;fn(arr); // [0,1,2,3,4,5,6,7,8,9] 选择排序 选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。- 举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序， 首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4. 对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。 其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序的时间复杂度为O(n^2)1234567891011121314151617function fn(arr) &#123; var min = 0; for (var i = 0; i &lt; arr.length - 1; i++) &#123; min = i; for (var j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; var temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 插入排序 插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。 举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序， 首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。 然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧 然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。 注意在插入一个数的时候要保证这个数前面的数已经有序。 简单插入排序的时间复杂度也是O(n^2)。123456789101112function fn(arr) &#123; for(var i = 1; i &lt; arr.length; i++) &#123; var j = i; var target = arr[i]; while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = target; &#125; return arr&#125; 快速排序 快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 12345678910111213141516function fn(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; pivot) &#123; right.push(arr[i]) &#125; else &#123; left.push(arr[i]) &#125; &#125; return fn(right).concat([pivot], fn(left))&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Require.js复习]]></title>
      <url>%2F2017%2F03%2F20%2FRequire-js%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[RequireJS解决代码依赖问题,异步加载js,避免页面失去相应 RequireJS的目标是鼓励代码的模块化，它使用了不同于传统&lt;script&gt;标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。RequireJS以一个相对于baseUrl的地址来加载所有的代码。 页面顶层&lt;script&gt;标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。 加载1&lt;script data-main="main" src="./require.js"&gt;&lt;/script&gt; 这里的mian是脚本的入口，相当于c语言的main()主函数, 所有的模块都要集中在这里被解析. 默认加载的都是js文件,所以就不用加.js1234&lt;script src="js1.js""&gt;&lt;/script&gt;&lt;script src="js2.js""&gt;&lt;/script&gt;&lt;script src="js3.js""&gt;&lt;/script&gt;&lt;script src="js4.js""&gt;&lt;/script&gt; 之前我们引用js代码就会是这样, 依赖顺序不能颠倒, 这样就非常麻烦, AMD规范1234 //AND规范的写法require(['依赖一', '依赖二', '依赖三'], function(依赖一的别名, 依赖三的别名, 依赖三的别名)&#123; //code &#125;) require很好的解决了这个代码依赖的问题,它采用AMD(异步模块加载)规范加载脚本文件.比如:1234require(['jquery', 'underscore', 'bankbone'], function($, _, Backbone) &#123; //code &#125;) 配置有的模块肯定是不符合AMD规范的,那么我们就需要配置一下,shim属性就是配置不符合AMD规范的代码的,require.config()参数是一个对象,写在页面的最顶部.123456789101112require.config(&#123; baseUrl: '路径', // 设置js文件的根目录,默认是main.js的目录,这里写相对与main.js的相对路径 paths: &#123; jquery: '路径' // 为每个文件单独指定路径, 也可以是网络地址 &#125; shim: &#123; '模块名': &#123; exports: '模块别名', deps: ['依赖一', '依赖二'] &#125; &#125;&#125;) AMD模块的写法1234define(['依赖'], function(依赖别名) &#123; //code &#125;) 12345678define(function(a, b) &#123; var add = function(a, b) &#123; return a + b; &#125; return add&#125;);//这样写只能返回一个方法//在main.js里用该模块的名字(a,b)调用 还可以用下面的方法写1234567891011121314define(function(a, b) &#123; var add = function(a, b) &#123; return a + b; &#125; var x = function(a, b) &#123; return a * b &#125; return &#123; add: add, x: x &#125;&#125;);//这样写只能返回多个方法//在main.js里用该模块的名字.add(a,b)或者模块名字.x(a,b)调用 模块的压缩合并 模块化的写法肯定会增加文件数量, 从而增加请求次数, 放慢加载速度, require有自带的压缩工具r.js, 可以合并所有模块为一个js文件. 可以去官网下载也可以使用bower下载1bower install r.js 下载完后在main.js的目录新建一个build.js文件(配置如下) 在build.js的文件目录下执行node r.js -o build.js 构建完后会有一个main-built.js文件 这里有一篇详细介绍打包的文章1234567891011121314151617181920212223242526272829(&#123; appDir: './', //项目根目录 out: 'main-build.js', //输出文件名 dir: './outdir', //输出目录，全部文件打包后要放入的文件夹（如果没有会自动新建的） /* 有了dir，就不能使用out配置项了，你在编译时它有非常明确的提示 */ baseUrl: './js/pages', //相对于appDir，代表要查找js文件的起始文件夹，下文所有文件路径的定义都是基于这个baseUrl的 modules: [ //要优化的模块 —— 里面的配置项即各页面的 相对baseUrl路径的 省略后缀“.js”的 入口文件(入口文件 ---- 即加载页面时引入require.js的script标签上data-main属性所指定的文件) //该属性必不可少，因为一个程序至少需要有一个入口 &#123; name:'main'&#125;, &#123; name:'index'&#125; ], fileExclusionRegExp: /^(r|build)\.js|.*\.scss$/, //正则匹配过滤文件，匹配到的文件将不会被输出到输出目录去，这里过滤掉的是 r.js、build.js、*.scss三类文件 optimizeCss: 'standard', removeCombined: true, //如果为true，优化器将从输出目录中删除已合并的文件 paths: &#123; //各模块相对baseUrl的路径，直接从require.config的path配置中烤取即可 "underscore": "../libs/underscore/underscore-min", "backbone": "../libs/backbone/backbone-min", &#125;, shim:&#123;// 配置不符合AMD规范的模块，直接从require.config的shim配置中烤取即可 "underscore": &#123; exports: "_" &#125;, "backbone": &#123; deps: ["underscore", "jquery"], exports: "Backbone" &#125;, &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6转码工具babel的使用]]></title>
      <url>%2F2017%2F03%2F14%2FES6%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Babel工具Babel CLI 是一个可以在命令行编译ES6的工具 安装方法 1npm install babel-cli -g 配置 Babel是通过安装插件(plugin)或者预设(preset)来编译代码的 先创建一个配置文件 .babelrc ,放置在项目根目录下 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 安装预设,把ES6编译成ES5. –save 可以把安装的包写进pageage.json的dependencies里,生产环境需要依赖的包 –save-dev 可以把安装的包写进pageage.json的devDependencies里,开发测试环境需要依赖的包 1npm install --save-dev babel-preset-es2015 修改配置文件 1234&#123; &quot;presets&quot;: [&apos;es2015&apos;], &quot;plugins&quot;: []&#125; 配置完毕,新建一个js文件demo.js,写一段代码实验一下 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [...arr, ...arr1];console.log(arr2); 命令窗口执行 1babel demo.js -o demo1.js 执行后代码变为ES5的代码 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [].concat(arr, arr1);console.log(arr2); 配置完毕,借助Babel,在现在的项目中就可以完全释放ES6的魔力了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一段自动转换rem的代码]]></title>
      <url>%2F2017%2F03%2F08%2F%E4%B8%80%E6%AE%B5%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2rem%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[写移动端页面的时候，引入这段js代码，就无须再担心不同屏幕的适配问题了一定要注意，移动端页面头部一定要引入&lt;meta name=&quot;viewport&quot; content=&quot;maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0&quot;/&gt; js代码12345678910111213(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; //这里的640 是根据设计稿的宽度来订的，设计稿宽度如果是750，64就改成750，很简单 &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自制图标字体]]></title>
      <url>%2F2017%2F03%2F04%2F%E8%87%AA%E5%88%B6%E5%9B%BE%E6%A0%87%E5%AD%97%E4%BD%93%2F</url>
      <content type="text"><![CDATA[生成自定义图标字体借助在线生成工具[IcoMoon](https://icomoon.io/) 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 ，白色表示选中 自定义的可以用AI直接画出来然后保存为svg格式 还可以用ps的自定义形状工具导出ai路径，然后用ai打开保存为svg文件 png图片就没必要转换了 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 点击Generate Fonte进入设置页面，图标后面为字体的名字 点击download按钮下载至本地，接下后只需这两个文件，拷贝至项目文件夹下 使用图标字体 在页面引入style.css&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt; 给标签加类名就可以所以图标字体&lt;span class=&quot;icon-dengpao&quot;&gt;&lt;/span&gt; 可以随意修改图标字体的大小颜色文 章 随 便 转 载 ，请 注 明 出 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习（1）]]></title>
      <url>%2F2017%2F02%2F28%2FES6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[ES6解构赋值1var [a, b, c] = [1,2,3] 左右要严格一一对应 左边格式不正确，var [a,d] = [1,2,3]可以解构成功，属于不完全解构 右边格式不正确，var [a,b,c,d] = [1,2,3] 解构成功，左边对应的值为undefined 如果右边的不是数组（不可遍历的解构）var [a] = 12; ，会报错 只要某种数据结构具有 Iterator(迭代器) 接口，都可以采用数组形式的解构赋值 Iterator(迭代器) 接口：在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构 默认值 var [a = 1] = [undefined] // a = 1 , var [a = 1] = [null]; // a = nullES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值 12345function f() &#123; console.log('aaa'); &#125; let [x = f()] = [1]; //x可以取到值，f()不会执行 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明 对象也可以解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 字符串的解构赋值 数值和布尔值的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值 圆括号问题 变量声明语句中，不能带有圆括号。 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 字符串拓展 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat();返回一个新字符串，表示将原字符串重复n次。 &#39;hello&#39;.repeat(2) // &quot;hellohello&quot; 参数如果是小数，会被取整。&#39;na&#39;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity(无限大)，会报错。 参数NaN等同于0 如果repeat的参数是字符串，则会先转换成数字。 padStart()，padEnd() 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串 传统模版字符串 123456 $('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); ES6模版字符串 12345 $('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213 // 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量,var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用trim方法消除它。 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串 模板字符串甚至还能嵌套]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（2）]]></title>
      <url>%2F2017%2F02%2F28%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[组件类首字母必须大写 HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）.只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 React.createClass 方法就用于生成一个组件类 组件类只能包含一个顶层标签 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.children this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点 this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array 。 所以，处理 this.props.children 的时候要小心。 PropTypes 组件的属性可以接受任意值，字符串、对象、函数等等都可以。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 getDefaultProps 方法可以用来设置组件属性的默认值。12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : &apos;Hello World&apos; &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 获取真实DOM 123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); 组件必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 this.stste 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;)); getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 组件的生命周期 组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() React 还提供两种特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next底部powered-by的logo栏更改以及注意事项（附官方文档,文末有福利链）]]></title>
      <url>%2F2017%2F02%2F27%2FHexo-Next%E5%BA%95%E9%83%A8powered-by%E7%9A%84logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E9%99%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E6%96%87%E6%9C%AB%E6%9C%89%E7%A6%8F%E5%88%A9%E9%93%BE%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Hexo-Next底部logo栏更改以及注意事项（附官方文档）昨晚研究了hexo，搭建博客很方便，主题，插件化功能非常强大。 本篇文章适合对象：各位用的是Next主题，那么适合看本篇文章，如果别的主题想找思路的适合看看练练手。想学习基础更改，优化，简单配置请看 点击官方文档。这里面有基础的教程以及第三方能用到的插件都有介绍，都是傻瓜式操作。PS:做插件化的朋友，请注意，站内搜索swiftype只有老用户才免费，新用户只有14天之后收费，RMB玩家可以略过，其他小伙伴可以选择Local Search，本站右上角就是Local Search，精准度还可以没有swiftype准，用用再说。搭建LocalSearch 方法如下： search 如果有其他好的插件和优化方法，我更新本片博文，当然大家有好点，好工具也希望邮件私信我，一同来分享，帮助大家打造富有个性化的博客。 问题说明用Next主题搭建起来的博客，在底部会有一个特别烦人的官方logo， oldlogo对于强迫症的我必须要改掉、改掉、改掉！查遍了所有文章都没有告诉，遂打算自己写一篇，有需要的可以看看。（含泪阅读了Next所有的源文件，最后不过是两句话能说明白。。却耗费我3,4个小时，让我多说一会废话凑凑字数吧，都是眼泪啊！） 成果展示 newlogo看起来至少比原来的好多了，更有个性化风格。 解决方案重点来啦。 1.首先，找到 \themes\next\layout_partials\下面的footer.swig文件，打开会发现，如下图的语句： config 看到划框的地方了吗？ 第一个框 是下面侧栏的“日期❤ XXX”如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 2.接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）打开之后，如图：foot看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 到此就可以pu上去了，等待2分钟就搞定了。有的时候可能有延迟。快去改掉那些不属于你的元素吧。 更多推荐，打造个性博客更多主题：http://hexo.io/themes/博客图标网（就是我导航条的小图标）：http://fontawesome.io/icons/文章转自Codeagles的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（1）]]></title>
      <url>%2F2017%2F02%2F27%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[react特性- 虚拟DOM - 组件化 borwser.js 将JSX语法转换为js语法 react.js 核心库 react-dom.js 提供与dom有关的功能123&lt;script type="text/bable"&gt; //bable 转换编译器 &lt;/script&gt; JSX语法 借助React环境运行 jsx标签就是HTML标签 jsx语法转换， jsx -&gt; js 在jsx中运行js代码，js代码要用｛｝括起来 属性，设置样式，事件绑定 组件类 大写开头，驼峰命名 React.createClass（｛｝）方法创建组建类 每个组件必须实现自己的render方法，输入一个定义好的模版；返回值为null，false，组件模版 只能包含一个顶层标签123456789101112 var HelloReact = React.createClass(&#123; render:function()&#123; return ( &lt;h1&gt;组件&lt;/h1&gt; &lt;p&gt;内容&lt;/p&gt; ) &#125; &#125;) ReactDOM.render（ &lt;HelloReact /&gt;, document.getElementById(&quot;id&quot;);） 组件样式- 内联样式 - 对象样式 - 选择器样式 以，结尾；HTML以；结尾 key，中不能出现“-” key驼峰命名 value如果是字符串要加引号 value是数字，不需要带单位1234567891011121314151617181920212223242526//这个样式需要写在头部的style标签之内.xzq ｛ background: #fff;｝//样式对象var sty = &#123; height: 100, background: &apos;#f0f&apos;&#125;var HelloReact = React.createClass(&#123; render: function()&#123; return ( //内联样式 &lt;div style=&#123;&#123;background:&apos;#f00&apos;,height: 200&#125;&#125;&gt;内联样式和 //对象样式 &lt;div style=&#123;sty&#125;&gt;对象样式&lt;/div&gt; //选择器样式 &lt;div className=&quot;a&quot;&gt;选择器样式&lt;/div&gt; &lt;/div&gt;); &#125;&#125;);//渲染标签ReactDOM.render( &lt;HelloReact /&gt;, document.getElementById(&apos;container&apos;) ) 复合组件创建多个组建合成一个组建，首先定义子组件，然后定义复合组件 12345678910111213141516171819202122232425var WebName = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;蓝天白云&lt;/h1&gt; &#125;&#125;) var WebLink = React.createClass(&#123; render: function()&#123; return &lt;a href=&quot;#&quot;&gt;www.yuanjingzhuang.com&lt;/a&gt; &#125;&#125;)var WenShow = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;WebName/&gt; &lt;WebLink/&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;WenShow /&gt;, document.getElementById(&quot;container&quot;) )]]></content>
    </entry>

    
  
  
</search>
