<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[webpack最基本的用法]]></title>
      <url>%2F2017%2F03%2F24%2Fwebpack%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[webpack安装webpack是所以Node.js开发的工具,可通过npm安装,首先要保证node已经安装完毕,可以去node官网下载, 然后通过npm下载webpack， webpack可以处理css/less，图片，json文件，js文件1npm install webpack -g 我们只需要webpack构建项目, 项目上线后是不需要依赖webpack的 所以我们在项目文件夹下安装时候可以安装在dev-dependencies中, 即:1npm install webpack --save-dev 在这里我们采用第一种安装方法 编写代码接下来我们使用webpack构建一个简单的hello word应用, 包括两个js模块 1 生成文本”Hello word”的hello模块(hello.js)1module.exports = &quot;Hello word&quot;; 2 打印文本的index模块(index.js), 入口模块12var text = require(&apos;./hello&apos;);console.log(text); 3 页面内容(index.html)12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入的bundle.js并不存在,他就是我们使用webpack构建出来的js文件现在我们的目录结构应该是这样的: index.jshello.jsindex.html 构建此时在项目文件夹下使用命令行工具(没有安装git可以按住shift右键,可以直接打开控制台)输入命令1webpack ./index bundle.js 这个命令会告诉webpack 将index.js作为项目入口文件进行构建, 并将结果输出为bundle.js, 然后在项目文件夹下就可以看到bundle.js文件了, 现在在浏览器中打开index.html文件就会在控制台看到输入Hello word了 bundle.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******//******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // identity function for calling harmony imports with the correct context/******/ __webpack_require__.i = function(value) &#123; return value; &#125;;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123;/******/ configurable: false,/******/ enumerable: true,/******/ get: getter/******/ &#125;);/******/ &#125;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = "";/******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = 1);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) &#123;module.exports = "hello word!";/***/ &#125;),/* 1 *//***/ (function(module, exports, __webpack_require__) &#123;var text = __webpack_require__(0);console.log(text);/***/ &#125;)/******/ ]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习（2）--类（class）]]></title>
      <url>%2F2017%2F03%2F22%2FES6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E7%B1%BB%EF%BC%88class%EF%BC%89%2F</url>
      <content type="text"><![CDATA[class类通过class关键字，可以定义类。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; constructor方法，这就是构造方法，而this关键字则代表实例对象。 ==一个类必须有constructor方法==，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 还有一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ==类的数据类型就是函数==，类本身就指向构造函数12typeof Point // "function"Point === Point.prototype.constructor // true 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，==类的所有方法都定义在类的prototype属性上面==。 类的使用方法和构造函数一样,通过new关键字新建12var cla = new Point(1,2);cla.toString(); // (12) Object.assign方法可以很方便地一次向类添加多个方法。12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); ==prototype对象的constructor属性，直接指向“类”的本身== ,类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 类的属性名可以用表达式 类的实例化对象通过new关键字创建 类的属性默认定义在原型上 this制定的定义在本身 类的所有实例共享一个原型对象 , 可以通过实例的__proto__属性为Class添加方法。原型上添加了一个方法后,所有的实例化对象都可以调用 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。12new Foo(); // ReferenceError 报错class Foo &#123;&#125; Class表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 采用Class表达式，可以写出立即执行的Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 私有方法利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向 类的方法内部的this默认指向类的实例,如果单独使用带this的方法会报错 12345678910111213 class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined class的继承Class之间可以通过extends关键字实现继承。1class ColorPiont extends Point&#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。123constructor(...args) &#123; super(...args);&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。 类的prototype属性和__proto__属性大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true Extends 的继承目标extends关键字后面可以跟多种类型的值。123class B extends A &#123; &#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 第二种情况，super作为对象时，指向父类的原型对象。1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 实例的proto属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, 'red');p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 通过子类实例的proto.proto属性，可以修改父类实例的行为。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。 ==注意，继承Object的子类，有一个行为差异==1234567class NewObj extends Object&#123; constructor()&#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);console.log(o.attr === true); // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 父类的静态方法，可以被子类继承。12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' 静态方法也是可以从super对象上调用的。12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); // hello, too Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。目前，只有这种写法可行，==因为ES6明确规定，Class内部只有静态方法，没有静态属性。== 类的私有属性目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示 , 私有属性可以指定初始值，在构造函数执行时进行初始化。它也可以用来写私有方法。 new.target属性Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见排序算法]]></title>
      <url>%2F2017%2F03%2F20%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[排序算法 冒泡排序 , 选择排序 , 插入排序, 快速排序 冒泡排序: 最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。 举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。 首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。 同理4和8交换，变成5,3,4,8,6,3和4无需交换。 5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。 对剩下的序列依次冒泡就会得到一个有序序列。 冒泡排序的时间复杂度为O(n^2)。 1234567891011121314var arr = [7,4,1,0,8,5,2,9,6,3];function fn(arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; for(var j = 0; j&lt; arr.length - 1; j++) &#123; if (arr[i] &lt; arr[j])&#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;fn(arr); // [0,1,2,3,4,5,6,7,8,9] 选择排序 选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。- 举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序， 首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4. 对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。 其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。 选择排序的时间复杂度为O(n^2)1234567891011121314151617function fn(arr) &#123; var min = 0; for (var i = 0; i &lt; arr.length - 1; i++) &#123; min = i; for (var j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; var temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 插入排序 插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。 举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序， 首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。 然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧 然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。 注意在插入一个数的时候要保证这个数前面的数已经有序。 简单插入排序的时间复杂度也是O(n^2)。123456789101112function fn(arr) &#123; for(var i = 1; i &lt; arr.length; i++) &#123; var j = i; var target = arr[i]; while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) &#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = target; &#125; return arr&#125; 快速排序 快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 12345678910111213141516function fn(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; pivot) &#123; right.push(arr[i]) &#125; else &#123; left.push(arr[i]) &#125; &#125; return fn(right).concat([pivot], fn(left))&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Require.js复习]]></title>
      <url>%2F2017%2F03%2F20%2FRequire-js%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[RequireJS解决代码依赖问题,异步加载js,避免页面失去相应 RequireJS的目标是鼓励代码的模块化，它使用了不同于传统&lt;script&gt;标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。RequireJS以一个相对于baseUrl的地址来加载所有的代码。 页面顶层&lt;script&gt;标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。 加载1&lt;script data-main="main" src="./require.js"&gt;&lt;/script&gt; 这里的mian是脚本的入口，相当于c语言的main()主函数, 所有的模块都要集中在这里被解析. 默认加载的都是js文件,所以就不用加.js1234&lt;script src="js1.js""&gt;&lt;/script&gt;&lt;script src="js2.js""&gt;&lt;/script&gt;&lt;script src="js3.js""&gt;&lt;/script&gt;&lt;script src="js4.js""&gt;&lt;/script&gt; 之前我们引用js代码就会是这样, 依赖顺序不能颠倒, 这样就非常麻烦, AMD规范1234 //AND规范的写法require(['依赖一', '依赖二', '依赖三'], function(依赖一的别名, 依赖三的别名, 依赖三的别名)&#123; //code &#125;) require很好的解决了这个代码依赖的问题,它采用AMD(异步模块加载)规范加载脚本文件.比如:1234require(['jquery', 'underscore', 'bankbone'], function($, _, Backbone) &#123; //code &#125;) 配置有的模块肯定是不符合AMD规范的,那么我们就需要配置一下,shim属性就是配置不符合AMD规范的代码的,require.config()参数是一个对象,写在页面的最顶部.123456789101112require.config(&#123; baseUrl: '路径', // 设置js文件的根目录,默认是main.js的目录,这里写相对与main.js的相对路径 paths: &#123; jquery: '路径' // 为每个文件单独指定路径, 也可以是网络地址 &#125; shim: &#123; '模块名': &#123; exports: '模块别名', deps: ['依赖一', '依赖二'] &#125; &#125;&#125;) AMD模块的写法1234define(['依赖'], function(依赖别名) &#123; //code &#125;) 12345678define(function(a, b) &#123; var add = function(a, b) &#123; return a + b; &#125; return add&#125;);//这样写只能返回一个方法//在main.js里用该模块的名字(a,b)调用 还可以用下面的方法写1234567891011121314define(function(a, b) &#123; var add = function(a, b) &#123; return a + b; &#125; var x = function(a, b) &#123; return a * b &#125; return &#123; add: add, x: x &#125;&#125;);//这样写只能返回多个方法//在main.js里用该模块的名字.add(a,b)或者模块名字.x(a,b)调用 模块的压缩合并 模块化的写法肯定会增加文件数量, 从而增加请求次数, 放慢加载速度, require有自带的压缩工具r.js, 可以合并所有模块为一个js文件. 可以去官网下载也可以使用bower下载1bower install r.js 下载完后在main.js的目录新建一个build.js文件(配置如下) 在build.js的文件目录下执行node r.js -o build.js 构建完后会有一个main-built.js文件 这里有一篇详细介绍打包的文章1234567891011121314151617181920212223242526272829(&#123; appDir: './', //项目根目录 out: 'main-build.js', //输出文件名 dir: './outdir', //输出目录，全部文件打包后要放入的文件夹（如果没有会自动新建的） /* 有了dir，就不能使用out配置项了，你在编译时它有非常明确的提示 */ baseUrl: './js/pages', //相对于appDir，代表要查找js文件的起始文件夹，下文所有文件路径的定义都是基于这个baseUrl的 modules: [ //要优化的模块 —— 里面的配置项即各页面的 相对baseUrl路径的 省略后缀“.js”的 入口文件(入口文件 ---- 即加载页面时引入require.js的script标签上data-main属性所指定的文件) //该属性必不可少，因为一个程序至少需要有一个入口 &#123; name:'main'&#125;, &#123; name:'index'&#125; ], fileExclusionRegExp: /^(r|build)\.js|.*\.scss$/, //正则匹配过滤文件，匹配到的文件将不会被输出到输出目录去，这里过滤掉的是 r.js、build.js、*.scss三类文件 optimizeCss: 'standard', removeCombined: true, //如果为true，优化器将从输出目录中删除已合并的文件 paths: &#123; //各模块相对baseUrl的路径，直接从require.config的path配置中烤取即可 "underscore": "../libs/underscore/underscore-min", "backbone": "../libs/backbone/backbone-min", &#125;, shim:&#123;// 配置不符合AMD规范的模块，直接从require.config的shim配置中烤取即可 "underscore": &#123; exports: "_" &#125;, "backbone": &#123; deps: ["underscore", "jquery"], exports: "Backbone" &#125;, &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6转码工具babel的使用]]></title>
      <url>%2F2017%2F03%2F14%2FES6%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Babel工具Babel CLI 是一个可以在命令行编译ES6的工具 安装方法 1npm install babel-cli -g 配置 Babel是通过安装插件(plugin)或者预设(preset)来编译代码的 先创建一个配置文件 .babelrc ,放置在项目根目录下 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 安装预设,把ES6编译成ES5. –save 可以把安装的包写进pageage.json的dependencies里,生产环境需要依赖的包 –save-dev 可以把安装的包写进pageage.json的devDependencies里,开发测试环境需要依赖的包 1npm install --save-dev babel-preset-es2015 修改配置文件 1234&#123; &quot;presets&quot;: [&apos;es2015&apos;], &quot;plugins&quot;: []&#125; 配置完毕,新建一个js文件demo.js,写一段代码实验一下 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [...arr, ...arr1];console.log(arr2); 命令窗口执行 1babel demo.js -o demo1.js 执行后代码变为ES5的代码 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [].concat(arr, arr1);console.log(arr2); 配置完毕,借助Babel,在现在的项目中就可以完全释放ES6的魔力了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一段自动转换rem的代码]]></title>
      <url>%2F2017%2F03%2F08%2F%E4%B8%80%E6%AE%B5%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2rem%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[写移动端页面的时候，引入这段js代码，就无须再担心不同屏幕的适配问题了一定要注意，移动端页面头部一定要引入&lt;meta name=&quot;viewport&quot; content=&quot;maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0&quot;/&gt; js代码12345678910111213(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; //这里的640 是根据设计稿的宽度来订的，设计稿宽度如果是750，64就改成750，很简单 &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自制图标字体]]></title>
      <url>%2F2017%2F03%2F04%2F%E8%87%AA%E5%88%B6%E5%9B%BE%E6%A0%87%E5%AD%97%E4%BD%93%2F</url>
      <content type="text"><![CDATA[生成自定义图标字体借助在线生成工具[IcoMoon](https://icomoon.io/) 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 ，白色表示选中 自定义的可以用AI直接画出来然后保存为svg格式 还可以用ps的自定义形状工具导出ai路径，然后用ai打开保存为svg文件 png图片就没必要转换了 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 点击Generate Fonte进入设置页面，图标后面为字体的名字 点击download按钮下载至本地，接下后只需这两个文件，拷贝至项目文件夹下 使用图标字体 在页面引入style.css&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt; 给标签加类名就可以所以图标字体&lt;span class=&quot;icon-dengpao&quot;&gt;&lt;/span&gt; 可以随意修改图标字体的大小颜色文 章 随 便 转 载 ，请 注 明 出 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习（1）]]></title>
      <url>%2F2017%2F02%2F28%2FES6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[ES6解构赋值1var [a, b, c] = [1,2,3] 左右要严格一一对应 左边格式不正确，var [a,d] = [1,2,3]可以解构成功，属于不完全解构 右边格式不正确，var [a,b,c,d] = [1,2,3] 解构成功，左边对应的值为undefined 如果右边的不是数组（不可遍历的解构）var [a] = 12; ，会报错 只要某种数据结构具有 Iterator(迭代器) 接口，都可以采用数组形式的解构赋值 Iterator(迭代器) 接口：在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构 默认值 var [a = 1] = [undefined] // a = 1 , var [a = 1] = [null]; // a = nullES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值 12345function f() &#123; console.log('aaa'); &#125; let [x = f()] = [1]; //x可以取到值，f()不会执行 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明 对象也可以解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 字符串的解构赋值 数值和布尔值的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值 圆括号问题 变量声明语句中，不能带有圆括号。 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 字符串拓展 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat();返回一个新字符串，表示将原字符串重复n次。 &#39;hello&#39;.repeat(2) // &quot;hellohello&quot; 参数如果是小数，会被取整。&#39;na&#39;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity(无限大)，会报错。 参数NaN等同于0 如果repeat的参数是字符串，则会先转换成数字。 padStart()，padEnd() 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串 传统模版字符串 123456 $('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); ES6模版字符串 12345 $('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213 // 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量,var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用trim方法消除它。 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串 模板字符串甚至还能嵌套]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（2）]]></title>
      <url>%2F2017%2F02%2F28%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[组件类首字母必须大写 HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）.只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 React.createClass 方法就用于生成一个组件类 组件类只能包含一个顶层标签 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.children this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点 this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array 。 所以，处理 this.props.children 的时候要小心。 PropTypes 组件的属性可以接受任意值，字符串、对象、函数等等都可以。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 getDefaultProps 方法可以用来设置组件属性的默认值。12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : &apos;Hello World&apos; &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 获取真实DOM 123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); 组件必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 this.stste 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;)); getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 组件的生命周期 组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() React 还提供两种特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next底部powered-by的logo栏更改以及注意事项（附官方文档,文末有福利链）]]></title>
      <url>%2F2017%2F02%2F27%2FHexo-Next%E5%BA%95%E9%83%A8powered-by%E7%9A%84logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E9%99%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E6%96%87%E6%9C%AB%E6%9C%89%E7%A6%8F%E5%88%A9%E9%93%BE%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Hexo-Next底部logo栏更改以及注意事项（附官方文档）昨晚研究了hexo，搭建博客很方便，主题，插件化功能非常强大。 本篇文章适合对象：各位用的是Next主题，那么适合看本篇文章，如果别的主题想找思路的适合看看练练手。想学习基础更改，优化，简单配置请看 点击官方文档。这里面有基础的教程以及第三方能用到的插件都有介绍，都是傻瓜式操作。PS:做插件化的朋友，请注意，站内搜索swiftype只有老用户才免费，新用户只有14天之后收费，RMB玩家可以略过，其他小伙伴可以选择Local Search，本站右上角就是Local Search，精准度还可以没有swiftype准，用用再说。搭建LocalSearch 方法如下： search 如果有其他好的插件和优化方法，我更新本片博文，当然大家有好点，好工具也希望邮件私信我，一同来分享，帮助大家打造富有个性化的博客。 问题说明用Next主题搭建起来的博客，在底部会有一个特别烦人的官方logo， oldlogo对于强迫症的我必须要改掉、改掉、改掉！查遍了所有文章都没有告诉，遂打算自己写一篇，有需要的可以看看。（含泪阅读了Next所有的源文件，最后不过是两句话能说明白。。却耗费我3,4个小时，让我多说一会废话凑凑字数吧，都是眼泪啊！） 成果展示 newlogo看起来至少比原来的好多了，更有个性化风格。 解决方案重点来啦。 1.首先，找到 \themes\next\layout_partials\下面的footer.swig文件，打开会发现，如下图的语句： config 看到划框的地方了吗？ 第一个框 是下面侧栏的“日期❤ XXX”如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 2.接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）打开之后，如图：foot看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 到此就可以pu上去了，等待2分钟就搞定了。有的时候可能有延迟。快去改掉那些不属于你的元素吧。 更多推荐，打造个性博客更多主题：http://hexo.io/themes/博客图标网（就是我导航条的小图标）：http://fontawesome.io/icons/文章转自Codeagles的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（1）]]></title>
      <url>%2F2017%2F02%2F27%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[react特性- 虚拟DOM - 组件化 borwser.js 将JSX语法转换为js语法 react.js 核心库 react-dom.js 提供与dom有关的功能123&lt;script type="text/bable"&gt; //bable 转换编译器 &lt;/script&gt; JSX语法 借助React环境运行 jsx标签就是HTML标签 jsx语法转换， jsx -&gt; js 在jsx中运行js代码，js代码要用｛｝括起来 属性，设置样式，事件绑定 组件类 大写开头，驼峰命名 React.createClass（｛｝）方法创建组建类 每个组件必须实现自己的render方法，输入一个定义好的模版；返回值为null，false，组件模版 只能包含一个顶层标签123456789101112 var HelloReact = React.createClass(&#123; render:function()&#123; return ( &lt;h1&gt;组件&lt;/h1&gt; &lt;p&gt;内容&lt;/p&gt; ) &#125; &#125;) ReactDOM.render（ &lt;HelloReact /&gt;, document.getElementById(&quot;id&quot;);） 组件样式- 内联样式 - 对象样式 - 选择器样式 以，结尾；HTML以；结尾 key，中不能出现“-” key驼峰命名 value如果是字符串要加引号 value是数字，不需要带单位1234567891011121314151617181920212223242526//这个样式需要写在头部的style标签之内.xzq ｛ background: #fff;｝//样式对象var sty = &#123; height: 100, background: &apos;#f0f&apos;&#125;var HelloReact = React.createClass(&#123; render: function()&#123; return ( //内联样式 &lt;div style=&#123;&#123;background:&apos;#f00&apos;,height: 200&#125;&#125;&gt;内联样式和 //对象样式 &lt;div style=&#123;sty&#125;&gt;对象样式&lt;/div&gt; //选择器样式 &lt;div className=&quot;a&quot;&gt;选择器样式&lt;/div&gt; &lt;/div&gt;); &#125;&#125;);//渲染标签ReactDOM.render( &lt;HelloReact /&gt;, document.getElementById(&apos;container&apos;) ) 复合组件创建多个组建合成一个组建，首先定义子组件，然后定义复合组件 12345678910111213141516171819202122232425var WebName = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;蓝天白云&lt;/h1&gt; &#125;&#125;) var WebLink = React.createClass(&#123; render: function()&#123; return &lt;a href=&quot;#&quot;&gt;www.yuanjingzhuang.com&lt;/a&gt; &#125;&#125;)var WenShow = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;WebName/&gt; &lt;WebLink/&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;WenShow /&gt;, document.getElementById(&quot;container&quot;) )]]></content>
    </entry>

    
  
  
</search>
