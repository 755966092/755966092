<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ES6转码工具babel的使用]]></title>
      <url>%2F2017%2F03%2F14%2FES6%E8%BD%AC%E7%A0%81%E5%B7%A5%E5%85%B7babel%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Babel工具Babel CLI 是一个可以在命令行编译ES6的工具 安装方法 1npm install babel-cli -g 配置 Babel是通过安装插件(plugin)或者预设(preset)来编译代码的 先创建一个配置文件 .babelrc ,放置在项目根目录下 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 安装预设,把ES6编译成ES5. –save 可以把安装的包写进pageage.json的dependencies里,生产环境需要依赖的包 –save-dev 可以把安装的包写进pageage.json的devDependencies里,开发测试环境需要依赖的包 1npm install --save-dev babel-preset-es2015 修改配置文件 1234&#123; &quot;presets&quot;: [&apos;es2015&apos;], &quot;plugins&quot;: []&#125; 配置完毕,新建一个js文件demo.js,写一段代码实验一下 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [...arr, ...arr1];console.log(arr2); 命令窗口执行 1babel demo.js -o demo1.js 执行后代码变为ES5的代码 1234var arr = [1, 2, 3];var arr1 = [4, 5, 6];var arr2 = [].concat(arr, arr1);console.log(arr2); 配置完毕,借助Babel,在现在的项目中就可以完全释放ES6的魔力了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一段自动转换rem的代码]]></title>
      <url>%2F2017%2F03%2F08%2F%E4%B8%80%E6%AE%B5%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2rem%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[写移动端页面的时候，引入这段js代码，就无须再担心不同屏幕的适配问题了一定要注意，移动端页面头部一定要引入&lt;meta name=&quot;viewport&quot; content=&quot;maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0&quot;/&gt; js代码12345678910111213(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; //这里的640 是根据设计稿的宽度来订的，设计稿宽度如果是750，64就改成750，很简单 &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自制图标字体]]></title>
      <url>%2F2017%2F03%2F04%2F%E8%87%AA%E5%88%B6%E5%9B%BE%E6%A0%87%E5%AD%97%E4%BD%93%2F</url>
      <content type="text"><![CDATA[生成自定义图标字体借助在线生成工具[IcoMoon](https://icomoon.io/) 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 ，白色表示选中 自定义的可以用AI直接画出来然后保存为svg格式 还可以用ps的自定义形状工具导出ai路径，然后用ai打开保存为svg文件 png图片就没必要转换了 单击 import icons 按钮 导入我们准备好的svg 图标，或者Add Icons From Library引用这个网站上的一些现成图标 点击Generate Fonte进入设置页面，图标后面为字体的名字 点击download按钮下载至本地，接下后只需这两个文件，拷贝至项目文件夹下 使用图标字体 在页面引入style.css&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt; 给标签加类名就可以所以图标字体&lt;span class=&quot;icon-dengpao&quot;&gt;&lt;/span&gt; 可以随意修改图标字体的大小颜色文 章 随 便 转 载 ，请 注 明 出 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6学习（1）]]></title>
      <url>%2F2017%2F02%2F28%2FES6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[ES6解构赋值1var [a, b, c] = [1,2,3] 左右要严格一一对应 左边格式不正确，var [a,d] = [1,2,3]可以解构成功，属于不完全解构 右边格式不正确，var [a,b,c,d] = [1,2,3] 解构成功，左边对应的值为undefined 如果右边的不是数组（不可遍历的解构）var [a] = 12; ，会报错 只要某种数据结构具有 Iterator(迭代器) 接口，都可以采用数组形式的解构赋值 Iterator(迭代器) 接口：在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构 默认值 var [a = 1] = [undefined] // a = 1 , var [a = 1] = [null]; // a = nullES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值 12345function f() &#123; console.log('aaa'); &#125; let [x = f()] = [1]; //x可以取到值，f()不会执行 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明 对象也可以解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 字符串的解构赋值 数值和布尔值的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 函数参数的解构赋值 圆括号问题 变量声明语句中，不能带有圆括号。 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数中，模式不能带有圆括号。 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 字符串拓展 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat();返回一个新字符串，表示将原字符串重复n次。 &#39;hello&#39;.repeat(2) // &quot;hellohello&quot; 参数如果是小数，会被取整。&#39;na&#39;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity(无限大)，会报错。 参数NaN等同于0 如果repeat的参数是字符串，则会先转换成数字。 padStart()，padEnd() 字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串 传统模版字符串 123456 $('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); ES6模版字符串 12345 $('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213 // 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量,var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果你不想要这个换行，可以使用trim方法消除它。 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串 模板字符串甚至还能嵌套]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（2）]]></title>
      <url>%2F2017%2F02%2F28%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[组件类首字母必须大写 HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）.只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 React.createClass 方法就用于生成一个组件类 组件类只能包含一个顶层标签 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.children this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点 this.props.children 的值有三种可能： 如果当前组件没有子节点，它就是 undefined ; 如果有一个子节点，数据类型是 object ； 如果有多个子节点，数据类型就是 array 。 所以，处理 this.props.children 的时候要小心。 PropTypes 组件的属性可以接受任意值，字符串、对象、函数等等都可以。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 getDefaultProps 方法可以用来设置组件属性的默认值。12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : &apos;Hello World&apos; &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125;); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 获取真实DOM 123456789101112131415161718var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;)); 组件必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 this.stste 123456789101112131415161718192021var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;)); getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 组件的生命周期 组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() React 还提供两种特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next底部powered-by的logo栏更改以及注意事项（附官方文档,文末有福利链）]]></title>
      <url>%2F2017%2F02%2F27%2FHexo-Next%E5%BA%95%E9%83%A8powered-by%E7%9A%84logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E9%99%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E6%96%87%E6%9C%AB%E6%9C%89%E7%A6%8F%E5%88%A9%E9%93%BE%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Hexo-Next底部logo栏更改以及注意事项（附官方文档）昨晚研究了hexo，搭建博客很方便，主题，插件化功能非常强大。 本篇文章适合对象：各位用的是Next主题，那么适合看本篇文章，如果别的主题想找思路的适合看看练练手。想学习基础更改，优化，简单配置请看 点击官方文档。这里面有基础的教程以及第三方能用到的插件都有介绍，都是傻瓜式操作。PS:做插件化的朋友，请注意，站内搜索swiftype只有老用户才免费，新用户只有14天之后收费，RMB玩家可以略过，其他小伙伴可以选择Local Search，本站右上角就是Local Search，精准度还可以没有swiftype准，用用再说。搭建LocalSearch 方法如下： search 如果有其他好的插件和优化方法，我更新本片博文，当然大家有好点，好工具也希望邮件私信我，一同来分享，帮助大家打造富有个性化的博客。 问题说明用Next主题搭建起来的博客，在底部会有一个特别烦人的官方logo， oldlogo对于强迫症的我必须要改掉、改掉、改掉！查遍了所有文章都没有告诉，遂打算自己写一篇，有需要的可以看看。（含泪阅读了Next所有的源文件，最后不过是两句话能说明白。。却耗费我3,4个小时，让我多说一会废话凑凑字数吧，都是眼泪啊！） 成果展示 newlogo看起来至少比原来的好多了，更有个性化风格。 解决方案重点来啦。 1.首先，找到 \themes\next\layout_partials\下面的footer.swig文件，打开会发现，如下图的语句： config 看到划框的地方了吗？ 第一个框 是下面侧栏的“日期❤ XXX”如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 2.接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）打开之后，如图：foot看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 到此就可以pu上去了，等待2分钟就搞定了。有的时候可能有延迟。快去改掉那些不属于你的元素吧。 更多推荐，打造个性博客更多主题：http://hexo.io/themes/博客图标网（就是我导航条的小图标）：http://fontawesome.io/icons/文章转自Codeagles的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react学习（1）]]></title>
      <url>%2F2017%2F02%2F27%2Freact%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[react特性- 虚拟DOM - 组件化 borwser.js 将JSX语法转换为js语法 react.js 核心库 react-dom.js 提供与dom有关的功能123&lt;script type="text/bable"&gt; //bable 转换编译器 &lt;/script&gt; JSX语法 借助React环境运行 jsx标签就是HTML标签 jsx语法转换， jsx -&gt; js 在jsx中运行js代码，js代码要用｛｝括起来 属性，设置样式，事件绑定 组件类 大写开头，驼峰命名 React.createClass（｛｝）方法创建组建类 每个组件必须实现自己的render方法，输入一个定义好的模版；返回值为null，false，组件模版 只能包含一个顶层标签123456789101112 var HelloReact = React.createClass(&#123; render:function()&#123; return ( &lt;h1&gt;组件&lt;/h1&gt; &lt;p&gt;内容&lt;/p&gt; ) &#125; &#125;) ReactDOM.render（ &lt;HelloReact /&gt;, document.getElementById(&quot;id&quot;);） 组件样式- 内联样式 - 对象样式 - 选择器样式 以，结尾；HTML以；结尾 key，中不能出现“-” key驼峰命名 value如果是字符串要加引号 value是数字，不需要带单位1234567891011121314151617181920212223242526//这个样式需要写在头部的style标签之内.xzq ｛ background: #fff;｝//样式对象var sty = &#123; height: 100, background: &apos;#f0f&apos;&#125;var HelloReact = React.createClass(&#123; render: function()&#123; return ( //内联样式 &lt;div style=&#123;&#123;background:&apos;#f00&apos;,height: 200&#125;&#125;&gt;内联样式和 //对象样式 &lt;div style=&#123;sty&#125;&gt;对象样式&lt;/div&gt; //选择器样式 &lt;div className=&quot;a&quot;&gt;选择器样式&lt;/div&gt; &lt;/div&gt;); &#125;&#125;);//渲染标签ReactDOM.render( &lt;HelloReact /&gt;, document.getElementById(&apos;container&apos;) ) 复合组件创建多个组建合成一个组建，首先定义子组件，然后定义复合组件 12345678910111213141516171819202122232425var WebName = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;蓝天白云&lt;/h1&gt; &#125;&#125;) var WebLink = React.createClass(&#123; render: function()&#123; return &lt;a href=&quot;#&quot;&gt;www.yuanjingzhuang.com&lt;/a&gt; &#125;&#125;)var WenShow = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;WebName/&gt; &lt;WebLink/&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;WenShow /&gt;, document.getElementById(&quot;container&quot;) )]]></content>
    </entry>

    
  
  
</search>
